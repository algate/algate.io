{"meta":{"title":"我是一张白纸","subtitle":"Algate's Blog","description":"这是algate的blog，algate就是我，我是一张白纸，我要用前端这支笔书写一段属于我的传奇。algate的博客。","author":"Algate","url":"https://algate.coding.me"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-02-27T03:27:59.511Z","updated":"2019-02-27T03:27:59.511Z","comments":false,"path":"/404.html","permalink":"https://algate.coding.me//404.html","excerpt":"","text":""},{"title":"分类","date":"2019-02-27T03:27:59.677Z","updated":"2019-02-27T03:27:59.677Z","comments":false,"path":"categories/index.html","permalink":"https://algate.coding.me/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-02-27T03:27:59.675Z","updated":"2019-02-27T03:27:59.675Z","comments":false,"path":"books/index.html","permalink":"https://algate.coding.me/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-02-27T03:27:59.670Z","updated":"2019-02-27T03:27:59.670Z","comments":false,"path":"about/index.html","permalink":"https://algate.coding.me/about/index.html","excerpt":"","text":"致力于网站建设与前端用户体验设计。喜欢新事物，关注前端动态，对新的技术有追求； 喜欢产品，喜欢设计，喜欢 coding。要想拥有一个充实的人生，你只有两种选择：从事自己喜欢的工作，或者，让自己喜欢上工作。稻盛和夫不想努力工作的人，永远觉得努力没用。他们总相信，人生有一条通向成功的捷径，却从来不相信，一个人必须非常努力，才能在职场随心所欲。1234567891011121314151617181920212223242526272829303132333435363738&#123; name: &apos;FE-onions&apos; age: 30, gender: &apos;男&apos;, profession: &apos;前端工程师&amp;WEB架构&amp;前端技术指导&apos;, experience: &apos;2014年初 to future&apos;, hometown: &apos;山西省孝义市&apos;, address: &apos;北京市&apos;, education: &apos;本科&apos;, github: &apos;https://github.com/algate&apos;, blog: &apos;https://algate.github.io&apos;, email: &apos;algate@foxmail.com&apos;, description: &apos; 进入前端行业，后悔了some days； 如果不干前端，我会后悔一辈子； 你问我为啥喜欢前端 &amp; 前端前景啥的？ ……&apos;, skills: [ [&apos;Html&apos;, &apos;Javascript&apos;, &apos;jQuery&apos;, &apos;CSS&apos;, &apos;ES6&apos;, &apos;Node&apos;], [&apos;Webpack&apos;, &apos;Gulp&apos;, &apos;Grunt&apos;], [&apos;Canvas&apos;, &apos;h5&apos;], [&apos;Vue&apos;, &apos;AngularJs&apos;, &apos;React&apos;], [&apos;Less&apos;,&apos;Sass&apos;], [&apos;Git&apos;, &apos;SVN&apos;], [&apos;Bootstrap&apos;, &apos;ElementUI&apos;, &apos;iView&apos;], [&apos;Hexo&apos;, &apos;Jekyll&apos;], [&apos;Photoshop&apos;, &apos;icon&apos;, &apos;Sublime Text&apos;] ], devTools: [ [&apos;Sublime Text&apos;, &apos;Visual Studio Code&apos;], [&apos;Chrome DevTools&apos;, &apos;Fiddler&apos;], [&apos;SourceTree&apos;, &apos;TortoiseSVN&apos;, &apos;Gerrit&apos;, &apos;Github&apos;, &apos;Git&apos;], [&apos;Navicat&apos;, &apos;XAMPP&apos;], [&apos;Poershell&apos;] ]&#125;"},{"title":"友情链接","date":"2019-02-27T03:27:59.844Z","updated":"2019-02-27T03:27:59.844Z","comments":true,"path":"links/index.html","permalink":"https://algate.coding.me/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-02-27T03:27:59.848Z","updated":"2019-02-27T03:27:59.848Z","comments":false,"path":"tags/index.html","permalink":"https://algate.coding.me/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-02-27T03:27:59.846Z","updated":"2019-02-27T03:27:59.846Z","comments":false,"path":"repository/index.html","permalink":"https://algate.coding.me/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"CSS3-flexbox","slug":"CSS3-FlexBox","date":"2018-12-14T08:35:30.000Z","updated":"2019-02-27T03:27:59.529Z","comments":true,"path":"2018/12/14/CSS3-FlexBox/","link":"","permalink":"https://algate.coding.me/2018/12/14/CSS3-FlexBox/","excerpt":"关于flex的内容不说太多，网上太多，再次只记录如何使用了只要用flex布局的，添加一下内容1234567891011121314151617/*设置body为伸缩容器*/display: -webkit-box;/*老版本：iOS 6-, Safari 3.1-6*/display: -moz-box;/*老版本：Firefox 19- */display: -ms-flexbox;/*混合版本：IE10*/display: -webkit-flex;/*新版本：Chrome*/display: flex;/*标准规范：Opera 12.1, Firefox 20+*//*伸缩项目换行*/-moz-box-orient: vertical || horizontal;-webkit-box-orient: vertical || horizontal;-moz-box-direction: normal || reverse;-webkit-box-direction: normal || reverse;-moz-box-lines: multiple || single;-webkit-box-lines: multiple || single;-webkit-flex-flow: column wrap || row / nowrap;-ms-flex-flow: column wrap || row / nowrap;flex-flow: column wrap || row / nowrap;","text":"关于flex的内容不说太多，网上太多，再次只记录如何使用了只要用flex布局的，添加一下内容1234567891011121314151617/*设置body为伸缩容器*/display: -webkit-box;/*老版本：iOS 6-, Safari 3.1-6*/display: -moz-box;/*老版本：Firefox 19- */display: -ms-flexbox;/*混合版本：IE10*/display: -webkit-flex;/*新版本：Chrome*/display: flex;/*标准规范：Opera 12.1, Firefox 20+*//*伸缩项目换行*/-moz-box-orient: vertical || horizontal;-webkit-box-orient: vertical || horizontal;-moz-box-direction: normal || reverse;-webkit-box-direction: normal || reverse;-moz-box-lines: multiple || single;-webkit-box-lines: multiple || single;-webkit-flex-flow: column wrap || row / nowrap;-ms-flex-flow: column wrap || row / nowrap;flex-flow: column wrap || row / nowrap;123456&lt;!-- 伸缩项目具体的分布方式 --&gt;-moz-box-pack: justify;-webkit-box-pack: justify;-ms-flex-pack: justify;-webkit-justify-content: space-between;justify-content: space-between;123456&lt;!-- 伸缩项目基线对其方式 --&gt;-moz-box-align: stretch || baseline || center || start || end;-webkit-box-align: stretch;-ms-flex-align: stretch;-webkit-align-items: stretch;align-items: stretch;需要注意的是：- 兼容性为主 - orient 另一个方向的字段为 horizontal(相对方向的水平) - box-line 只在一行显示改为single - flex-flow 是 flex-direction和 flex-wrap 缩写 行用 row 列用 column 不换行用 nowrap -stretch 伸缩项目拉伸填充整个伸缩容器 如果是伸缩子项目按照比例添加如下代码12345-moz-box-flex: 1;-webkit-box-flex: 1;-ms-flex: 1;-webkit-flex: 1;flex: 1;需要注意的是- 如果一个元素这是了宽度没有flex-1，那么剩下的将占用除去宽度意外的剩余空间 - 如果要这是排序 默认值是1开始的。 12345-moz-box-ordinal-group: 2;-webkit-box-ordinal-group: 2;-ms-flex-order: 2;-webkit-order: 2;order: 2;暂时先到这里，后期再加……","categories":[{"name":"CSS3","slug":"CSS3","permalink":"https://algate.coding.me/categories/CSS3/"}],"tags":[{"name":"flexbox","slug":"flexbox","permalink":"https://algate.coding.me/tags/flexbox/"}]},{"title":"Notation-语法","slug":"Notation-语法","date":"2018-11-09T03:46:30.000Z","updated":"2019-02-27T03:27:59.596Z","comments":true,"path":"2018/11/09/Notation-语法/","link":"","permalink":"https://algate.coding.me/2018/11/09/Notation-语法/","excerpt":"面试题引起的f*ckExamples[] is equal ![]Array is equal not array:[] == ![]; // -&gt; true ( What The f*ck Javascript )💡 Explanation:The abstract equality operator converts both sides to numbers to compare them, and both sides become the number 0 for different reasons. Arrays are truthy, so on the right, the opposite of a truthy value is false, which is then coerced to 0. On the left, however, an empty array is coerced to a number without becoming a boolean first, and empty arrays are coerced to 0, despite being truthy.Here is how this expression simplifies:+[] == +![];0 == +false;0 == 0;true;See also [] is truthy, but not true.","text":"面试题引起的f*ckExamples[] is equal ![]Array is equal not array:[] == ![]; // -&gt; true ( What The f*ck Javascript )💡 Explanation:The abstract equality operator converts both sides to numbers to compare them, and both sides become the number 0 for different reasons. Arrays are truthy, so on the right, the opposite of a truthy value is false, which is then coerced to 0. On the left, however, an empty array is coerced to a number without becoming a boolean first, and empty arrays are coerced to 0, despite being truthy.Here is how this expression simplifies:+[] == +![];0 == +false;0 == 0;true;See also [] is truthy, but not true.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://algate.coding.me/categories/Javascript/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://algate.coding.me/tags/语法/"}]},{"title":"HTML5 - 新增Api-History","slug":"HTML5-Api-History状态管理","date":"2018-06-17T07:21:30.000Z","updated":"2019-02-27T03:27:59.550Z","comments":true,"path":"2018/06/17/HTML5-Api-History状态管理/","link":"","permalink":"https://algate.coding.me/2018/06/17/HTML5-Api-History状态管理/","excerpt":"前端路由的实现方式前端路由主要由两种方式实现：location.hash+hashchange事件history.pushState()+popState事件hash+hashchange实现这种方法的好处在于支持IE浏览器。对早期的一些浏览器的支持比较好。实现原理：location.hash始终指向页面url 中#之后的内容当当前页面的url =www.baidu.com,可以在浏览器的控制台输入location.hash为空，当页面指向url =www.baidu.com/#/hello的时候,location.hash = #/hello。通过读取location.hash可以知道当前页面所处的位置。通过hashchange事件可以监听location.hash的变化，从而进行相应的处理即可。那么如何触发hash的改变呢？这里主要由两种方法：设置a标签，href =’#/blue’，当点击标签的时候，可以在当前url的后面增加上’#/blue’，同时触发hashchange,再回调函数中进行处理。直接在js中对location.hash =&#39;#/blue&#39;即可，此时url会改变，也会触发hashchange事件。下面给出一个通用的hash前端路由的实现方案：","text":"前端路由的实现方式前端路由主要由两种方式实现：location.hash+hashchange事件history.pushState()+popState事件hash+hashchange实现这种方法的好处在于支持IE浏览器。对早期的一些浏览器的支持比较好。实现原理：location.hash始终指向页面url 中#之后的内容当当前页面的url =www.baidu.com,可以在浏览器的控制台输入location.hash为空，当页面指向url =www.baidu.com/#/hello的时候,location.hash = #/hello。通过读取location.hash可以知道当前页面所处的位置。通过hashchange事件可以监听location.hash的变化，从而进行相应的处理即可。那么如何触发hash的改变呢？这里主要由两种方法：设置a标签，href =’#/blue’，当点击标签的时候，可以在当前url的后面增加上’#/blue’，同时触发hashchange,再回调函数中进行处理。直接在js中对location.hash =&#39;#/blue&#39;即可，此时url会改变，也会触发hashchange事件。下面给出一个通用的hash前端路由的实现方案：function Router() { this.currentUrl = &apos;&apos;; this.routes = {}; } Router.prototype.route = function(path, callback) { this.routes[path] = callback || function() {} } Router.prototype.refresh = function() { this.currentUrl = location.hash.slice(1) || &apos;/&apos;; this.routes[this.currentUrl](); } Router.prototype.init = function() { window.addEventListener(&apos;load&apos;, this.refresh.bind(this), false); window.addEventListener(&apos;hashchange&apos;, this.refresh.bind(this), false); // console.log(location.hash) // if(location.hash.slice(1)!==&apos;/&apos;) // location.hash = &apos;#/&apos;; } 上述定义了一个Router对象，在实例中可以这么使用：var route = new Router(); route.init(); function changecolor(color) { var body = document.getElementsByTagName(&apos;body&apos;)[0]; body.style[&apos;background-color&apos;] = color; } route.route(&apos;/&apos;, changecolor.bind(null, &apos;skyblue&apos;)); route.route(&apos;/blue&apos;, changecolor.bind(null, &apos;blue&apos;)); route.route(&apos;/green&apos;, changecolor.bind(null, &apos;green&apos;)); route.route(&apos;/color&apos;, function() { var p = document.getElementsByTagName(&apos;a&apos;); [].forEach.call(p, function(item) { item.style[&apos;color&apos;] = &apos;#&apos; + ((~~(Math.random() * (1 &lt;&lt; 24))).toString(16)); }) }); 新建一个Router的实例，进行初始化，然后进行url与callback的绑定，就可以在hash发生改变的时候出发触发相应的callback。这种方式支持浏览器的前进与后退。很好的解决了前后端分离之后的问题。这种方式有一个缺点就是#的存在，让一些人看了觉得不是很舒服，所以html给history新增了一些api，从而以一种更优雅的方式实现前端路由。history.pushState()+popstate跟之前的方法一样,pushState()修改url的地址，popstate监听地址的改变，不同的是，手动的进行pushState()并不会触发popstate事件。可以这样理解：1.用户点击了某个链接，触发ajax获取新的页面或者触发js中的某些操作，改变了dom结构。2.我们希望保存上一个页面，这时候我们就使用pushState(data,null,url)来将上一个页面的信息保存下来。3.当用户点击浏览器的前进或者后退的时候，触发popstate事件，可以读取到数据，然后进行该页面的操作或者ajax获取该页面的数据，也可以通过pushState()中的data来进行还原、更新。(function() { var div1 = document.getElementById(&apos;div1&apos;); var a1 = document.getElementById(&apos;a1&apos;); var a2 = document.getElementById(&apos;a2&apos;); var count1 = 0; var count2 = 0; //最开始的状态，采用replace直接替换 history.replaceState({ count1: count1, count2: count2 }, null, &apos;&apos;); a1.addEventListener(&apos;click&apos;, function() { count1++; //之后的状态，需要进行保存 history.pushState({ count1: count1, count2: count2 }, null, &apos;#/s&apos; + count1); a1.innerHTML = &apos;s&apos; + count1; }) a2.addEventListener(&apos;click&apos;, function() { count2++; //之后的状态，需要进行保存 history.pushState({ count1: count1, count2: count2 }, null, &apos;#/k&apos; + count2); a2.innerHTML = &apos;k&apos; + count2; }) window.addEventListener(&apos;popstate&apos;, function(e) { console.log(e.state); //监听popstate事件，对状态进行还原 a1.innerHTML = &apos;s&apos; + e.state.count1; a2.innerHTML = &apos;k&apos; + e.state.count2; }) })() 采用了立即执行函数来避免污染全局变量，其中点击一下a1,a2元素，均会进行pushState操作，在进行前进后退的时候，就会触发popstate事件，通过在该事件中对元素进行还原，优雅的解决了单页应用前进后退问题。演示地址：demo完整代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot; /&gt;&lt;head&gt;&lt;title&gt;pushState demo&lt;/title&gt;&lt;style&gt; body &#123; font-family: &quot;Microsoft YaHei&quot;; transition: background-color .3s; &#125; .bg-org &#123; color: #383c3c; background-color: #FF6633; &#125; .bg-blue &#123; color: #fbfaf5; background-color: #6699FF; &#125; .time &#123; margin-top: 20%; text-align: center; font-size: 4em; font-weight: 100; &#125; .switch &#123; margin: auto; width: 30px; height: 30px; position:absolute; bottom:25%; left:0; right:0; cursor:pointer; box-shadow: 0 0 0 5px rgba(255,255,255,.6); border-radius: 50%; transition: box-shadow .1s; &#125; .switch:hover &#123; box-shadow: 0 0 0 5px rgba(255,255,255,.75); &#125; .switch:active &#123; box-shadow: 0 0 0 30px rgba(255,255,255,.4); &#125;&lt;/style&gt;&lt;/head&gt;&lt;body class=&quot;bg-org&quot;&gt; &lt;h1 id=&quot;time&quot; class=&quot;time&quot;&gt;Loading...&lt;/h1&gt; &lt;div id=&quot;switch&quot; class=&quot;switch&quot;&gt;&lt;/div&gt;&lt;!-- 传统location方式 --&gt;&lt;!-- &lt;script&gt; if(urlParam(&apos;state&apos;)==&apos;blue&apos;) &#123; $(&apos;body&apos;).className = &apos;bg-blue&apos;; &#125; else &#123; $(&apos;body&apos;).className = &apos;bg-org&apos;; &#125; var time = $(&apos;#time&apos;); function $(selector) &#123;return document.querySelector(selector);&#125; // 显示当前时间 setInterval(function()&#123; var date = new Date(), format = function(n) &#123;return n&lt;10?&apos;0&apos;+n:n&#125;; time.innerHTML = format(date.getHours()) + &apos; : &apos; + format(date.getMinutes()) + &apos; : &apos; + format(date.getSeconds()); &#125;, 500); $(&apos;#switch&apos;).addEventListener(&apos;click&apos;, toggleState, false); function toggleState(e) &#123; var flag = $(&apos;body&apos;).className==&apos;bg-org&apos;?&apos;bg-blue&apos;:&apos;bg-org&apos;; window.location = location.pathname + &apos;?state=&apos; + flag.split(&apos;-&apos;)[1]; $(&apos;body&apos;).className = flag; &#125; /** * 获取url参数 * @param &#123;String&#125; name 参数名 * @return &#123;String&#125; 参数值 */ function getUrlParam(name)&#123; var reg, value; reg = new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;=([^&amp;]*)(&amp;|$)&quot;); value = window.location.search.substr(1).match(reg); return value==null?null:decodeURI(value[2]); &#125;&lt;/script&gt; --&gt;&lt;!-- popstate事件 --&gt; &lt;!-- &lt;script&gt; var time = $(&apos;#time&apos;); function $(selector) &#123;return document.querySelector(selector);&#125; // 显示当前时间 setInterval(function()&#123; var date = new Date(), format = function(n) &#123;return n&lt;10?&apos;0&apos;+n:n&#125;; time.innerHTML = format(date.getHours()) + &apos; : &apos; + format(date.getMinutes()) + &apos; : &apos; + format(date.getSeconds()); &#125;, 500); $(&apos;#switch&apos;).addEventListener(&apos;click&apos;, toggleState, false); // 监听popstate事件 history.pushState &amp;&amp; window.addEventListener(&quot;popstate&quot;, function(e) &#123; // 获取history.state对象中的状态信息 // 在这里state将自动成为event的子对象，可直接通过event.state访问 var flag = e.state &amp;&amp; e.state.title; $(&apos;body&apos;).className = flag || ($(&apos;body&apos;).className==&apos;bg-org&apos;?&apos;bg-blue&apos;:&apos;bg-org&apos;); &#125;, false); function toggleState(e) &#123; var flag = $(&apos;body&apos;).className==&apos;bg-org&apos;?&apos;bg-blue&apos;:&apos;bg-org&apos;; // 新建历史记录，将当前状态信息保存至history.state中 console.log(history); history.pushState &amp;&amp; history.pushState(&#123; title: flag &#125;, flag, &apos;?state=&apos;+flag.split(&apos;-&apos;)[1]); $(&apos;body&apos;).className = flag; &#125; &lt;/script&gt; --&gt; &lt;!-- hashchange事件 --&gt;&lt;script&gt; var time = $(&apos;#time&apos;); function $(selector) &#123;return document.querySelector(selector);&#125; // 显示当前时间 setInterval(function()&#123; var date = new Date(), format = function(n) &#123;return n&lt;10?&apos;0&apos;+n:n&#125;; time.innerHTML = format(date.getHours()) + &apos; : &apos; + format(date.getMinutes()) + &apos; : &apos; + format(date.getSeconds()); &#125;, 500); // 监听onhashchange事件 window.addEventListener(&quot;hashchange&quot;, function(e) &#123; // 获取hash值判断页面状态 var flag = location.hash &amp;&amp; location.hash.substring(1); console.log(flag); $(&apos;body&apos;).className = &apos;bg-&apos;+flag || ($(&apos;body&apos;).className==&apos;bg-org&apos;?&apos;bg-blue&apos;:&apos;bg-org&apos;); &#125;, false); $(&apos;#switch&apos;).addEventListener(&apos;click&apos;, toggleState, false); function toggleState(e) &#123; var flag = $(&apos;body&apos;).className==&apos;bg-org&apos;?&apos;bg-blue&apos;:&apos;bg-org&apos;; // 在url中写入新的hash值 location.hash = flag.split(&apos;-&apos;)[1]; $(&apos;body&apos;).className = flag; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML5","slug":"HTML5","permalink":"https://algate.coding.me/categories/HTML5/"}],"tags":[{"name":"History历史状态管理","slug":"History历史状态管理","permalink":"https://algate.coding.me/tags/History历史状态管理/"}]},{"title":"HTML5 - 新增Api","slug":"HTML5-新增Api","date":"2018-06-15T10:05:30.000Z","updated":"2019-02-27T03:27:59.552Z","comments":true,"path":"2018/06/15/HTML5-新增Api/","link":"","permalink":"https://algate.coding.me/2018/06/15/HTML5-新增Api/","excerpt":"1. H5新增选择器( SelectorsAPI )querySelector(“body / #mydiv / .selected / img .fig / [title=hello]”)参数：一个CSS选择符 “img .layer”返回类为”fig”的第一个img元素;返回：匹配到的第一个元素调用：Document类型，Element类型浏览器的兼容性：IE8+、FireFox3.5+、Safari3.1+、Chrome和Opera10+querySelectorAll()","text":"1. H5新增选择器( SelectorsAPI )querySelector(“body / #mydiv / .selected / img .fig / [title=hello]”)参数：一个CSS选择符 “img .layer”返回类为”fig”的第一个img元素;返回：匹配到的第一个元素调用：Document类型，Element类型浏览器的兼容性：IE8+、FireFox3.5+、Safari3.1+、Chrome和Opera10+querySelectorAll()参数：也是一个CSS选择符返回：一个NodeList实例调用：Document类型，Element类型和DocumentFragment类型浏览器的兼容性：IE8+、FireFox3.5+、Safari3.1+、Chrome和Opera10+document.getElementByClass(“className”)参数：一个或多个类名的字符串返回：一个NodeList实例调用：Document类型浏览器的兼容性：IE9+Element.classList 属性返回: 该元素的class属性值的列表，返回的列表是一个类似数组的对象,存在length属性返回的对象存在操作class值的方法：add(value): 将给定的字符串value,添加class 属性列表, 若已存在，就不添加 remove(value): 从列表中删除value toggle(value): 切换class，即：存在时删除，不存在时添加 contains(value): 判断列表中是否存在value 浏览器的兼容性：Firefox3.6+ 和 Chrome2. 焦点管理 - H5添加了辅助管理DOM焦点的功能。1）document.activeElement属性，该属性引用DOM中当前获得了焦点的元素元素获得焦点的方式：页面加载（文档刚刚加载完成时，document.activeElement保存的是document.body元素的引用，文档加载期间为null）用户输入在代码中调用focus()方法, 如 button.focus()。2）document.hasFocus() 方法，用于确定文档是否获得了焦点，获得了焦点时为true,否则为false通过检测文档是否获得了焦点，可以知道用户是不是正在与页面交互，提高Web应用的无障碍性。浏览器兼容性：IE4+ 、Firefox 3+ 、 Safari 4+ 、Chrome和 Opera 8+3. 自定义数据属性HTML5规定，可以为元素添加非标准的属性，但要添加前缀data-,目的是为元素提供与渲染无关的信息，或者提供语义信息。这些属性可以任意添加、随便命名，只要以data开头即可。&lt;div id=&quot;mydiv&quot; data-app=&quot;12&quot; data-myname=&quot;Lily&quot; data-my-sex=&quot;女&quot;&gt;&lt;/div&gt; 访问和设置自定义属性：//通过元素的dataset属性，该属性返回值是DOMStringMap, 即一个名值对的映射 alert ( div.dataset.app ) ; //输出”12” div.dataset.app=”34”; alert ( div.dataset.myname ) ; //输出”Lily” div.dataset.myname=”Jack”; alert ( div.dataset.mySex ); //输出”女” div.dataset.mySex=”men”; //驼峰式 自定义数据属性的作用：实现HTML标签与JS的交互相分离，根据不同属性值，实现不同的效果。如：库jquery mobile, AngularJS4. 延迟加载JS外部 JS作为body元素的最后一个标签加入HTML，不影响文档页面加载的速度如果给&lt;script&gt;标签添加defer属性，则该标签引入的JS外部文件加载会延迟到onload事件触发之前完成。如果给&lt;script&gt;标签添加async属性, JS文件会异步加载，多个JS文件都添加该属性时，执行顺序不一定，那个先加载完执行哪个，这是就会出现函数找不到的问题。一般用于JS文件之间是并行关系时使用，如加载广告5. 历史状态管理 - onhashchange &amp; pushState || replaceState1) 通过用户跳转页面的操作，改变历史状态管理：在现代Web应用中，用户的每次操作不一定打开一个全新的页面，因此”后退”和”前进”按钮也就失去了作用，导致用户很难在不同的状态间切换。2）在网页URL后面添加hash值参数，改变历史状态管理：如baidu.com#aaaaaaa通过window.location.hash访问和设置URL的参数列表alert (window.location.hash) //输出当前页面的参数列表 “#aaaaaaa” H5新增了hashchange 事件，以便在URL的参数列表（及URL中” # “号后面的所有字符串）发生变化时，通知开发人员。新增这个事件，是因为在Ajax应用中，开发人员经常要利用URL参数列表来保存状态或导航信息。必须把onhashchange 事件绑定到window对象上。浏览器兼容性：IE8+ ,Firefox3.6+, Safari5+, Chrome和Opera10.6+&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() { var oInput = document.getElementById(&apos;input1&apos;); var oDiv = document.getElementById(&apos;div1&apos;); var json = {}; oInput.onclick = function() { var num = Math.random(); //产生0-1之间的随机数 var arr = randomNum(35, 7); //产生7个由1-35之间的整数组成的随机数 json[num] = arr; console.log(json); // oDiv.innerHTML = arr; window.location.hash = num; //设置当前网页网址URL的hash值 }; window.onhashchange = function() { console.log(window.location.hash); oDiv.innerHTML = json[window.location.hash.substring(1)]; }; function randomNum(iAll, iNow) { var arr = []; var newArr = []; for (var i = 1; i &lt;= iAll; i++) { arr.push(i); } for (var i = 0; i &lt; iNow; i++) { newArr.push(arr.splice(Math.floor(Math.random() * arr.length), 1)); } return newArr; } }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; type=&quot;button&quot; value=&quot;随机选择&quot; id=&quot;input1&quot;&gt; &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 3) 通过history对象的pushState()方法可以创建新的历史状态,通过window的popstate事件对象的state属性可以获得作为第一个参数传递给pushState()方法的状态对象。replaceState()方法：重写当前状态，参数与 pushState()方法的前两个参数相同。详细操作更新：现在HTML5规范为window.history引入了两个新api，pushState和replaceState，我们可以使用它很方便的达到改变url不重载页面的目的。未完待续…https://blog.csdn.net/helloxiaoliang/article/details/73850428浏览器兼容性：Firefox4+,Safari5+, Opera11.5+和Chrome支持。6.HTMLDocument的变化readyStateIE4首先为document设置了readyState属性，其他浏览器也陆续增加了这个属性，HTML最终将这个属性写入了标准。在IE中，document的readyState属性包括两个值：[1]loading：正在载入文档[2]complete：文档加载结束我们看下标准中对readyState的阐述：在firefox、chrome等浏览器中，loading和complete之间还有一个interactive状态，我们看一下MDN中对interactive状态的阐述：The document has finished loading and the document has been parsed but sub-resources such as images, stylesheets and frames are still loading. The state indicates that theDOMContentLoaded event has been fired.也就是说，文档本身已经被加载完毕，并且也已经被解析完毕，但是像image,css style文件等外部资源还在下载，这时意味着DOMContentLoaded事件的触发。在readyState状态的改变会触发readystatechange事件，我们可以通过为document绑定readystatechange事件来监听其状态的变化。注：IE4+,Firefox3.6+,chrome,Opera9+,Safari支持这两个属性","categories":[{"name":"HTML5","slug":"HTML5","permalink":"https://algate.coding.me/categories/HTML5/"}],"tags":[{"name":"HTML5相关Api","slug":"HTML5相关Api","permalink":"https://algate.coding.me/tags/HTML5相关Api/"}]},{"title":"JS进阶 - JS实现数组去重方法总结","slug":"JS-实现数组去重方法总结","date":"2018-06-15T05:48:30.000Z","updated":"2019-02-27T03:27:59.564Z","comments":true,"path":"2018/06/15/JS-实现数组去重方法总结/","link":"","permalink":"https://algate.coding.me/2018/06/15/JS-实现数组去重方法总结/","excerpt":"方法一：双层循环，外层循环元素，内层循环时比较值如果有相同的值则跳过，不相同则push进数组Array.prototype.distinct = function() { var arr = this, result = [], i, j, len = arr.length; for (i = 0; i &lt; len; i++) { for (j = i + 1; j &lt; len; j++) { if (arr[i] === arr[j]) { j = ++i; } } result.push(arr[i]); } return result; } var arra = [1, 2, 3, 4, 4, 1, 1, 2, 1, 1, 1]; arra.distinct(); //返回[3,4,2,1]","text":"方法一：双层循环，外层循环元素，内层循环时比较值如果有相同的值则跳过，不相同则push进数组Array.prototype.distinct = function() { var arr = this, result = [], i, j, len = arr.length; for (i = 0; i &lt; len; i++) { for (j = i + 1; j &lt; len; j++) { if (arr[i] === arr[j]) { j = ++i; } } result.push(arr[i]); } return result; } var arra = [1, 2, 3, 4, 4, 1, 1, 2, 1, 1, 1]; arra.distinct(); //返回[3,4,2,1] 方法二：利用splice直接在原数组进行操作双层循环，外层循环元素，内层循环时比较值值相同时，则删去这个值注意点:删除元素之后，需要将数组的长度也减1.Array.prototype.distinct = function() { var arr = this, i, j, len = arr.length; for (i = 0; i &lt; len; i++) { for (j = i + 1; j &lt; len; j++) { if (arr[i] == arr[j]) { arr.splice(j, 1); len--; j--; } } } return arr; }; var a = [1, 2, 3, 4, 5, 6, 5, 3, 2, 4, 56, 4, 1, 2, 1, 1, 1, 1, 1, 1, ]; var b = a.distinct(); console.log(b.toString()); //1,2,3,4,5,6,56 方法三：利用对象的属性不能相同的特点进行去重Array.prototype.distinct = function() { var arr = this, i, obj = {}, result = [], len = arr.length; for (i = 0; i &lt; arr.length; i++) { if (!obj[arr[i]]) { //如果能查找到，证明数组元素重复了 obj[arr[i]] = 1; result.push(arr[i]); } } return result; }; var a = [1, 2, 3, 4, 5, 6, 5, 3, 2, 4, 56, 4, 1, 2, 1, 1, 1, 1, 1, 1, ]; var b = a.distinct(); console.log(b.toString()); //1,2,3,4,5,6,56 方法四：数组递归去重运用递归的思想先排序，然后从最后开始比较，遇到相同，则删除Array.prototype.distinct = function() { var arr = this, len = arr.length; arr.sort(function(a, b) { //对数组进行排序才能方便比较 return a - b; }) function loop(index) { if (index &gt;= 1) { if (arr[index] === arr[index - 1]) { arr.splice(index, 1); } loop(index - 1); //递归loop函数进行去重 } } loop(len - 1); return arr; }; var a = [1, 2, 3, 4, 5, 6, 5, 3, 2, 4, 56, 4, 1, 2, 1, 1, 1, 1, 1, 1, 56, 45, 56]; var b = a.distinct(); console.log(b.toString()); //1,2,3,4,5,6,45,56 方法五：利用indexOf以及forEachArray.prototype.distinct = function() { var arr = this, result = [], len = arr.length; arr.forEach(function(v, i, arr) { //这里利用map，filter方法也可以实现 var bool = arr.indexOf(v, i + 1); //从传入参数的下一个索引值开始寻找是否存在重复 if (bool === -1) { result.push(v); } }) return result; }; var a = [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 2, 2, 1, 23, 1, 23, 2, 3, 2, 3, 2, 3]; var b = a.distinct(); console.log(b.toString()); //1,23,2,3 方法六：利用ES6的setSet数据结构，它类似于数组，其成员的值都是唯一的。利用Array.from将Set结构转换成数组ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构。Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。function dedupe(array){ return Array.from(new Set(array)); } dedupe([1,1,2,3]) //[1,2,3] 拓展运算符(…)内部使用for…of循环let arr = [1,2,3,3]; let resultarr = [...new Set(arr)]; console.log(resultarr); //[1,2,3]","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://algate.coding.me/categories/Javascript/"}],"tags":[{"name":"数组去重","slug":"数组去重","permalink":"https://algate.coding.me/tags/数组去重/"}]},{"title":"三剑客-angular、vue、react比较","slug":"三剑客-AngularVueReact比较","date":"2018-06-11T10:01:30.000Z","updated":"2019-02-27T03:27:59.661Z","comments":true,"path":"2018/06/11/三剑客-AngularVueReact比较/","link":"","permalink":"https://algate.coding.me/2018/06/11/三剑客-AngularVueReact比较/","excerpt":"比较 Angular、React、Vue 三剑客为 web 应用选择 JavaScript 开发框架是一件很费脑筋的事。现如今 Angular 和 React 非常流行，并且最近出现的新贵 VueJS 同样博得了很多人的关注。更重要的是，这只是一些新起之秀。在开始之前 —— 是否应用单页 Web 应用开发？首先你需要弄明白你需要单页面应用程序（SPA）还是多页面的方式。关于这个问题的详细内容请阅读我的博客文章，“单页面应用程序（SPA）与多页 Web 应用程序（MPA）”。具体对比分析：","text":"比较 Angular、React、Vue 三剑客为 web 应用选择 JavaScript 开发框架是一件很费脑筋的事。现如今 Angular 和 React 非常流行，并且最近出现的新贵 VueJS 同样博得了很多人的关注。更重要的是，这只是一些新起之秀。在开始之前 —— 是否应用单页 Web 应用开发？首先你需要弄明白你需要单页面应用程序（SPA）还是多页面的方式。关于这个问题的详细内容请阅读我的博客文章，“单页面应用程序（SPA）与多页 Web 应用程序（MPA）”。具体对比分析：*单页面应用（SinglePage Web Application，SPA）多页面应用（MultiPage Application，MPA）组成一个外壳页面和多个页面片段组成多个完整页面构成资源共用(css,js)共用，只需在外壳部分加载不共用，每个页面都需要加载刷新方式页面局部刷新或更改整页刷新url 模式a.com/#/pageone a.com/#/pagetwoa.com/pageone.html a.com/pagetwo.html用户体验页面片段间的切换快，用户体验良好页面切换加载缓慢，流畅度不够，用户体验比较差转场动画容易实现无法实现数据传递容易依赖 url传参、或者cookie 、localStorage等搜索引擎优化(SEO)需要单独方案、实现较为困难、不利于SEO检索 可利用服务器端渲染(SSR)优化实现方法简易试用范围高要求的体验度、追求界面流畅的应用适用于追求高度支持搜索引擎的应用开发成本较高，常需借助专业的框架较低 ，但页面重复代码多维护成本相对容易相对复杂以下是我们今天要解决的问题：这些框架或库有多成熟？ 这些框架只会火热一时吗？ 这些框架相应的社区规模有多大，能得到多少帮助？ 找到每个框架开发者容易吗？ 这些框架的基本编程概念 是什么？ 对于小型或大型应用程序，框架是否易用？ 每个框架学习曲线什么样？ 你期望这些框架的性能怎么样？ 在哪能仔细了解底层原理？ 你可以用你选择的框架开发吗？ 生命周期与战略考虑Angular是基于 TypeScript 的 Javascript 框架。由 Google 进行开发和维护，它被描述为“超级厉害的 JavaScript MVW 框架”。Angular（也被称为 “Angular 2+”，“Angular 2” 或者 “ng2”）已被重写，是与 AngularJS（也被称为 “Angular.js” 或 “AngularJS 1.x”）不兼容的后续版本。当 AngularJS（旧版本）最初于2010年10月发布时，仍然在修复 bug，等等 —— 新的 Angular（sans JS）于 2016 年 9 月推出版本 2。最新的主版本是 4，因为版本 3 被跳过了。Google，Vine，Wix，Udemy，weather.com，healthcare.gov 和 Forbes 都使用 Angular（根据 madewithangular，stackshare 和 libscore.com 提供的数据）。React被描述为 “用于构建用户界面的 JavaScript 库”。React 最初于 2013 年 3 月发布，由 Facebook 进行开发和维护，Facebook 在多个页面上使用 React 组件（但不是作为单页应用程序）。根据 Chris Cordle 这篇文章的统计，React 在 Facebook 上的使用远远多于 Angular 在 Google 上的使用。React 还被 Airbnb，Uber，Netflix，Twitter，Pinterest，Reddit，Udemy，Wix，Paypal，Imgur，Feedly，Stripe，Tumblr，Walmart 等使用（根据 Facebook, stackshare 和 libscore.com 提供的数据）。Facebook 正在开发 React Fiber。它会改变 React 的底层 - 渲染速度应该会更快 - 但是在变化之后，版本会向后兼容。Facebook 将会在 2017 年 4 月的开发者大会上讨论新变化，并发布一篇非官方的关于新架构的文章。React Fiber 可能与 React 16 一起发布。Vue是 2016 年发展最为迅速的 JS 框架之一。Vue 将自己描述为一款“用于构建直观，快速和组件化交互式界面的 MVVM 框架”。它于 2014 年 2 月首次由 Google 前员工 Evan You 发布（顺便说一句：尤雨溪那时候发表了一篇 vue 发布首周的营销活动和数据的博客文章）。尤其是考虑到 Vue 在没有大公司的支持的情况下，作为一个人开发的框架还能获得这么多的吸引力，这无疑是非常成功的。尤雨溪目前有一个包含数十名核心开发者的团队。2016 年，版本 2 发布。Vue 被阿里巴巴，百度，Expedia，任天堂，GitLab 使用 — 可以在 madewithvuejs.com 找到一些小型项目的列表。Angular 和 Vue 都遵守 MIT license 许可，而 React 遵守 BSD3-license 许可证。在专利文件上有很多讨论。James Ide（前 Facebook 工程师）解释专利文件背后的原因和历史：Facebook 的专利授权是在保护自己免受专利诉讼的能力的同时分享其代码。专利文件被更新了一次，有些人声称，如果你的公司不打算起诉 Facebook，那么使用 React 是可以的。你可以在 Github 的这个 issue 上 查看讨论。我不是律师，所以如果 React 许可证对你或你的公司有问题，你应该自己决定。关于这个话题还有很多文章：Dennis Walsh 写到，你为什么不该害怕。Raúl Kripalani 警告：反对创业公司使用 React，他还写了一篇备忘录概览。此外，Facebook 上还有一个最新的声明：解释 React 的许可证。核心开发如前所述，Angular 和 React 得到大公司的支持和使用。Facebook，Instagram 和 WhatsApp 正在它们的页面使用 React。Google 在很多项目中使用 Angular，例如，新的 Adwords 用户界面是使用 Angular 和 Dart。然而，Vue 是由一群通过 Patreon 和其他赞助方式支持的个人实现的，是好坏你自己确定。Matthias Götzke 认为 Vue 小团队的好处是用了更简洁和更少的过度设计的代码或 API。我们来看看一些统计数据：Angular 在团队介绍页列出 36 人，Vue 列出 16 人，而 React 没有团队介绍页。在 Github 上，Angular 有 25,000+ 的 star 和 463 位代码贡献者，React 有 70,000+ 的 star 和 1,000+ 位代码贡献者，而 Vue 有近 60,000 的 star 和只有 120 位代码贡献者。你也可以查看 Angular，React 和 Vue 的 Github Star 历史。又一次说明 Vue 的趋势似乎很好。根据 bestof.js 提供的数据显示，在过去三个月 Angular 2 平均每天获得 31 个 star，React 74 个，Vue.JS 107 个。那我们试试别的吧。ThoughtWorks 的 Technology Radar 技术随时间推移的变化。ThoughtWorks 的 Technology Radar 随着时间推移，技术的演进过程给人深刻的印象。Redux 是在采用阶段（被 ThoughtWorks 项目采用的！），它在许多 ThoughtWorks 项目中的价值是不可估量的。Vue.js 是在试用阶段（被试着用的）。Vue被描述为具有平滑学习曲线的，轻量级并具灵活性的Angular的替代品。Angular 2 是正在处于评估阶段 使用 —— 已被 ThoughtWork 团队成功实践，但是还没有被强烈推荐。根据 2017 年 Stackoverflow 的最新调查，被调查的开发者中，喜爱 React 有 67%，喜欢 AngularJS 的有 52%。“没有兴趣在开发中继续使用”的开发者占了更高的数量，AngularJS（48%）和 React（33%）。在这两种情况下，Vue 都不在前十。然后是 statejs.com 关于比较 “前端框架” 的调查。最有意思的事实是：React 和 Angular 有 100% 的认知度，23% 的受访者不了解 Vue。关于满意度，92% 的受访者愿意“再次使用” React ，Vue 有 89% ,而 Angular 2 只有 65%。长期支持和迁移Facebook 在其设计原则中指出，React API 非常稳定。还有一些脚本可以帮助你从当前的API移到更新的版本：请查阅 react-codemod。迁移是非常容易的，没有这样的东西（需要）作为长期支持的版本。在 Reddit 这篇文章中指出，人们看到到升级从来不是问题。React 团队写了一篇关于他们版本控制方案的博客文章。当他们添加弃用警告时，在下一个主要版本中的行为发生更改之前，他们会保留当前版本的其余部分。没有计划更改为新的主要版本 - v14 于 2015 年 10 月发布，v15 于 2016 年 4 月发布，而 v16 还没有发布日期。（译者注：v16 于 2017 年 9 月底发布）最近 React核心开发人员指出，升级不应该是一个问题。关于 Angular，从 v2 发布开始，有一篇关于版本管理和发布 Angular 的博客文章。每六个月会有一次重大更新，至少有六个月的时间（两个主要版本）。在文档中有一些实验性的 API 被标记为较短的弃用期。目前还没有官方公告，但根据这篇文章，Angular 团队已经宣布了以 Angular 4 开始的长期支持版本。这些将在下一个主要版本发布之后至少一年得到支持。这意味着至少在 2018 年 9 月之前，将支持 Angular 4，并提供 bug 修复和重要补丁。在大多数情况下，将 Angular 从 v2 更新到 v4 与更新 Angular 依赖关系一样简单。Angular 还提供了有关是否需要进一步更改的信息指南。Vue 1.x 到 2.0 的更新过程对于一个小应用程序来说应该很容易 - 开发者团队已经声称 90% 的 API 保持不变。在控制台上有一个很好的升级 - 诊断迁移 - 辅助工具。一位开发人员指出，从 v1 到 v2 的更新在大型应用程序中仍然没有挑战。不幸的是，关于 LTS 版本的下一个主要版本或计划信息没有清晰的（公共）路径。还有一件事：Angular 是一个完整的框架，提供了很多捆绑在一起的东西。React 比 Angular 更灵活，你可能会使用更多独立的，不稳定的，快速更新的库 - 这意味着你需要自己维护相应的更新和迁移。如果某些包不再被维护，或者其他一些包在某些时候成为事实上的标准，这也可能是不利的。React，Angular 和 Vue 的比较组件我们所讨论的框架都是基于组件的。一个组件得到一个输入，并且在一些内部的行为/计算之后，它返回一个渲染的 UI 模板（一个登录/注销区或一个待办事项列表项）作为输出。定义的组件应该易于在网页或其他组件中重用。例如，你可以使用具有各种属性（列，标题信息，数据行等）的网格组件（由一个标题组件和多个行组件组成），并且能够在另一个页面上使用具有不同数据集的组件。这里有一篇关于组件的综合性文章，如果你想了解更多这方面的信息。React 和 Vue 都擅长处理组件：小型的无状态的函数接收输入和返回元素作为输出。Typescript，ES6 与 ES5React专注于使用 Javascript ES6。Vue 使用 Javascript ES5 或 ES6。Angular 依赖于 TypeScript。这在相关示例和开源项目中提供了更多的一致性（React 示例可以在 ES5 或 ES6 中找到）。这也引入了像装饰器和静态类型的概念。静态类型对于代码智能工具非常有用，比如自动重构，跳转到定义等等 - 它们也可以减少应用程序中的错误数量，尽管这个话题当然没有共识。Eric Elliott 在他的文章 “静态类型的令人震惊的秘密” 中不同意上面的观点。Daniel C Wang 表示，使用静态类型并没有什么坏处，同时有测试驱动开发（TDD）和静态类型挺好的。你也应该知道你可以使用 Flow 在 React 中启用类型检查。这是 Facebook 为 JavaScript 开发的静态类型检查器。Flow 也可以集成到 VueJS 中。如果你在用 TypeScript 编写代码，那么你不需要再编写标准的 JavaScript 了。尽管它在不断发展，但与整个 JavaScript 语言相比，TypeScript 的用户群仍然很小。一个风险可能是你正在向错误的方向发展，因为 TypeScript 可能 - 也许不太可能 - 随着时间的推移也会消失。此外，TypeScript 为项目增加了很多（学习）开销 - 你可以在 Eric Elliott 的 Angular 2 vs. React 比较 中阅读更多关于这方面的内容。更新: James Ravenscroft 在对这篇文章的评论中写道，TypeScript 对 JSX 有一流的支持 - 可以无缝地对组件进行类型检查。所以，如果你喜欢 TypeScript 并且你想使用 React，这应该不成问题。模板 —— JSX 还是 HTMLReact打破了长期以来的最佳实践。几十年来，开发人员试图分离 UI 模板和内联的 Javascript 逻辑，但是使用 JSX，这些又被混合了。这听起来很糟糕，但是你应该听彼得·亨特（Peter Hunt）的演讲 “React：反思最佳实践”（2013 年 10 月）。他指出，分离模板和逻辑仅仅是技术的分离，而不是关注的分离。你应该构建组件而不是模板。组件是可重用的、可组合的、可单元测试的。JSX 是一个类似 HTML 语法的可选预处理器，并随后在 JavaScript 中进行编译。JSX 有一些怪癖 —— 例如，你需要使用 className 而不是 class，因为后者是 Javascript 的保留字。JSX 对于开发来说是一个很大的优势，因为代码写在同一个地方，可以在代码完成和编译时更好地检查工作成果。当你在 JSX 中输入错误时，React 将不会编译，并打印输出错误的行号。Angular 2 在运行时静默失败（如果使用 Angular 中的预编译，这个参数可能是无效的）。JSX 意味着 React 中的所有内容都是 Javascript – 用于JSX模板和逻辑。Cory House 在 2016 年 1 月的文章 中指出：“Angular 2 继续把 ‘JS’ 放到 HTML 中。React 把 ‘HTML’ 放到 JS 中。“这是一件好事，因为 Javascript 比 HTML 更强大。Angular 模板使用特殊的 Angular 语法（比如 ngIf 或 ngFor）来增强 HTML。虽然 React 需要 JavaScript 的知识，但 Angular 会迫使你学习 Angular 特有的语法。Vue 具有“单个文件组件”。这似乎是对于关注分离的权衡 - 模板，脚本和样式在一个文件中，但在三个不同的有序部分中。这意味着你可以获得语法高亮，CSS 支持以及更容易使用预处理器（如 Jade 或 SCSS）。我已经阅读过其他文章，JSX 更容易调试，因为 Vue 不会显示不规范 HTML 的语法错误。这是不正确的，因为 Vue 转换 HTML 来渲染函数 - 所以错误显示没有问题（感谢 Vinicius Reis 的评论和更正！）。旁注：如果你喜欢 JSX 的思路，并想在 Vue 中使用它，可以使用 babel-plugin-transform-vue-jsx。框架和库Angular 是一个框架而不是一个库，因为它提供了关于如何构建应用程序的强有力的约束，并且还提供了更多开箱即用的功能。Angular 是一个 “完整的解决方案” - 功能齐全，你可以愉快的开始开发。你不需要研究库，路由解决方案或类似的东西 - 你只要开始工作就好了。另一方面，React 和 Vue 是很灵活的。他们的库可以和各种包搭配。（在 npm 上有很多 React 的包，但 Vue 的包比较少，因为毕竟这个框架还比较新）。有了 React，你甚至可以交换库本身的 API 兼容替代品，如 Inferno。然而，灵活性越大，责任就越大 - React 没有规则和有限的指导。每个项目都需要决定架构，而且事情可能更容易出错。另一方面，Angular 还有一个令人困惑的构建工具，样板，检查器（linter）和时间片来处理。如果使用项目初始套件或样板，React 也是如此。他们自然是非常有帮助的，但是 React 可以开箱即用，这也许是你应该学习的方式。有时，在 JavaScript 环境中工作要使用各种工具被称为 “Javascript 疲劳症”。Eric Clemmons 在他的文章 中说：当开始使用框架，还有一堆安装的工具，你可能会不习惯。这些都是框架生成的。很多开发人员不明白，框架内部发生了什么 —— 或者需要花费很多时间才能搞明白。Vue 似乎是三个框架中最轻量的。GitLab 有一篇关于 Vue.js（2016 年 10 月）的决定的博客文章：Vue.js 完美的兼顾了它将为你做什么和你需要做什么。（…）Vue.js 始终是可及的，一个坚固，但灵活的安全网，保证编程效率和把操作 DOM 造成的痛苦降到最低。他们喜欢简单易用 —— 源代码非常易读，不需要任何文档或外部库。一切都非常简单。Vue.js “对任何东西都不做大的假设”。还有一个关于 GitLab 决定的播客节目。另一个来自 Pixeljets 的关于向 Vue 转变的博文。React “是 JS 界在意识层面向前迈出的一大步，它以一种实用简洁的方式向人们展示了真正的函数式编程。和 Vue 相比，React 的一大缺点是由于 JSX 的限制，组件的粒度会更小。这里是文章的引述：对于我和我的团队来说，代码的可读性是很重要的，但编写代码很有趣也是非常重要的。在实现真正简单的计算器小部件时创建 6 个组件并不奇怪。在许多情况下，在维护，修改或对某个小部件进行可视化检查方面也是不好的，因为你需要绕过多个文件/函数并分别检查每个小块的 HTML。再次，我不是建议写巨石 - 我建议在日常开发中使用组件而不是微组件。关于 Hacker news 和 Reddit 上的博客文章有趣的讨论 - 有来自 Vue 的持异议者和进一步支持者的争论。状态管理和数据绑定构建用户界面很困难，因为处处都有状态 - 随着时间的推移而变化的数据带来了复杂性。定义的状态工作流程对于应用程序的增长和复杂性有很大的帮助。对于复杂度不大的应用程序，就不必定义的状态流了，像原生 JS 就足够了。它是如何工作的？组件在任何时间点描述 UI。当数据改变时，框架重新渲染整个 UI 组件 - 显示的数据始终是最新的。我们可以把这个概念称为“ UI 即功能”。React 经常与 Redux 在一起使用。Redux 以三个基本原则来自述：单一数据源（Single source of truth）State 是只读的（State is read-only）使用纯函数执行修改（Changes are made with pure functions）换句话说：整个应用程序的状态存储在单个 store 的状态树中。这有助于调试应用程序，一些功能更容易实现。状态是只读的，只能通过 action 来改变，以避免竞争条件（这也有助于调试）。编写 Reducer 来指定如何通过 action 来转换 state。大多数教程和样板文件都已经集成了 Redux，但是如果没有它，你可以使用 React（你可能不需要在你的项目中使用 Redux）。Redux 在代码中引入了复杂性和相当强的约束。如果你正在学习React，那么在你要使用 Redux 之前，你应该考虑学习纯粹的 React。你绝对应该阅读 Dan Abramov 的“你可能不需要 Redux”。有些开发人员 建议使用 Mobx 代替 Redux。你可以把它看作是一个 “自动的 Redux”，这使得事情一开始就更容易使用和理解。如果你想了解，你应该从介绍开始。你也可以阅读 Robin 的 Redux 和 MobX 的比较。他还提供了有关从 Redux 迁移到 MobX 的信息。如果你想查找其他 Flux 库，这个列表非常有用。如果你是来自 MVC 的世界，那么你应该阅读 Mikhail Levkovsky 的文章“Redux 中的思考（当你所知道的是 MVC）”。Vue 可以使用 Redux，但它提供了 Vuex 作为自己的解决方案。React 和 Angular 之间的巨大差异是 单向与双向绑定。当 UI 元素（例如，用户输入）被更新时，Angular 的双向绑定改变 model 状态。React 只有一种方法：先更新 model，然后渲染 UI 元素。Angular 的方式实现起来代码更干净，开发人员更容易实现。React 的方式会有更好的数据总览，因为数据只能在一个方向上流动（这使得调试更容易）。这两个概念各有优劣。你需要了解这些概念，并确定这是否会影响你选择框架。文章“双向数据绑定：Angular 2 和 React”和这个 Stackoverflow 上的问题都提供了一个很好的解释。在这里你可以找到一些交互式的代码示例（3 年前的示例（，只适用于 Angular 1 和 React）。最后，Vue 支持单向绑定和双向绑定（默认为单向绑定）。如果你想进一步阅读，这有一篇长文，是有关状态的不同类型和 Angular 应用程序中的状态管理（Victor Savkin）。其他的编程概念Angular 包含依赖注入（dependency injection），即一个对象将依赖项（服务）提供给另一个对象（客户端）的模式。这导致更多的灵活性和更干净的代码。文章 “理解依赖注入” 更详细地解释了这个概念。模型 - 视图 - 控制器模式（MVC）将项目分为三个部分：模型，视图和控制器。Angular（MVC 模式的框架）有开箱即用的 MVC 特性。React 只有 V —— 你需要自己解决 M 和 C。灵活性与精简到微服务你可以通过仅仅添加 React 或 Vue 的 JavaScript 库到你的源码中的方式去使用它们。但是由于 Angular 使用了 TypeScript，所以不能这样使用 Angular。现在我们正在更多地转向微服务和微应用。React 和 Vue 通过只选择真正需要的东西，你可以更好地控制应用程序的大小。它们提供了更灵活的方式去把一个老应用的一部分从单页应用（SPA）转移到微服务。Angular 最适合单页应用（SPA），因为它可能太臃肿而不能用于微服务。正如 Cory House 所说:JavaScript 发展速度很快，而且 React 可以让你将应用程序的一小部分替换成更好用的 JS 库，而不是期待你的框架能够创新。小巧，可组合的单一用途工具的理念永远不会过时。有些人对非单页的网站也使用 React（例如复杂的表单或向导）。甚至 Facebook 都没有把 React 用在 Facebook 的主页，而是用在特定的页面，实现特定的功能。体积和性能任何框架都不会十全十美：Angular 框架非常臃肿。gzip 文件大小为 143k，而 Vue 为 23K，React 为 43k。为了提高性能，React 和 Vue 都使用了虚拟 DOM（Virtual DOM）。如果你对此感兴趣，可以阅读虚拟 DOM 和 DOM 之间的差异以及 react.js 中虚拟 DOM 的实际优势。此外，虚拟 DOM 的作者之一在 Stackoverflow 上回答了性能的相关问题。为了检查性能，我看了一下最佳的 js 框架基准。你可以自己下载并运行它，或者查看交互式结果表。Angular，React 和 Vue 性能比较（源文件）内存分配（源文件）总结一下：Vue 有着很好的性能和高深的内存分配技巧。如果比较快慢的话，这些框架都非常接近（比如 Inferno）。请记住，性能基准只能作为考虑的附注，而不是作为判断标准。测试Facebook 使用 Jest 来测试其 React 代码。这里有篇 Jest 和 Mocha 之间的比较的文章 —— 还有一篇关于 Enzyme 和 Mocha 如何一起使用 的文章。Enzyme 是 Airbnb 使用的 JavaScript 测试工具（与 Jest，Karma 和其他测试框架一起使用）。如果你想了解更多，有一些关于在 React（这里和这里）测试的旧文章。Angular 2 中使用 Jasmine 作为测试框架。Eric Elliott 在一篇文章中抱怨说 Jasmine “有数百种测试和断言的方式，需要仔细阅读每一个，来了解它在做什么”。输出也是非常臃肿和难以阅读。有关 Angular 2 与 Karma 和 Mocha 的整合的一些有用的文章。这里有一个关于 Angular 2 测试策略的旧视频（从2015年起）。Vue 缺乏测试指导，但是 Evan 在 2017 年的展望中写道，团队计划在这方面开展工作。他们推荐使用 Karma。Vue 和 Jest 结合使用，还有 avoriaz 作为测试工具。通用与原生 app通用 app 正在将应用程序引入 web、搬上桌面，同样将深入原生 app 的世界。React 和 Angular 都支持原生开发。Angular 拥有用于原生应用的 NativeScript（由 Telerik 支持）和用于混合开发的 Ionic 框架。借助 React，你可以试试 react-native-renderer 来构建跨平台的 iOS 和 Android 应用程序，或者用 react-native 开发原生 app。许多 app（包括 Facebook；查看更多的展示）都是用 react-native 构建的。Javascript 框架在客户端上渲染页面。这对于性能，整体用户体验和 SEO 是不利的。服务器端预渲染是一个好办法。所有这三个框架都有相应的库来实现服务端渲染。React 有 next.js，Vue 有 nuxt.js，而 Angular 有…… Angular Universal。学习曲线Angular 的学习曲线确实很陡。它有全面的文档，但你仍然可能被吓哭，因为说起来容易做起来难。即使你对 Javascript 有深入的了解，也需要了解框架的底层原理。去初始化项目是很神奇的，它会引入很多的包和代码。因为有一个大的，预先存在的生态系统，你需要随着时间的推移学习，这很不利。另一方面，由于已经做出了很多决定，所以在特定情况下可能会很好。对于 React，你可能需要针对第三方库进行大量重大决策。仅仅 React 中就有 16 种不同的 flux 软件包来用于状态管理可供选择。Vue 学习起来很容易。公司转向 Vue 是因为它对初级开发者来说似乎更容易一些。这里有一片说他们团队为什么从 Angular 转到 Vue的文章。另一位用户表示，他公司的 React 应用程序非常复杂，以至于新开发人员无法跟上代码。有了 Vue，初级和高级开发人员之间的差距缩小了，他们可以更轻松地协作，减少 bug，减少解决问题的时间。有些人说他们用 React 做的东西比用 Vue 做的更好。如果你是一个没有经验的 Javascript 开发人员 - 或者如果你在过去十年中主要使用 jQuery，那么你应该考虑使用 Vue。转向 React 时，思维方式的转换更为明显。Vue 看起来更像是简单的 Javascript，同时也引入了一些新的概念：组件，事件驱动模型和单向数据流。这同样是很小的部分。同时，Angular 和 React 也有自己的实现方式。它们可能会限制你，因为你需要调整自己的做法，才能顺畅的开发。这可能是一个缺点，因为你不能随心所欲，而且学习曲线陡峭。这也可能是一个好处，因为你在学习技术时必须学习正确的概念。用 Vue，你可以用老方法来做。这一开始可能会比较容易上手，但长此以往会出现问题。在调试方面，React 和 Vue 的黑魔法更少是一个加分项。找出 bug 更容易，因为需要看的地方少了，堆栈跟踪的时候，自己的代码和那些库之间有更明显的区别。使用 React 的人员报告说，他们永远不必阅读库的源代码。但是，在调试 Angular 应用程序时，通常需要调试 Angular 的内部来理解底层模型。从好的一面来看，从 Angular 4 开始，错误信息应该更清晰，更具信息性。Angular, React 和 Vue 底层原理你想自己阅读源代码吗？你想看看事情到底是怎么样的吗？可能首先要查看 Github 仓库: React（github.com/facebook/re…）、Angular（github.com/angular/ang…）和 Vue（github.com/vuejs/vue）。语法看起来怎么样？ValueCoders 比较 Angular，React 和 Vue 的语法。在生产环境中查看也很容易 —— 连同底层的源代码。TodoMVC 列出了几十个相同的 Todo 应用程序，用不同的 Javascript 框架编写 —— 你可以比较 Angular，React 和 Vue 的解决方案。RealWorld 创建了一个真实世界的应用程序（中仿），他们已经准备好了 Angular（4+）和 React（带 Redux ）的解决方案。Vue 的开发正在进行中。你可以看到许多真实的 app，以下是 React 的方案：Do（一款很好用的笔记管理 app，用 React 和 Redux 实现）sound-redux（用 React 和 Redux 实现的 Soundcloud 客户端）Brainfock（用 React 实现的项目和团队管理解决方案）react-hn 和 react-news（仿 Hacker news）react-native-whatsapp-ui 和 教程（仿 Whatsapp 的 react-native 版）phoenix-trello（仿 Trello）slack-clone 和其他教程 (仿Slack)以下是 Angular 版的 app：angular2-hn 和 hn-ng2（仿 Hacker News，另一个由 Ashwin Sureshkumar 创建的很好的教程）Redux-and-angular-2（仿 Twitter）以下是 Vue 版的 app：vue-hackernews-2.0 和 Loopa news（仿Hacker News）vue-soundcloud（Soundcloud 演示）","categories":[{"name":"其他","slug":"其他","permalink":"https://algate.coding.me/categories/其他/"}],"tags":[{"name":"三剑客","slug":"三剑客","permalink":"https://algate.coding.me/tags/三剑客/"}]},{"title":"继承","slug":"JS进阶-继承","date":"2018-06-09T07:46:30.000Z","updated":"2019-02-27T05:20:32.582Z","comments":true,"path":"2018/06/09/JS进阶-继承/","link":"","permalink":"https://algate.coding.me/2018/06/09/JS进阶-继承/","excerpt":"引用网上的一张图简单概括就四句话1.实例的proto === 构造函数的prototype2.构造函数的proto === Function.prototye3.构造函数原型(Array.prototype)的proto === Object.prototype(对象的原型)4.Object.prototype.proto === null;js中有三种继承方式1.js原型（prototype）实现继承12345678910111213141516171819202122232425&lt;html&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; function Person(name,age)&#123; this.name=name; this.age=age; &#125; Person.prototype.sayHello=function()&#123; alert(&quot;使用原型得到Name：&quot;+this.name); &#125; var per=new Person(&quot;马小倩&quot;,21); per.sayHello(); //输出：使用原型得到Name:马小倩 function Student()&#123;&#125; Student.prototype=new Person(&quot;洪如彤&quot;,21); var stu=new Student(); Student.prototype.grade=5; Student.prototype.intr=function()&#123; alert(this.grade); &#125; stu.sayHello();//输出：使用原型得到Name:洪如彤 stu.intr();//输出：5&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","text":"引用网上的一张图简单概括就四句话1.实例的proto === 构造函数的prototype2.构造函数的proto === Function.prototye3.构造函数原型(Array.prototype)的proto === Object.prototype(对象的原型)4.Object.prototype.proto === null;js中有三种继承方式1.js原型（prototype）实现继承12345678910111213141516171819202122232425&lt;html&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; function Person(name,age)&#123; this.name=name; this.age=age; &#125; Person.prototype.sayHello=function()&#123; alert(&quot;使用原型得到Name：&quot;+this.name); &#125; var per=new Person(&quot;马小倩&quot;,21); per.sayHello(); //输出：使用原型得到Name:马小倩 function Student()&#123;&#125; Student.prototype=new Person(&quot;洪如彤&quot;,21); var stu=new Student(); Student.prototype.grade=5; Student.prototype.intr=function()&#123; alert(this.grade); &#125; stu.sayHello();//输出：使用原型得到Name:洪如彤 stu.intr();//输出：5&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;2.构造函数实现继承1234567891011121314151617181920212223242526&lt;html&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; function Parent(name)&#123; this.name=name; this.sayParent=function()&#123; alert(&quot;Parent:&quot;+this.name); &#125; &#125; function Child(name,age)&#123; this.tempMethod=Parent; this.tempMethod(name); this.age=age; this.sayChild=function()&#123; alert(&quot;Child:&quot;+this.name+&quot;age:&quot;+this.age); &#125; &#125; var parent=new Parent(&quot;江剑臣&quot;); parent.sayParent(); //输出：“Parent:江剑臣” var child=new Child(&quot;李鸣&quot;,24); //输出：“Child:李鸣 age:24” child.sayChild();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;3.call , apply实现继承12345678910111213141516171819202122232425262728293031323334353637&lt;html&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; function Person(name,age,love)&#123; this.name=name; this.age=age; this.love=love; this.say=function say()&#123; alert(&quot;姓名：&quot;+name); &#125; &#125; //call方式 function student(name,age)&#123; Person.call(this,name,age); &#125; //apply方式 function teacher(name,love)&#123; Person.apply(this,[name,love]); //Person.apply(this,arguments); //跟上句一样的效果，arguments &#125; //call与aplly的异同： //1,第一个参数this都一样,指当前对象 //2,第二个参数不一样：call的是一个个的参数列表；apply的是一个数组（arguments也可以） var per=new Person(&quot;武凤楼&quot;,25,&quot;魏荧屏&quot;); //输出：“武凤楼” per.say(); var stu=new student(&quot;曹玉&quot;,18);//输出：“曹玉” stu.say(); var tea=new teacher(&quot;秦杰&quot;,16);//输出：“秦杰” tea.say();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;有如下代码：123456789var A = function(x) &#123; this.x = x;&#125;A.prototype.say = function() &#123; console.log(this.x);&#125;a = new A(3);a.say();console.log(a);如果改成es6的写法：class A { constructor(x){ this.x = x; } say(){ console.log(this.x); } } 我们要定义一个B，让B继承A的方法；12345678// B继承Avar B = function(x) &#123; A.call(this, x) // 继承x&#125;B.prototype = new A(); // 继承A的原型var b = new B(5);b.say();console.log(b);如果写成es6语法的继承：// C继承Aclass C extends A{}; var c = new C(6); c.say(); console.log(c); 把数字转换成数组class NumPrototype { constructor(x) { this.x = x; } get iterate() { return this.iterateF(); } iterateF () { var result = []; for (var i = 0; i &lt;= this.x; i++) { result.push(i); } return result; } }; var no = new NumPrototype(8); var arr = no.iterate; console.log(arr, no.iterate);","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://algate.coding.me/categories/Javascript/"}],"tags":[{"name":"继承","slug":"继承","permalink":"https://algate.coding.me/tags/继承/"}]},{"title":"Js - 事件委托","slug":"Js-事件委托","date":"2018-06-08T10:41:30.000Z","updated":"2019-02-27T03:27:59.580Z","comments":true,"path":"2018/06/08/Js-事件委托/","link":"","permalink":"https://algate.coding.me/2018/06/08/Js-事件委托/","excerpt":"原文地址：js中的事件委托或是事件代理详解那什么叫事件委托呢？它还有一个名字叫事件代理，JavaScript高级程序设计上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。那这是什么意思呢？网上的各位大牛们讲事件委托基本上都用了同一个例子，就是取快递来解释这个现象，我仔细揣摩了一下，这个例子还真是恰当，我就不去想别的例子来解释了，借花献佛，我摘过来，大家认真领会一下事件委托到底是一个什么原理：有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。","text":"原文地址：js中的事件委托或是事件代理详解那什么叫事件委托呢？它还有一个名字叫事件代理，JavaScript高级程序设计上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。那这是什么意思呢？网上的各位大牛们讲事件委托基本上都用了同一个例子，就是取快递来解释这个现象，我仔细揣摩了一下，这个例子还真是恰当，我就不去想别的例子来解释了，借花献佛，我摘过来，大家认真领会一下事件委托到底是一个什么原理：有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。这里其实还有2层意思的：第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的；第二，新员工也是可以被前台MM代为签收的，即程序中新添加的dom节点也是有事件的。为什么要用事件委托：一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了（内存不够用，是硬伤，哈哈），比如上面的100个li，就要占用100个内存空间，如果是1000个，10000个呢，那只能说呵呵了，如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，是不是省了很多，自然性能就会更好。事件委托的原理：事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。事件委托怎么实现：终于到了本文的核心部分了，哈哈，在介绍事件委托的方法之前，我们先来看一段一般方法的例子：子节点实现相同的功能：&lt;ul id=&quot;ul1&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt; &lt;/ul&gt; 实现功能是点击li，弹出123：window.onload = function(){ var oUl = document.getElementById(&quot;ul1&quot;); var aLi = oUl.getElementsByTagName(&apos;li&apos;); for(var i=0;i&lt;aLi.length;i++){ aLi[i].onclick = function(){ alert(123); } } } 上面的代码的意思很简单，相信很多人都是这么实现的，我们看看有多少次的dom操作，首先要找到ul，然后遍历li，然后点击li的时候，又要找一次目标的li的位置，才能执行最后的操作，每次点击都要找一次li；那么我们用事件委托的方式做又会怎么样呢？window.onload = function(){ var oUl = document.getElementById(&quot;ul1&quot;); oUl.onclick = function(){ alert(123); } } 这里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发，当然，这里当点击ul的时候，也是会触发的，那么问题就来了，如果我想让事件代理的效果跟直接给节点的事件效果一样怎么办，比如说只有点击li才会触发，不怕，我们有绝招：Event对象提供了一个属性叫target，可以返回事件的目标节点，我们成为事件源，也就是说，target就可以表示为当前的事件操作的dom，但是不是真正操作dom，当然，这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较（习惯问题）：window.onload = function(){ var oUl = document.getElementById(&quot;ul1&quot;); oUl.onclick = function(ev){ var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == &apos;li&apos;){ alert(123); alert(target.innerHTML); } } } 这样改下就只有点击li会触发事件了，且每次只执行一次dom操作，如果li数量很多的话，将大大减少dom的操作，优化的性能可想而知！上面的例子是说li操作的是同样的效果，要是每个li被点击的效果都不一样，那么用事件委托还有用吗？&lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;add&quot; value=&quot;添加&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;remove&quot; value=&quot;删除&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;move&quot; value=&quot;移动&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;select&quot; value=&quot;选择&quot; /&gt; &lt;/div&gt; jswindow.onload = function(){ var Add = document.getElementById(&quot;add&quot;); var Remove = document.getElementById(&quot;remove&quot;); var Move = document.getElementById(&quot;move&quot;); var Select = document.getElementById(&quot;select&quot;); Add.onclick = function(){ alert(&apos;添加&apos;); }; Remove.onclick = function(){ alert(&apos;删除&apos;); }; Move.onclick = function(){ alert(&apos;移动&apos;); }; Select.onclick = function(){ alert(&apos;选择&apos;); } } 上面实现的效果我就不多说了，很简单，4个按钮，点击每一个做不同的操作，那么至少需要4次dom操作，如果用事件委托，能进行优化吗？window.onload = function(){ var oBox = document.getElementById(&quot;box&quot;); oBox.onclick = function (ev) { var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLocaleLowerCase() == &apos;input&apos;){ switch(target.id){ case &apos;add&apos; : alert(&apos;添加&apos;); break; case &apos;remove&apos; : alert(&apos;删除&apos;); break; case &apos;move&apos; : alert(&apos;移动&apos;); break; case &apos;select&apos; : alert(&apos;选择&apos;); break; } } } } 用事件委托就可以只用一次dom操作就能完成所有的效果，比上面的性能肯定是要好一些的现在讲的都是document加载完成的现有dom节点下的操作，那么如果是新增的节点，新增的节点会有事件吗？也就是说，一个新员工来了，他能收到快递吗？看一下正常的添加节点的方法：这是一般的做法，但是你会发现，新增的li是没有事件的，说明添加子节点的时候，事件没有一起添加进去，这不是我们想要的结果，那怎么做呢？一般的解决方案会是这样，将for循环用一个函数包起来，命名为mHover，如下：window.onload = function(){ var oBtn = document.getElementById(&quot;btn&quot;); var oUl = document.getElementById(&quot;ul1&quot;); var aLi = oUl.getElementsByTagName(&apos;li&apos;); var num = 4; function mHover () { //鼠标移入变红，移出变白 for(var i=0; i&lt;aLi.length;i++){ aLi[i].onmouseover = function(){ this.style.background = &apos;red&apos;; }; aLi[i].onmouseout = function(){ this.style.background = &apos;#fff&apos;; } } } //添加新节点 oBtn.onclick = function(){ num++; var oLi = document.createElement(&apos;li&apos;); oLi.innerHTML = 111*num; oUl.appendChild(oLi); mHover (); }; } 虽然功能实现了，看着还挺好，但实际上无疑是又增加了一个dom操作，在优化性能方面是不可取的，那么有事件委托的方式，能做到优化吗？window.onload = function(){ var oBtn = document.getElementById(&quot;btn&quot;); var oUl = document.getElementById(&quot;ul1&quot;); var aLi = oUl.getElementsByTagName(&apos;li&apos;); var num = 4; //事件委托，添加的子元素也有事件 oUl.onmouseover = function(ev){ var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == &apos;li&apos;){ target.style.background = &quot;red&quot;; } }; oUl.onmouseout = function(ev){ var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == &apos;li&apos;){ target.style.background = &quot;#fff&quot;; } }; //添加新节点 oBtn.onclick = function(){ num++; var oLi = document.createElement(&apos;li&apos;); oLi.innerHTML = 111*num; oUl.appendChild(oLi); }; } 看，上面是用事件委托的方式，新添加的子元素是带有事件效果的，我们可以发现，当用事件委托的时候，根本就不需要去遍历元素的子节点，只需要给父级元素添加事件就好了，其他的都是在js里面的执行，这样可以大大的减少dom操作，这才是事件委托的精髓所在。————————————————–华丽的分割线———————————————————在这里先感谢一下@苍茫大地NV 的提问，提的问题非常好！👏👏👏他的问题是：现在给一个场景 ul &gt; li &gt; div &gt; p，div占满li，p占\b满div，还是给ul绑定时间，需要判断点击的是不是li（假设li里面的结构是不固定的），那么e.target就可能是p，也有可能是div，这种情况你会怎么处理呢？&lt;ul id=&quot;test&quot;&gt; &lt;li&gt; &lt;p&gt;11111111111&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;div&gt; 22222222 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;3333333333&lt;/span&gt; &lt;/li&gt; &lt;li&gt;4444444&lt;/li&gt; &lt;/ul&gt; 如上列表，有4个li，里面的内容各不相同，点击li，event对象肯定是当前点击的对象，怎么指定到li上，下面我直接给解决方案：var oUl = document.getElementById(‘test’);oUl.addEventListener(‘click’,function(ev){var target = ev.target;while(target !== oUl ){if(target.tagName.toLowerCase() == ‘li’){console.log(‘li click~’);break;}target = target.parentNode;}})核心代码是while循环部分，实际上就是一个递归调用，你也可以写成一个函数，用递归的方法来调用，同时用到冒泡的原理，从里往外冒泡，知道currentTarget为止，当当前的target是li的时候，就可以执行对应的事件了，然后终止循环，恩，没毛病！这里看不到效果，大家可以复制过去运行一下！总结：那什么样的事件可以用事件委托，什么样的事件不可以用呢？适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在不如说focus，blur之类的，本身就没用冒泡的特性，自然就不能用事件委托了。好了，今天就到这里，下次我想介绍一下事件绑定，欢迎大家关注和阅读，以上纯属个人见解，如有不对的地方，万望指正，不胜感谢！","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://algate.coding.me/categories/Javascript/"}],"tags":[{"name":"事件委托","slug":"事件委托","permalink":"https://algate.coding.me/tags/事件委托/"}]},{"title":"ES6-async 函数","slug":"ES6-async函数","date":"2018-06-08T10:01:30.000Z","updated":"2019-02-27T03:27:59.535Z","comments":true,"path":"2018/06/08/ES6-async函数/","link":"","permalink":"https://algate.coding.me/2018/06/08/ES6-async函数/","excerpt":"async 函数是什么？一句话，它就是 Generator 函数的语法糖。const gen = function* () { const f1 = yield readFile(&apos;/etc/fstab&apos;); const f2 = yield readFile(&apos;/etc/shells&apos;); console.log(f1.toString()); console.log(f2.toString()); }; 写成async函数，就是下面这样。const asyncReadFile = async function () { const f1 = await readFile(&apos;/etc/fstab&apos;); const f2 = await readFile(&apos;/etc/shells&apos;); console.log(f1.toString()); console.log(f2.toString()); };","text":"async 函数是什么？一句话，它就是 Generator 函数的语法糖。const gen = function* () { const f1 = yield readFile(&apos;/etc/fstab&apos;); const f2 = yield readFile(&apos;/etc/shells&apos;); console.log(f1.toString()); console.log(f2.toString()); }; 写成async函数，就是下面这样。const asyncReadFile = async function () { const f1 = await readFile(&apos;/etc/fstab&apos;); const f2 = await readFile(&apos;/etc/shells&apos;); console.log(f1.toString()); console.log(f2.toString()); }; 一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。async函数对 Generator 函数的改进，体现在以下四点。（1）内置执行器。Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。asyncReadFile(); 上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。（2）更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。（3）更广的适用性。co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。（4）返回值是 Promise。async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。2.基本用法async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。async 函数有多种使用形式。// 函数声明 async function foo() {} // 函数表达式 const foo = async function () {}; // 对象的方法 let obj = { async foo() {} }; obj.foo().then(...) // Class 的方法 class Storage { constructor() { this.cachePromise = caches.open(&apos;avatars&apos;); } async getAvatar(name) { const cache = await this.cachePromise; return cache.match(`/avatars/${name}.jpg`); } } const storage = new Storage(); storage.getAvatar(&apos;jake&apos;).then(…); // 箭头函数 const foo = async () =&gt; {}; 3.语法async函数的语法规则总体上比较简单，难点是错误处理机制。返回 Promise 对象async函数返回一个 Promise 对象。async函数内部return语句返回的值，会成为then方法回调函数的参数。","categories":[{"name":"Es6","slug":"Es6","permalink":"https://algate.coding.me/categories/Es6/"}],"tags":[{"name":"async","slug":"async","permalink":"https://algate.coding.me/tags/async/"},{"name":"await","slug":"await","permalink":"https://algate.coding.me/tags/await/"}]},{"title":"ES6-Class 的基本语法","slug":"ES6-Class的基本语法","date":"2018-06-07T10:01:30.000Z","updated":"2019-02-27T03:27:59.532Z","comments":true,"path":"2018/06/07/ES6-Class的基本语法/","link":"","permalink":"https://algate.coding.me/2018/06/07/ES6-Class的基本语法/","excerpt":"JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。function Point(x, y) { this.x = x; this.y = y; } Point.prototype.toString = function () { return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; }; var p = new Point(1, 2);","text":"JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。function Point(x, y) { this.x = x; this.y = y; } Point.prototype.toString = function () { return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; }; var p = new Point(1, 2); ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。//定义类 class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; } }","categories":[{"name":"Es6","slug":"Es6","permalink":"https://algate.coding.me/categories/Es6/"}],"tags":[{"name":"Class","slug":"Class","permalink":"https://algate.coding.me/tags/Class/"}]},{"title":"Js - 判断对象还是数组","slug":"Js-判断对象还是数组","date":"2018-06-07T06:36:30.000Z","updated":"2019-02-27T03:27:59.583Z","comments":true,"path":"2018/06/07/Js-判断对象还是数组/","link":"","permalink":"https://algate.coding.me/2018/06/07/Js-判断对象还是数组/","excerpt":"1.对于Javascript 1.8.5（ECMAScript 5），变量名字.isArray( )可以实现这个目的var a=[]; var b={}; Array.isArray(a);//true Array.isArray(b)//false","text":"1.对于Javascript 1.8.5（ECMAScript 5），变量名字.isArray( )可以实现这个目的var a=[]; var b={}; Array.isArray(a);//true Array.isArray(b)//false 2.如果你只是用typeof来检查该变量，不论是array还是object，都将返回‘objec’。 此问题的一个可行的答案是是检查该变量是不是object，并且检查该变量是否有数字长度（当为空array时长度也可能为0,object的长度为undefined）。var a=[]; var b={}; typeof a === &apos;object&apos; &amp;&amp; !isNaN(a.length)//true typeof b === &apos;object&apos; &amp;&amp; !isNaN(b.length)//false 3.调用toString( )方法试着将该变量转化为代表其类型的string。var a=[]; var b={}; Object.prototype.toString.call(a) === &apos;[object Array]&apos;//true Object.prototype.toString.call(b) === &apos;[object Array]&apos;//false","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://algate.coding.me/categories/Javascript/"}],"tags":[{"name":"判断对象","slug":"判断对象","permalink":"https://algate.coding.me/tags/判断对象/"}]},{"title":"Js - 代码规范","slug":"Js-代码规范","date":"2018-06-04T07:59:30.000Z","updated":"2019-02-27T03:27:59.582Z","comments":true,"path":"2018/06/04/Js-代码规范/","link":"","permalink":"https://algate.coding.me/2018/06/04/Js-代码规范/","excerpt":"本文来自百度代码规范。值得借鉴。JavaScript编码规范1 前言2 代码风格2.1 文件2.2 结构2.2.1 缩进2.2.2 空格2.2.3 换行2.2.4 语句","text":"本文来自百度代码规范。值得借鉴。JavaScript编码规范1 前言2 代码风格2.1 文件2.2 结构2.2.1 缩进2.2.2 空格2.2.3 换行2.2.4 语句2.3 命名2.4 注释2.4.1 单行注释2.4.2 多行注释2.4.3 文档化注释2.4.4 类型定义2.4.5 文件注释2.4.6 命名空间注释2.4.7 类注释2.4.8 函数/方法注释2.4.9 事件注释2.4.10 常量注释2.4.11 复杂类型注释2.4.12 AMD 模块注释2.4.13 细节注释3 语言特性3.1 变量3.2 条件3.3 循环3.4 类型3.4.1 类型检测3.4.2 类型转换3.5 字符串3.6 对象3.7 数组3.8 函数3.8.1 函数长度3.8.2 参数设计3.8.3 闭包3.8.4 空函数3.9 面向对象3.10 动态特性3.10.1 eval3.10.2 动态执行代码3.10.3 with3.10.4 delete3.10.5 对象属性4 浏览器环境4.1 模块化4.1.1 AMD4.1.2 define4.1.3 require4.2 DOM4.2.1 元素获取4.2.2 样式获取4.2.3 样式设置4.2.4 DOM 操作4.2.5 DOM 事件1 前言JavaScript在百度一直有着广泛的应用，特别是在浏览器端的行为管理。本文档的目标是使JavaScript代码风格保持一致，容易被理解和被维护。虽然本文档是针对JavaScript设计的，但是在使用各种JavaScript的预编译语言时(如TypeScript等)时，适用的部分也应尽量遵循本文档的约定。2 代码风格2.1 文件[建议] JavaScript 文件使用无 BOM 的 UTF-8 编码。解释：UTF-8 编码具有更广泛的适应性。BOM 在使用程序或工具处理文件时可能造成不必要的干扰。[建议] 在文件结尾处，保留一个空行。2.2 结构2.2.1 缩进[强制] 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格 或 tab 字符。[强制] switch 下的 case 和 default 必须增加一个缩进层级。示例：12345678910111213141516171819202122232425262728293031// goodswitch (variable) &#123; case '1': // do... break; case '2': // do... break; default: // do...&#125;// badswitch (variable) &#123;case '1': // do... break;case '2': // do... break;default: // do...&#125;2.2.2 空格[强制] 二元运算符两侧必须有一个空格，一元运算符与操作对象之间不允许有空格。示例：123var a = !arr.length;a++;a = b + c;[强制] 用作代码块起始的左花括号 { 前必须有一个空格。示例：12345678910111213141516171819// goodif (condition) &#123;&#125;while (condition) &#123;&#125;function funcName() &#123;&#125;// badif (condition)&#123;&#125;while (condition)&#123;&#125;function funcName()&#123;&#125;[强制] if / else / for / while / function / switch / do / try / catch / finally 关键字后，必须有一个空格。示例：12345678910111213141516171819// goodif (condition) &#123;&#125;while (condition) &#123;&#125;(function () &#123;&#125;)();// badif(condition) &#123;&#125;while(condition) &#123;&#125;(function() &#123;&#125;)();[强制] 在对象创建时，属性中的 : 之后必须有空格，: 之前不允许有空格。示例：12345678910111213// goodvar obj = &#123; a: 1, b: 2, c: 3&#125;;// badvar obj = &#123; a : 1, b:2, c :3&#125;;[强制] 函数声明、具名函数表达式、函数调用中，函数名和 ( 之间不允许有空格。示例：1234567891011121314151617// goodfunction funcName() &#123;&#125;var funcName = function funcName() &#123;&#125;;funcName();// badfunction funcName () &#123;&#125;var funcName = function funcName () &#123;&#125;;funcName ();[强制] , 和 ; 前不允许有空格。示例：12345// goodcallFunc(a, b);// badcallFunc(a , b) ;[强制] 在函数调用、函数声明、括号表达式、属性访问、if / for / while / switch / catch 等语句中，() 和 [] 内紧贴括号部分不允许有空格。示例：12345678910111213141516171819202122232425262728// goodcallFunc(param1, param2, param3);save(this.list[this.indexes[i]]);needIncream &amp;&amp; (variable += increament);if (num &gt; list.length) &#123;&#125;while (len--) &#123;&#125;// badcallFunc( param1, param2, param3 );save( this.list[ this.indexes[ i ] ] );needIncreament &amp;&amp; ( variable += increament );if ( num &gt; list.length ) &#123;&#125;while ( len-- ) &#123;&#125;[强制] 单行声明的数组与对象，如果包含元素，{} 和 [] 内紧贴括号部分不允许包含空格。解释：声明包含元素的数组与对象，只有当内部元素的形式较为简单时，才允许写在一行。元素复杂的情况，还是应该换行书写。示例：1234567891011121314151617// goodvar arr1 = [];var arr2 = [1, 2, 3];var obj1 = &#123;&#125;;var obj2 = &#123;name: 'obj'&#125;;var obj3 = &#123; name: 'obj', age: 20, sex: 1&#125;;// badvar arr1 = [ ];var arr2 = [ 1, 2, 3 ];var obj1 = &#123; &#125;;var obj2 = &#123; name: 'obj' &#125;;var obj3 = &#123;name: 'obj', age: 20, sex: 1&#125;;[强制] 行尾不得有多余的空格。2.2.3 换行[强制] 每个独立语句结束后必须换行。[强制] 每行不得超过 120 个字符。解释：超长的不可分割的代码允许例外，比如复杂的正则表达式。长字符串不在例外之列。[强制] 运算符处换行时，运算符必须在新行的行首。示例：1234567891011121314151617181920212223// goodif (user.isAuthenticated() &amp;&amp; user.isInRole('admin') &amp;&amp; user.hasAuthority('add-admin') || user.hasAuthority('delete-admin')) &#123; // Code&#125;var result = number1 + number2 + number3 + number4 + number5;// badif (user.isAuthenticated() &amp;&amp; user.isInRole('admin') &amp;&amp; user.hasAuthority('add-admin') || user.hasAuthority('delete-admin')) &#123; // Code&#125;var result = number1 + number2 + number3 + number4 + number5;[强制] 在函数声明、函数表达式、函数调用、对象创建、数组创建、for语句等场景中，不允许在 , 或 ; 前换行。示例：1234567891011121314151617181920212223242526// goodvar obj = &#123; a: 1, b: 2, c: 3&#125;;foo( aVeryVeryLongArgument, anotherVeryLongArgument, callback);// badvar obj = &#123; a: 1 , b: 2 , c: 3&#125;;foo( aVeryVeryLongArgument , anotherVeryLongArgument , callback);[建议] 不同行为或逻辑的语句集，使用空行隔开，更易阅读。示例：12345678// 仅为按逻辑换行的示例，不代表setStyle的最优实现function setStyle(element, property, value) &#123; if (element == null) &#123; return; &#125; element.style[property] = value;&#125;[建议] 在语句的行长度超过 120 时，根据逻辑条件合理缩进。示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// 较复杂的逻辑条件组合，将每个条件独立一行，逻辑运算符放置在行首进行分隔，或将部分逻辑按逻辑组合进行分隔。// 建议最终将右括号 ) 与左大括号 &#123; 放在独立一行，保证与 if 内语句块能容易视觉辨识。if (user.isAuthenticated() &amp;&amp; user.isInRole('admin') &amp;&amp; user.hasAuthority('add-admin') || user.hasAuthority('delete-admin')) &#123; // Code&#125;// 按一定长度截断字符串，并使用 + 运算符进行连接。// 分隔字符串尽量按语义进行，如不要在一个完整的名词中间断开。// 特别的，对于HTML片段的拼接，通过缩进，保持和HTML相同的结构。var html = '' // 此处用一个空字符串，以便整个HTML片段都在新行严格对齐 + '&lt;article&gt;' + '&lt;h1&gt;Title here&lt;/h1&gt;' + '&lt;p&gt;This is a paragraph&lt;/p&gt;' + '&lt;footer&gt;Complete&lt;/footer&gt;' + '&lt;/article&gt;';// 也可使用数组来进行拼接，相对 + 更容易调整缩进。var html = [ '&lt;article&gt;', '&lt;h1&gt;Title here&lt;/h1&gt;', '&lt;p&gt;This is a paragraph&lt;/p&gt;', '&lt;footer&gt;Complete&lt;/footer&gt;', '&lt;/article&gt;'];html = html.join('');// 当参数过多时，将每个参数独立写在一行上，并将结束的右括号 ) 独立一行。// 所有参数必须增加一个缩进。foo( aVeryVeryLongArgument, anotherVeryLongArgument, callback);// 也可以按逻辑对参数进行组合。// 最经典的是baidu.format函数，调用时将参数分为“模板”和“数据”两块baidu.format( dateFormatTemplate, year, month, date, hour, minute, second);// 当函数调用时，如果有一个或以上参数跨越多行，应当每一个参数独立一行。// 这通常出现在匿名函数或者对象初始化等作为参数时，如setTimeout函数等。setTimeout( function () &#123; alert('hello'); &#125;, 200);order.data.read( 'id=' + me.model.id, function (data) &#123; me.attchToModel(data.result); callback(); &#125;, 300);// 链式调用较长时采用缩进进行调整。$('#items') .find('.selected') .highlight() .end();// 三元运算符由3部分组成，因此其换行应当根据每个部分的长度不同，形成不同的情况。var result = thisIsAVeryVeryLongCondition ? resultA : resultB;var result = condition ? thisIsAVeryVeryLongResult : resultB;// 数组和对象初始化的混用，严格按照每个对象的 &#123; 和结束 &#125; 在独立一行的风格书写。var array = [ &#123; // ... &#125;, &#123; // ... &#125;];[建议] 对于 if...else...、try...catch...finally 等语句，推荐使用在 } 号后添加一个换行 的风格，使代码层次结构更清晰，阅读性更好。示例：12345678910111213if (condition) &#123; // some statements;&#125;else &#123; // some statements;&#125;try &#123; // some statements;&#125;catch (ex) &#123; // some statements;&#125;2.2.4 语句[强制] 不得省略语句结束的分号。[强制] 在 if / else / for / do / while 语句中，即使只有一行，也不得省略块 {...}。示例：123456789// goodif (condition) &#123; callFunc();&#125;// badif (condition) callFunc();if (condition) callFunc();[强制] 函数定义结束不允许添加分号。示例：1234567891011// goodfunction funcName() &#123;&#125;// badfunction funcName() &#123;&#125;;// 如果是函数表达式，分号是不允许省略的。var funcName = function () &#123;&#125;;[强制] IIFE 必须在函数表达式外添加 (，非 IIFE 不得在函数表达式外添加 (。解释：IIFE = Immediately-Invoked Function Expression.额外的 ( 能够让代码在阅读的一开始就能判断函数是否立即被调用，进而明白接下来代码的用途。而不是一直拖到底部才恍然大悟。示例：123456789101112131415161718// goodvar task = (function () &#123; // Code return result;&#125;)();var func = function () &#123;&#125;;// badvar task = function () &#123; // Code return result;&#125;();var func = (function () &#123;&#125;);2.3 命名[强制] 变量 使用 Camel命名法。示例：1var loadingModules = &#123;&#125;;[强制] 常量 使用 全部字母大写，单词间下划线分隔 的命名方式。示例：1var HTML_ENTITY = &#123;&#125;;[强制] 函数 使用 Camel命名法。示例：12function stringFormat(source) &#123;&#125;[强制] 函数的 参数 使用 Camel命名法。示例：12function hear(theBells) &#123;&#125;[强制] 类 使用 Pascal命名法。示例：12function TextNode(options) &#123;&#125;[强制] 类的 方法 / 属性 使用 Camel命名法。示例：12345678function TextNode(value, engine) &#123; this.value = value; this.engine = engine;&#125;TextNode.prototype.clone = function () &#123; return this;&#125;;[强制] 枚举变量 使用 Pascal命名法，枚举的属性 使用 全部字母大写，单词间下划线分隔 的命名方式。示例：123456var TargetState = &#123; READING: 1, READED: 2, APPLIED: 3, READY: 4&#125;;[强制] 命名空间 使用 Camel命名法。示例：1equipments.heavyWeapons = &#123;&#125;;[强制] 由多个单词组成的缩写词，在命名中，根据当前命名法和出现的位置，所有字母的大小写与首字母的大小写保持一致。示例：1234567function XMLParser() &#123;&#125;function insertHTML(element, html) &#123;&#125;var httpRequest = new HTTPRequest();[强制] 类名 使用 名词。示例：12function Engine(options) &#123;&#125;[建议] 函数名 使用 动宾短语。示例：12function getStyle(element) &#123;&#125;[建议] boolean 类型的变量使用 is 或 has 开头。示例：12var isReady = false;var hasMoreCommands = false;[建议] Promise对象 用 动宾短语的进行时 表达。示例：12var loadingData = ajax.get('url');loadingData.then(callback);2.4 注释2.4.1 单行注释[强制] 必须独占一行。// 后跟一个空格，缩进与下一行被注释说明的代码一致。2.4.2 多行注释[建议] 避免使用 /*...*/ 这样的多行注释。有多行注释内容时，使用多个单行注释。2.4.3 文档化注释[强制] 为了便于代码阅读和自文档化，以下内容必须包含以 /**...*/ 形式的块注释中。解释：文件namespace类函数或方法类属性事件全局变量常量AMD 模块[强制] 文档注释前必须空一行。[建议] 自文档化的文档说明 what，而不是 how。2.4.4 类型定义[强制] 类型定义都是以{开始, 以}结束。解释：常用类型如：{string}, {number}, {boolean}, {Object}, {Function}, {RegExp}, {Array}, {Date}。类型不仅局限于内置的类型，也可以是自定义的类型。比如定义了一个类 Developer，就可以使用它来定义一个参数和返回值的类型。[强制] 对于基本类型 {string}, {number}, {boolean}，首字母必须小写。类型定义语法示例解释String{string}–Number{number}–Boolean{boolean}–Object{Object}–Function{Function}–RegExp{RegExp}–Array{Array}–Date{Date}–单一类型集合{Array.&lt;string&gt;}string 类型的数组多类型{(number｜boolean)}可能是 number 类型, 也可能是 boolean 类型允许为null{?number}可能是 number, 也可能是 null不允许为null{!Object}Object 类型, 但不是 nullFunction类型{function(number, boolean)}函数, 形参类型Function带返回值{function(number, boolean):string}函数, 形参, 返回值类型参数可选@param {string=} name可选参数, =为类型后缀可变参数@param {…number} args变长参数, …为类型前缀任意类型{*}任意类型可选任意类型@param {*=} name可选参数，类型不限可变任意类型@param {…*} args变长参数，类型不限2.4.5 文件注释[强制] 文件顶部必须包含文件注释，用 @file 标识文件说明。示例：123/** * @file Describe the file */[建议] 文件注释中可以用 @author 标识开发者信息。解释：开发者信息能够体现开发人员对文件的贡献，并且能够让遇到问题或希望了解相关信息的人找到维护人。通常情况文件在被创建时标识的是创建者。随着项目的进展，越来越多的人加入，参与这个文件的开发，新的作者应该被加入 @author 标识。@author 标识具有多人时，原则是按照 责任 进行排序。通常的说就是如果有问题，就是找第一个人应该比找第二个人有效。比如文件的创建者由于各种原因，模块移交给了其他人或其他团队，后来因为新增需求，其他人在新增代码时，添加 @author 标识应该把自己的名字添加在创建人的前面。@author 中的名字不允许被删除。任何劳动成果都应该被尊重。业务项目中，一个文件可能被多人频繁修改，并且每个人的维护时间都可能不会很长，不建议为文件增加 @author 标识。通过版本控制系统追踪变更，按业务逻辑单元确定模块的维护责任人，通过文档与wiki跟踪和查询，是更好的责任管理方式。对于业务逻辑无关的技术型基础项目，特别是开源的公共项目，应使用 @author 标识。示例：12345/** * @file Describe the file * @author author-name(mail-name@domain.com) * author-name2(mail-name2@domain.com) */2.4.6 命名空间注释[建议] 命名空间使用 @namespace 标识。示例：1234/** * @namespace */var util = &#123;&#125;;2.4.7 类注释[建议] 使用 @class 标记类或构造函数。解释：对于使用对象 constructor 属性来定义的构造函数，可以使用 @constructor 来标记。示例：12345678/** * 描述 * * @class */function Developer() &#123; // constructor body&#125;[建议] 使用 @extends 标记类的继承信息。示例：1234567891011/** * 描述 * * @class * @extends Developer */function Fronteer() &#123; Developer.call(this); // constructor body&#125;util.inherits(Fronteer, Developer);[强制] 使用包装方式扩展类成员时， 必须通过 @lends 进行重新指向。解释：没有 @lends 标记将无法为该类生成包含扩展类成员的文档。示例：12345678910111213141516171819/** * 类描述 * * @class * @extends Developer */function Fronteer() &#123; Developer.call(this); // constructor body&#125;util.extend( Fronteer.prototype, /** @lends Fronteer.prototype */&#123; _getLevel: function () &#123; // TODO &#125; &#125;);[强制] 类的属性或方法等成员信息使用 @public / @protected / @private 中的任意一个，指明可访问性。解释：生成的文档中将有可访问性的标记，避免用户直接使用非 public 的属性或方法。示例：1234567891011121314151617181920212223242526272829/** * 类描述 * * @class * @extends Developer */var Fronteer = function () &#123; Developer.call(this); /** * 属性描述 * * @type &#123;string&#125; * @private */ this._level = 'T12'; // constructor body&#125;;util.inherits(Fronteer, Developer);/** * 方法描述 * * @private * @return &#123;string&#125; 返回值描述 */Fronteer.prototype._getLevel = function () &#123;&#125;;2.4.8 函数/方法注释[强制] 函数/方法注释必须包含函数说明，有参数和返回值时必须使用注释标识。[强制] 参数和返回值注释必须包含类型信息和说明。[建议] 当函数是内部函数，外部不可访问时，可以使用 @inner 标识。示例：1234567891011121314151617/** * 函数描述 * * @param &#123;string&#125; p1 参数1的说明 * @param &#123;string&#125; p2 参数2的说明，比较长 * 那就换行了. * @param &#123;number=&#125; p3 参数3的说明（可选） * @return &#123;Object&#125; 返回值描述 */function foo(p1, p2, p3) &#123; var p3 = p3 || 10; return &#123; p1: p1, p2: p2, p3: p3 &#125;;&#125;[强制] 对 Object 中各项的描述， 必须使用 @param 标识。示例：12345678910/** * 函数描述 * * @param &#123;Object&#125; option 参数描述 * @param &#123;string&#125; option.url option项描述 * @param &#123;string=&#125; option.method option项描述，可选参数 */function foo(option) &#123; // TODO&#125;[建议] 重写父类方法时， 应当添加 @override 标识。如果重写的形参个数、类型、顺序和返回值类型均未发生变化，可省略 @param、@return，仅用 @override 标识，否则仍应作完整注释。解释：简而言之，当子类重写的方法能直接套用父类的方法注释时可省略对参数与返回值的注释。2.4.9 事件注释[强制] 必须使用 @event 标识事件，事件参数的标识与方法描述的参数标识相同。示例：12345678910/** * 值变更时触发 * * @event * @param &#123;Object&#125; e e描述 * @param &#123;string&#125; e.before before描述 * @param &#123;string&#125; e.after after描述 */onchange: function (e) &#123;&#125;[强制] 在会广播事件的函数前使用 @fires 标识广播的事件，在广播事件代码前使用 @event 标识事件。[建议] 对于事件对象的注释，使用 @param 标识，生成文档时可读性更好。示例：1234567891011121314151617181920212223/** * 点击处理 * * @fires Select#change * @private */Select.prototype.clickHandler = function () &#123; /** * 值变更时触发 * * @event Select#change * @param &#123;Object&#125; e e描述 * @param &#123;string&#125; e.before before描述 * @param &#123;string&#125; e.after after描述 */ this.fire( 'change', &#123; before: 'foo', after: 'bar' &#125; );&#125;;2.4.10 常量注释[强制] 常量必须使用 @const 标记，并包含说明和类型信息。示例：1234567/** * 常量说明 * * @const * @type &#123;string&#125; */var REQUEST_URL = 'myurl.do';2.4.11 复杂类型注释[建议] 对于类型未定义的复杂结构的注释，可以使用 @typedef 标识来定义。示例：123456789101112131415161718192021222324// `namespaceA~` 可以换成其它 namepaths 前缀，目的是为了生成文档中能显示 `@typedef` 定义的类型和链接。/** * 服务器 * * @typedef &#123;Object&#125; namespaceA~Server * @property &#123;string&#125; host 主机 * @property &#123;number&#125; port 端口 *//** * 服务器列表 * * @type &#123;Array.&lt;namespaceA~Server&gt;&#125; */var servers = [ &#123; host: '1.2.3.4', port: 8080 &#125;, &#123; host: '1.2.3.5', port: 8081 &#125;];2.4.12 AMD 模块注释[强制] AMD 模块使用 @module 或 @exports 标识。解释：@exports 与 @module 都可以用来标识模块，区别在于 @module 可以省略模块名称。而只使用 @exports 时在 namepaths 中可以省略 module: 前缀。示例：12345678910111213141516171819202122232425define( function (require) &#123; /** * foo description * * @exports Foo */ var foo = &#123; // TODO &#125;; /** * baz description * * @return &#123;boolean&#125; return description */ foo.baz = function () &#123; // TODO &#125;; return foo; &#125;);也可以在 exports 变量前使用 @module 标识：12345678910111213141516171819202122define( function (require) &#123; /** * module description. * * @module foo */ var exports = &#123;&#125;; /** * bar description * */ exports.bar = function () &#123; // TODO &#125;; return exports; &#125;);如果直接使用 factory 的 exports 参数，还可以：123456789101112131415161718/** * module description. * * @module */define( function (require, exports) &#123; /** * bar description * */ exports.bar = function () &#123; // TODO &#125;; return exports; &#125;);[强制] 对于已使用 @module 标识为 AMD模块 的引用，在 namepaths 中必须增加 module: 作前缀。解释：namepaths 没有 module: 前缀时，生成的文档中将无法正确生成链接。示例：1234567891011121314151617181920212223/** * 点击处理 * * @fires module:Select#change * @private */Select.prototype.clickHandler = function () &#123; /** * 值变更时触发 * * @event module:Select#change * @param &#123;Object&#125; e e描述 * @param &#123;string&#125; e.before before描述 * @param &#123;string&#125; e.after after描述 */ this.fire( 'change', &#123; before: 'foo', after: 'bar' &#125; );&#125;;[建议] 对于类定义的模块，可以使用 @alias 标识构建函数。示例：1234567891011121314151617/** * A module representing a jacket. * @module jacket */define( function () &#123; /** * @class * @alias module:jacket */ var Jacket = function () &#123; &#125;; return Jacket; &#125;);[建议] 多模块定义时，可以使用 @exports 标识各个模块。示例：123456789101112131415161718192021222324// one moduledefine('html/utils', /** * Utility functions to ease working with DOM elements. * @exports html/utils */ function () &#123; var exports = &#123; &#125;; return exports; &#125;);// another moduledefine('tag', /** @exports tag */ function () &#123; var exports = &#123; &#125;; return exports; &#125;);[建议] 对于 exports 为 Object 的模块，可以使用@namespace标识。解释：使用 @namespace 而不是 @module 或 @exports 时，对模块的引用可以省略 module: 前缀。[建议] 对于 exports 为类名的模块，使用 @class 和 @exports 标识。示例：1234567891011121314151617181920212223// 只使用 @class Bar 时，类方法和属性都必须增加 @name Bar#methodName 来标识，与 @exports 配合可以免除这一麻烦，并且在引用时可以省去 module: 前缀。// 另外需要注意类名需要使用 var 定义的方式。/** * Bar description * * @see foo * @exports Bar * @class */var Bar = function () &#123; // TODO&#125;;/** * baz description * * @return &#123;(string|Array)&#125; return description */Bar.prototype.baz = function () &#123; // TODO&#125;;2.4.13 细节注释对于内部实现、不容易理解的逻辑说明、摘要信息等，我们可能需要编写细节注释。[建议] 细节注释遵循单行注释的格式。说明必须换行时，每行是一个单行注释的起始。示例：1234567function foo(p1, p2, opt_p3) &#123; // 这里对具体内部逻辑进行说明 // 说明太长需要换行 for (...) &#123; .... &#125;&#125;[强制] 有时我们会使用一些特殊标记进行说明。特殊标记必须使用单行注释的形式。下面列举了一些常用标记：解释：TODO: 有功能待实现。此时需要对将要实现的功能进行简单说明。FIXME: 该处代码运行没问题，但可能由于时间赶或者其他原因，需要修正。此时需要对如何修正进行简单说明。HACK: 为修正某些问题而写的不太好或者使用了某些诡异手段的代码。此时需要对思路或诡异手段进行描述。XXX: 该处存在陷阱。此时需要对陷阱进行描述。3 语言特性3.1 变量[强制] 变量在使用前必须通过 var 定义。解释：不通过 var 定义变量将导致变量污染全局环境。示例：12345// goodvar name = 'MyName';// badname = 'MyName';[强制] 每个 var 只能声明一个变量。解释：一个 var 声明多个变量，容易导致较长的行长度，并且在修改时容易造成逗号和分号的混淆。示例：123456789// goodvar hangModules = [];var missModules = [];var visited = &#123;&#125;;// badvar hangModules = [], missModules = [], visited = &#123;&#125;;[强制] 变量必须 即用即声明，不得在函数或其它形式的代码块起始位置统一声明所有变量。解释：变量声明与使用的距离越远，出现的跨度越大，代码的阅读与维护成本越高。虽然JavaScript的变量是函数作用域，还是应该根据编程中的意图，缩小变量出现的距离空间。示例：1234567891011121314151617181920212223242526272829303132333435// goodfunction kv2List(source) &#123; var list = []; for (var key in source) &#123; if (source.hasOwnProperty(key)) &#123; var item = &#123; k: key, v: source[key] &#125;; list.push(item); &#125; &#125; return list;&#125;// badfunction kv2List(source) &#123; var list = []; var key; var item; for (key in source) &#123; if (source.hasOwnProperty(key)) &#123; item = &#123; k: key, v: source[key] &#125;; list.push(item); &#125; &#125; return list;&#125;3.2 条件[强制] 在 Equality Expression 中使用类型严格的 ===。仅当判断 null 或 undefined 时，允许使用 == null。解释：使用 === 可以避免等于判断中隐式的类型转换。示例：123456789// goodif (age === 30) &#123; // ......&#125;// badif (age == 30) &#123; // ......&#125;[建议] 尽可能使用简洁的表达式。示例：1234567891011// 字符串为空// goodif (!name) &#123; // ......&#125;// badif (name === '') &#123; // ......&#125;1234567891011// 字符串非空// goodif (name) &#123; // ......&#125;// badif (name !== '') &#123; // ......&#125;1234567891011// 数组非空// goodif (collection.length) &#123; // ......&#125;// badif (collection.length &gt; 0) &#123; // ......&#125;1234567891011// 布尔不成立// goodif (!notTrue) &#123; // ......&#125;// badif (notTrue === false) &#123; // ......&#125;1234567891011// null 或 undefined// goodif (noValue == null) &#123; // ......&#125;// badif (noValue === null || typeof noValue === 'undefined') &#123; // ......&#125;[建议] 按执行频率排列分支的顺序。解释：按执行频率排列分支的顺序好处是：阅读的人容易找到最常见的情况，增加可读性。提高执行效率。[建议] 对于相同变量或表达式的多值条件，用 switch 代替 if。示例：1234567891011121314151617181920// goodswitch (typeof variable) &#123; case 'object': // ...... break; case 'number': case 'boolean': case 'string': // ...... break;&#125;// badvar type = typeof variable;if (type === 'object') &#123; // ......&#125;else if (type === 'number' || type === 'boolean' || type === 'string') &#123; // ......&#125;[建议] 如果函数或全局中的 else 块后没有任何语句，可以删除 else。示例：123456789101112131415161718// goodfunction getName() &#123; if (name) &#123; return name; &#125; return 'unnamed';&#125;// badfunction getName() &#123; if (name) &#123; return name; &#125; else &#123; return 'unnamed'; &#125;&#125;3.3 循环[建议] 不要在循环体中包含函数表达式，事先将函数提取到循环体外。解释：循环体中的函数表达式，运行过程中会生成循环次数个函数对象。示例：12345678910111213141516// goodfunction clicker() &#123; // ......&#125;for (var i = 0, len = elements.length; i &lt; len; i++) &#123; var element = elements[i]; addListener(element, 'click', clicker);&#125;// badfor (var i = 0, len = elements.length; i &lt; len; i++) &#123; var element = elements[i]; addListener(element, 'click', function () &#123;&#125;);&#125;[建议] 对循环内多次使用的不变值，在循环外用变量缓存。示例：123456789101112131415// goodvar width = wrap.offsetWidth + 'px';for (var i = 0, len = elements.length; i &lt; len; i++) &#123; var element = elements[i]; element.style.width = width; // ......&#125;// badfor (var i = 0, len = elements.length; i &lt; len; i++) &#123; var element = elements[i]; element.style.width = wrap.offsetWidth + 'px'; // ......&#125;[建议] 对有序集合进行遍历时，缓存 length。解释：虽然现代浏览器都对数组长度进行了缓存，但对于一些宿主对象和老旧浏览器的数组对象，在每次 length 访问时会动态计算元素个数，此时缓存 length 能有效提高程序性能。示例：1234for (var i = 0, len = elements.length; i &lt; len; i++) &#123; var element = elements[i]; // ......&#125;[建议] 对有序集合进行顺序无关的遍历时，使用逆序遍历。解释：逆序遍历可以节省变量，代码比较优化。示例：12345var len = elements.length;while (len--) &#123; var element = elements[len]; // ......&#125;3.4 类型3.4.1 类型检测[建议] 类型检测优先使用 typeof。对象类型检测使用 instanceof。null 或 undefined 的检测使用 == null。示例：1234567891011121314151617181920212223242526272829// stringtypeof variable === 'string'// numbertypeof variable === 'number'// booleantypeof variable === 'boolean'// Functiontypeof variable === 'function'// Objecttypeof variable === 'object'// RegExpvariable instanceof RegExp// Arrayvariable instanceof Array// nullvariable === null// null or undefinedvariable == null// undefinedtypeof variable === 'undefined'3.4.2 类型转换[建议] 转换成 string 时，使用 + &#39;&#39;。示例：1234567// goodnum + '';// badnew String(num);num.toString();String(num);[建议] 转换成 number 时，通常使用 +。示例：12345// good+str;// badNumber(str);[建议] string 转换成 number，要转换的字符串结尾包含非数字并期望忽略时，使用 parseInt。示例：12var width = '200px';parseInt(width, 10);[强制] 使用 parseInt 时，必须指定进制。示例：12345// goodparseInt(str, 10);// badparseInt(str);[建议] 转换成 boolean 时，使用 !!。示例：12var num = 3.14;!!num;[建议] number 去除小数点，使用 Math.floor / Math.round / Math.ceil，不使用 parseInt。示例：1234567// goodvar num = 3.14;Math.ceil(num);// badvar num = 3.14;parseInt(num, 10);3.5 字符串[强制] 字符串开头和结束使用单引号 &#39;。解释：输入单引号不需要按住 shift，方便输入。实际使用中，字符串经常用来拼接 HTML。为方便 HTML 中包含双引号而不需要转义写法。示例：12var str = '我是一个字符串';var html = '&lt;div class=\"cls\"&gt;拼接HTML可以省去双引号转义&lt;/div&gt;';[建议] 使用 数组 或 + 拼接字符串。解释：使用 + 拼接字符串，如果拼接的全部是 StringLiteral，压缩工具可以对其进行自动合并的优化。所以，静态字符串建议使用 + 拼接。在现代浏览器下，使用 + 拼接字符串，性能较数组的方式要高。如需要兼顾老旧浏览器，应尽量使用数组拼接字符串。示例：123456789101112131415// 使用数组拼接字符串var str = [ // 推荐换行开始并缩进开始第一个字符串, 对齐代码, 方便阅读. '&lt;ul&gt;', '&lt;li&gt;第一项&lt;/li&gt;', '&lt;li&gt;第二项&lt;/li&gt;', '&lt;/ul&gt;'].join('');// 使用 + 拼接字符串var str2 = '' // 建议第一个为空字符串, 第二个换行开始并缩进开始, 对齐代码, 方便阅读 + '&lt;ul&gt;', + '&lt;li&gt;第一项&lt;/li&gt;', + '&lt;li&gt;第二项&lt;/li&gt;', + '&lt;/ul&gt;';[建议] 复杂的数据到视图字符串的转换过程，选用一种模板引擎。解释：使用模板引擎有如下好处：在开发过程中专注于数据，将视图生成的过程由另外一个层级维护，使程序逻辑结构更清晰。优秀的模板引擎，通过模板编译技术和高质量的编译产物，能获得比手工拼接字符串更高的性能。artTemplate: 体积较小，在所有环境下性能高，语法灵活。dot.js: 体积小，在现代浏览器下性能高，语法灵活。etpl: 体积较小，在所有环境下性能高，模板复用性高，语法灵活。handlebars: 体积大，在所有环境下性能高，扩展性高。hogon: 体积小，在现代浏览器下性能高。nunjucks: 体积较大，性能一般，模板复用性高。3.6 对象[强制] 使用对象字面量 {} 创建新 Object。示例：12345// goodvar obj = &#123;&#125;;// badvar obj = new Object();[强制] 对象创建时，如果一个对象的所有 属性 均可以不添加引号，则所有 属性 不得添加引号。示例：1234var info = &#123; name: 'someone', age: 28&#125;;[强制] 对象创建时，如果任何一个 属性 需要添加引号，则所有 属性 必须添加 &#39;。解释：如果属性不符合 Identifier 和 NumberLiteral 的形式，就需要以 StringLiteral 的形式提供。示例：12345678910111213// goodvar info = &#123; 'name': 'someone', 'age': 28, 'more-info': '...'&#125;;// badvar info = &#123; name: 'someone', age: 28, 'more-info': '...'&#125;;[强制] 不允许修改和扩展任何原生对象和宿主对象的原型。示例：123// 以下行为绝对禁止String.prototype.trim = function () &#123;&#125;;[建议] 属性访问时，尽量使用 .。解释：属性名符合 Identifier 的要求，就可以通过 . 来访问，否则就只能通过 [expr] 方式访问。通常在 JavaScript 中声明的对象，属性命名是使用 Camel 命名法，用 . 来访问更清晰简洁。部分特殊的属性(比如来自后端的JSON)，可能采用不寻常的命名方式，可以通过 [expr] 方式访问。示例：12info.age;info['more-info'];[建议] for in 遍历对象时, 使用 hasOwnProperty 过滤掉原型中的属性。示例：123456var newInfo = &#123;&#125;;for (var key in info) &#123; if (info.hasOwnProperty(key)) &#123; newInfo[key] = info[key]; &#125;&#125;3.7 数组[强制] 使用数组字面量 [] 创建新数组，除非想要创建的是指定长度的数组。示例：12345// goodvar arr = [];// badvar arr = new Array();[强制] 遍历数组不使用 for in。解释：数组对象可能存在数字以外的属性, 这种情况下 for in 不会得到正确结果.示例：123456789101112var arr = ['a', 'b', 'c'];arr.other = 'other things'; // 这里仅作演示, 实际中应使用Object类型// 正确的遍历方式for (var i = 0, len = arr.length; i &lt; len; i++) &#123; console.log(i);&#125;// 错误的遍历方式for (i in arr) &#123; console.log(i);&#125;[建议] 不因为性能的原因自己实现数组排序功能，尽量使用数组的 sort 方法。解释：自己实现的常规排序算法，在性能上并不优于数组默认的 sort 方法。以下两种场景可以自己实现排序：需要稳定的排序算法，达到严格一致的排序结果。数据特点鲜明，适合使用桶排。[建议] 清空数组使用 .length = 0。3.8 函数3.8.1 函数长度[建议] 一个函数的长度控制在 50 行以内。解释：将过多的逻辑单元混在一个大函数中，易导致难以维护。一个清晰易懂的函数应该完成单一的逻辑单元。复杂的操作应进一步抽取，通过函数的调用来体现流程。特定算法等不可分割的逻辑允许例外。示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344function syncViewStateOnUserAction() &#123; if (x.checked) &#123; y.checked = true; z.value = ''; &#125; else &#123; y.checked = false; &#125; if (!a.value) &#123; warning.innerText = 'Please enter it'; submitButton.disabled = true; &#125; else &#123; warning.innerText = ''; submitButton.disabled = false; &#125;&#125;// 直接阅读该函数会难以明确其主线逻辑，因此下方是一种更合理的表达方式：function syncViewStateOnUserAction() &#123; syncXStateToView(); checkAAvailability();&#125;function syncXStateToView() &#123; if (x.checked) &#123; y.checked = true; z.value = ''; &#125; else &#123; y.checked = false; &#125;&#125;function checkAAvailability() &#123; if (!a.value) &#123; displayWarningForAMissing(); &#125; else &#123; clearWarnignForA(); &#125;&#125;3.8.2 参数设计[建议] 一个函数的参数控制在 6 个以内。解释：除去不定长参数以外，函数具备不同逻辑意义的参数建议控制在 6 个以内，过多参数会导致维护难度增大。某些情况下，如使用 AMD Loader 的 require 加载多个模块时，其 callback 可能会存在较多参数，因此对函数参数的个数不做强制限制。[建议] 通过 options 参数传递非数据输入型参数。解释：有些函数的参数并不是作为算法的输入，而是对算法的某些分支条件判断之用，此类参数建议通过一个 options 参数传递。如下函数：123456789101112/** * 移除某个元素 * * @param &#123;Node&#125; element 需要移除的元素 * @param &#123;boolean&#125; removeEventListeners 是否同时将所有注册在元素上的事件移除 */function removeElement(element, removeEventListeners) &#123; element.parent.removeChild(element); if (removeEventListeners) &#123; element.clearEventListeners(); &#125;&#125;可以转换为下面的签名：12345678910111213/** * 移除某个元素 * * @param &#123;Node&#125; element 需要移除的元素 * @param &#123;Object&#125; options 相关的逻辑配置 * @param &#123;boolean&#125; options.removeEventListeners 是否同时将所有注册在元素上的事件移除 */function removeElement(element, options) &#123; element.parent.removeChild(element); if (options.removeEventListeners) &#123; element.clearEventListeners(); &#125;&#125;这种模式有几个显著的优势：boolean 型的配置项具备名称，从调用的代码上更易理解其表达的逻辑意义。当配置项有增长时，无需无休止地增加参数个数，不会出现 removeElement(element, true, false, false, 3) 这样难以理解的调用代码。当部分配置参数可选时，多个参数的形式非常难处理重载逻辑，而使用一个 options 对象只需判断属性是否存在，实现得以简化。3.8.3 闭包[建议] 在适当的时候将闭包内大对象置为 null。解释：在 JavaScript 中，无需特别的关键词就可以使用闭包，一个函数可以任意访问在其定义的作用域外的变量。需要注意的是，函数的作用域是静态的，即在定义时决定，与调用的时机和方式没有任何关系。闭包会阻止一些变量的垃圾回收，对于较老旧的JavaScript引擎，可能导致外部所有变量均无法回收。首先一个较为明确的结论是，以下内容会影响到闭包内变量的回收：嵌套的函数中是否有使用该变量。嵌套的函数中是否有 直接调用eval。是否使用了 with 表达式。Chakra、V8 和 SpiderMonkey 将受以上因素的影响，表现出不尽相同又较为相似的回收策略，而JScript.dll和Carakan则完全没有这方面的优化，会完整保留整个 LexicalEnvironment 中的所有变量绑定，造成一定的内存消耗。由于对闭包内变量有回收优化策略的 Chakra、V8 和 SpiderMonkey 引擎的行为较为相似，因此可以总结如下，当返回一个函数 fn 时：如果 fn 的 [[Scope]] 是ObjectEnvironment（with 表达式生成 ObjectEnvironment，函数和 catch 表达式生成 DeclarativeEnvironment），则：如果是 V8 引擎，则退出全过程。如果是 SpiderMonkey，则处理该 ObjectEnvironment 的外层 LexicalEnvironment。获取当前 LexicalEnvironment 下的所有类型为 Function 的对象，对于每一个 Function 对象，分析其 FunctionBody：如果 FunctionBody 中含有 直接调用eval，则退出全过程。否则得到所有的 Identifier。对于每一个 Identifier，设其为 name，根据查找变量引用的规则，从 LexicalEnvironment 中找出名称为 name 的绑定 binding。对 binding 添加 notSwap 属性，其值为 true。检查当前 LexicalEnvironment 中的每一个变量绑定，如果该绑定有 notSwap 属性且值为 true，则：如果是V8引擎，删除该绑定。如果是SpiderMonkey，将该绑定的值设为 undefined，将删除 notSwap 属性。对于Chakra引擎，暂无法得知是按 V8 的模式还是按 SpiderMonkey 的模式进行。如果有 非常庞大 的对象，且预计会在 老旧的引擎 中执行，则使用闭包时，注意将闭包不需要的对象置为空引用。[建议] 使用 IIFE 避免 Lift 效应。解释：在引用函数外部变量时，函数执行时外部变量的值由运行时决定而非定义时，最典型的场景如下：1234567891011var tasks = [];for (var i = 0; i &lt; 5; i++) &#123; tasks[tasks.length] = function () &#123; console.log('Current cursor is at ' + i); &#125;;&#125;var len = tasks.length;while (len--) &#123; tasks[len]();&#125;以上代码对 tasks 中的函数的执行均会输出 Current cursor is at 5，往往不符合预期。此现象称为 Lift 效应 。解决的方式是通过额外加上一层闭包函数，将需要的外部变量作为参数传递来解除变量的绑定关系：1234567891011121314var tasks = [];for (var i = 0; i &lt; 5; i++) &#123; // 注意有一层额外的闭包 tasks[tasks.length] = (function (i) &#123; return function () &#123; console.log('Current cursor is at ' + i); &#125;; &#125;)(i);&#125;var len = tasks.length;while (len--) &#123; tasks[len]();&#125;3.8.4 空函数[建议] 空函数不使用 new Function() 的形式。示例：1var emptyFunction = function () &#123;&#125;;[建议] 对于性能有高要求的场合，建议存在一个空函数的常量，供多处使用共享。示例：12345678var EMPTY_FUNCTION = function () &#123;&#125;;function MyClass() &#123;&#125;MyClass.prototype.abstractMethod = EMPTY_FUNCTION;MyClass.prototype.hooks.before = EMPTY_FUNCTION;MyClass.prototype.hooks.after = EMPTY_FUNCTION;3.9 面向对象[强制] 类的继承方案，实现时需要修正 constructor。解释：通常使用其他 library 的类继承方案都会进行 constructor 修正。如果是自己实现的类继承方案，需要进行 constructor 修正。示例：123456789101112/** * 构建类之间的继承关系 * * @param &#123;Function&#125; subClass 子类函数 * @param &#123;Function&#125; superClass 父类函数 */function inherits(subClass, superClass) &#123; var F = new Function(); F.prototype = superClass.prototype; subClass.prototype = new F(); subClass.prototype.constructor = subClass;&#125;[建议] 声明类时，保证 constructor 的正确性。示例：1234567891011121314151617function Animal(name) &#123; this.name = name;&#125;// 直接prototype等于对象时，需要修正constructorAnimal.prototype = &#123; constructor: Animal, jump: function () &#123; alert('animal ' + this.name + ' jump'); &#125;&#125;;// 这种方式扩展prototype则无需理会constructorAnimal.prototype.jump = function () &#123; alert('animal ' + this.name + ' jump');&#125;;[建议] 属性在构造函数中声明，方法在原型中声明。解释：原型对象的成员被所有实例共享，能节约内存占用。所以编码时我们应该遵守这样的原则：原型对象包含程序不会修改的成员，如方法函数或配置项。12345678function TextNode(value, engine) &#123; this.value = value; this.engine = engine;&#125;TextNode.prototype.clone = function () &#123; return this;&#125;;[强制] 自定义事件的 事件名 必须全小写。解释：在 JavaScript 广泛应用的浏览器环境，绝大多数 DOM 事件名称都是全小写的。为了遵循大多数 JavaScript 开发者的习惯，在设计自定义事件时，事件名也应该全小写。[强制] 自定义事件只能有一个 event 参数。如果事件需要传递较多信息，应仔细设计事件对象。解释：一个事件对象的好处有：顺序无关，避免事件监听者需要记忆参数顺序。每个事件信息都可以根据需要提供或者不提供，更自由。扩展方便，未来添加事件信息时，无需考虑会破坏监听器参数形式而无法向后兼容。[建议] 设计自定义事件时，应考虑禁止默认行为。解释：常见禁止默认行为的方式有两种：事件监听函数中 return false。事件对象中包含禁止默认行为的方法，如 preventDefault。3.10 动态特性3.10.1 eval[强制] 避免使用直接 eval 函数。解释：直接 eval，指的是以函数方式调用 eval 的调用方法。直接 eval 调用执行代码的作用域为本地作用域，应当避免。如果有特殊情况需要使用直接 eval，需在代码中用详细的注释说明为何必须使用直接 eval，不能使用其它动态执行代码的方式，同时需要其他资深工程师进行 Code Review。[建议] 尽量避免使用 eval 函数。3.10.2 动态执行代码[建议] 使用 new Function 执行动态代码。解释：通过 new Function 生成的函数作用域是全局使用域，不会影响当当前的本地作用域。如果有动态代码执行的需求，建议使用 new Function。示例：12var handler = new Function('x', 'y', 'return x + y;');var result = handler($('#x').val(), $('#y').val());3.10.3 with[建议] 尽量不要使用 with。解释：使用 with 可能会增加代码的复杂度，不利于阅读和管理；也会对性能有影响。大多数使用 with 的场景都能使用其他方式较好的替代。所以，尽量不要使用 with。3.10.4 delete[建议] 减少 delete 的使用。解释：如果没有特别的需求，减少或避免使用delete。delete的使用会破坏部分 JavaScript 引擎的性能优化。[建议] 处理 delete 可能产生的异常。解释：对于有被遍历需求，且值 null 被认为具有业务逻辑意义的值的对象，移除某个属性必须使用 delete 操作。在严格模式或IE下使用 delete 时，不能被删除的属性会抛出异常，因此在不确定属性是否可以删除的情况下，建议添加 try-catch 块。示例：123456try &#123; delete o.x;&#125;catch (deleteError) &#123; o.x = null;&#125;3.10.5 对象属性[建议] 避免修改外部传入的对象。解释：JavaScript 因其脚本语言的动态特性，当一个对象未被 seal 或 freeze 时，可以任意添加、删除、修改属性值。但是随意地对 非自身控制的对象 进行修改，很容易造成代码在不可预知的情况下出现问题。因此，设计良好的组件、函数应该避免对外部传入的对象的修改。下面代码的 selectNode 方法修改了由外部传入的 datasource 对象。如果 datasource 用在其它场合（如另一个 Tree 实例）下，会造成状态的混乱。123456789101112function Tree(datasource) &#123; this.datasource = datasource;&#125;Tree.prototype.selectNode = function (id) &#123; // 从datasource中找出节点对象 var node = this.findNode(id); if (node) &#123; node.selected = true; this.flushView(); &#125;&#125;;对于此类场景，需要使用额外的对象来维护，使用由自身控制，不与外部产生任何交互的 selectedNodeIndex 对象来维护节点的选中状态，不对 datasource 作任何修改。12345678910111213function Tree(datasource) &#123; this.datasource = datasource; this.selectedNodeIndex = &#123;&#125;;&#125;Tree.prototype.selectNode = function (id) &#123; // 从datasource中找出节点对象 var node = this.findNode(id); if (node) &#123; this.selectedNodeIndex[id] = true; this.flushView(); &#125;&#125;;除此之外，也可以通过 deepClone 等手段将自身维护的对象与外部传入的分离，保证不会相互影响。[建议] 具备强类型的设计。解释：如果一个属性被设计为 boolean 类型，则不要使用 1 / 0 作为其值。对于标识性的属性，如对代码体积有严格要求，可以从一开始就设计为 number 类型且将 0 作为否定值。从 DOM 中取出的值通常为 string 类型，如果有对象或函数的接收类型为 number 类型，提前作好转换，而不是期望对象、函数可以处理多类型的值。4 浏览器环境4.1 模块化4.1.1 AMD[强制] 使用 AMD 作为模块定义。解释：AMD 作为由社区认可的模块定义形式，提供多种重载提供灵活的使用方式，并且绝大多数优秀的 Library 都支持 AMD，适合作为规范。目前，比较成熟的 AMD Loader 有：官方实现的 requirejs百度自己实现的 esl[强制] 模块 id 必须符合标准。解释：模块 id 必须符合以下约束条件：类型为 string，并且是由 / 分割的一系列 terms 来组成。例如：this/is/a/module。term 应该符合 [a-zA-Z0-9_-]+ 规则。不应该有 .js 后缀。跟文件的路径保持一致。4.1.2 define[建议] 定义模块时不要指明 id 和 dependencies。解释：在 AMD 的设计思想里，模块名称是和所在路径相关的，匿名的模块更利于封包和迁移。模块依赖应在模块定义内部通过 local require 引用。所以，推荐使用 define(factory) 的形式进行模块定义。示例：1234define( function (require) &#123; &#125;);[建议] 使用 return 来返回模块定义。解释：使用 return 可以减少 factory 接收的参数（不需要接收 exports 和 module），在没有 AMD Loader 的场景下也更容易进行简单的处理来伪造一个 Loader。示例：123456789define( function (require) &#123; var exports = &#123;&#125;; // ... return exports; &#125;);4.1.3 require[强制] 全局运行环境中，require 必须以 async require 形式调用。解释：模块的加载过程是异步的，同步调用并无法保证得到正确的结果。示例：123456// goodrequire(['foo'], function (foo) &#123;&#125;);// badvar foo = require('foo');[强制] 模块定义中只允许使用 local require，不允许使用 global require。解释：在模块定义中使用 global require，对封装性是一种破坏。在 AMD 里，global require 是可以被重命名的。并且 Loader 甚至没有全局的 require 变量，而是用 Loader 名称做为 global require。模块定义不应该依赖使用的 Loader。[强制] Package在实现时，内部模块的 require 必须使用 relative id。解释：对于任何可能通过 发布-引入 的形式复用的第三方库、框架、包，开发者所定义的名称不代表使用者使用的名称。因此不要基于任何名称的假设。在实现源码中，require 自身的其它模块时使用 relative id。示例：12345define( function (require) &#123; var util = require('./util'); &#125;);[建议] 不会被调用的依赖模块，在 factory 开始处统一 require。解释：有些模块是依赖的模块，但不会在模块实现中被直接调用，最为典型的是 css / js / tpl 等 Plugin 所引入的外部内容。此类内容建议放在模块定义最开始处统一引用。示例：12345678define( function (require) &#123; require('css!foo.css'); require('tpl!bar.tpl.html'); // ... &#125;);4.2 DOM4.2.1 元素获取[建议] 对于单个元素，尽可能使用 document.getElementById 获取，避免使用document.all。[建议] 对于多个元素的集合，尽可能使用 context.getElementsByTagName 获取。其中 context 可以为 document 或其他元素。指定 tagName 参数为 * 可以获得所有子元素。[建议] 遍历元素集合时，尽量缓存集合长度。如需多次操作同一集合，则应将集合转为数组。解释：原生获取元素集合的结果并不直接引用 DOM 元素，而是对索引进行读取，所以 DOM 结构的改变会实时反映到结果中。示例：12345678910111213141516&lt;div&gt;&lt;/div&gt;&lt;span&gt;&lt;/span&gt;&lt;script&gt;var elements = document.getElementsByTagName('*');// 显示为 DIValert(elements[0].tagName);var div = elements[0];var p = document.createElement('p');document.body.insertBefore(p, div);// 显示为 Palert(elements[0].tagName);&lt;/script&gt;[建议] 获取元素的直接子元素时使用 children。避免使用childNodes，除非预期是需要包含文本、注释和属性类型的节点。4.2.2 样式获取[建议] 获取元素实际样式信息时，应使用 getComputedStyle 或 currentStyle。解释：通过 style 只能获得内联定义或通过 JavaScript 直接设置的样式。通过 CSS class 设置的元素样式无法直接通过 style 获取。4.2.3 样式设置[建议] 尽可能通过为元素添加预定义的 className 来改变元素样式，避免直接操作 style 设置。[强制] 通过 style 对象设置元素样式时，对于带单位非 0 值的属性，不允许省略单位。解释：除了 IE，标准浏览器会忽略不规范的属性值，导致兼容性问题。4.2.4 DOM 操作[建议] 操作 DOM 时，尽量减少页面 reflow。解释：页面 reflow 是非常耗时的行为，非常容易导致性能瓶颈。下面一些场景会触发浏览器的reflow：DOM元素的添加、修改（内容）、删除。应用新的样式或者修改任何影响元素布局的属性。Resize浏览器窗口、滚动页面。读取元素的某些属性（offsetLeft、offsetTop、offsetHeight、offsetWidth、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、getComputedStyle()、currentStyle(in IE)) 。[建议] 尽量减少 DOM 操作。解释：DOM 操作也是非常耗时的一种操作，减少 DOM 操作有助于提高性能。举一个简单的例子，构建一个列表。我们可以用两种方式：在循环体中 createElement 并 append 到父元素中。在循环体中拼接 HTML 字符串，循环结束后写父元素的 innerHTML。第一种方法看起来比较标准，但是每次循环都会对 DOM 进行操作，性能极低。在这里推荐使用第二种方法。4.2.5 DOM 事件[建议] 优先使用 addEventListener / attachEvent 绑定事件，避免直接在 HTML 属性中或 DOM 的 expando 属性绑定事件处理。解释：expando 属性绑定事件容易导致互相覆盖。[建议] 使用 addEventListener 时第三个参数使用 false。解释：标准浏览器中的 addEventListener 可以通过第三个参数指定两种时间触发模型：冒泡和捕获。而 IE 的 attachEvent 仅支持冒泡的事件触发。所以为了保持一致性，通常 addEventListener 的第三个参数都为 false。[建议] 在没有事件自动管理的框架支持下，应持有监听器函数的引用，在适当时候（元素释放、页面卸载等）移除添加的监听器。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://algate.coding.me/categories/Javascript/"}],"tags":[{"name":"代码规范","slug":"代码规范","permalink":"https://algate.coding.me/tags/代码规范/"}]},{"title":"HTML5 - postMessage","slug":"HTML5-postMessage","date":"2018-05-25T07:17:30.000Z","updated":"2019-02-27T03:27:59.551Z","comments":true,"path":"2018/05/25/HTML5-postMessage/","link":"","permalink":"https://algate.coding.me/2018/05/25/HTML5-postMessage/","excerpt":"","text":"","categories":[{"name":"HTML5","slug":"HTML5","permalink":"https://algate.coding.me/categories/HTML5/"}],"tags":[{"name":"postMessage","slug":"postMessage","permalink":"https://algate.coding.me/tags/postMessage/"}]},{"title":"HTML5 - 新增标签和删除的标签","slug":"HTML5-新增标签和删除的标签","date":"2018-05-25T07:17:30.000Z","updated":"2019-02-27T03:27:59.555Z","comments":true,"path":"2018/05/25/HTML5-新增标签和删除的标签/","link":"","permalink":"https://algate.coding.me/2018/05/25/HTML5-新增标签和删除的标签/","excerpt":"* 一、新增标签** 结构标签相当于有意义的div标签article：用于定义一篇文章header：定义页面的头部footer：nav：导航条链接section：定义一个区域aside：定义页面内容的侧边栏hgroup：定义文件中一个区块的相关信息figure：定义一组媒体内容以及它们的标题（可以用于包裹canvas，video等多媒体标签）figcaption：用于figure标签内定义媒体的标题footer：定义一个页面区域的底部dialog：定义一个对话框（例如微信的对话框）补充一：header/section/footer/aside/article/footer这几个标签最好不要嵌套在里面，放在最外边补充二：使用层级(header=section=footer：写在外层)&gt;(aside/article/figure/hgroup/nav：写在内层)","text":"* 一、新增标签** 结构标签相当于有意义的div标签article：用于定义一篇文章header：定义页面的头部footer：nav：导航条链接section：定义一个区域aside：定义页面内容的侧边栏hgroup：定义文件中一个区块的相关信息figure：定义一组媒体内容以及它们的标题（可以用于包裹canvas，video等多媒体标签）figcaption：用于figure标签内定义媒体的标题footer：定义一个页面区域的底部dialog：定义一个对话框（例如微信的对话框）补充一：header/section/footer/aside/article/footer这几个标签最好不要嵌套在里面，放在最外边补充二：使用层级(header=section=footer：写在外层)&gt;(aside/article/figure/hgroup/nav：写在内层)** 多媒体标签* 第一类video：定义一个视频video标签和audio标签使用差不多1.autoplay：是否自动播放2.controls：是否展示控制器4.可以用css控制视频框的宽度和高度3.可以包裹source标签audio：定义一个音频1.autoplay：是否自动播放（autoplay=”autoplay”：自动播放，不写则默认不自动播放）2.loop：是否重复以及重复几次（loop=’-1’时无限重复，=数字时重复数字次数）3.controls：是否显示控制器（controls=”controls”时显示，不写则默认不显示）4.可以包裹source标签source：定义媒体资源可以用于audio和video标签内部，并且可以添加不同格式的媒体文件，type属性用于填写转码格式，如下：* 第二类canvas（图片标签）：定义图片* 第三类embed：定义外部可交互内容和插件，例如flash使用方法和audio和video标签类似1.可以使用css控制资源显示的大小Web应用标签* 第一类：状态标签** meter：实时状态显示：气压、气温等（目前只支持谷歌和opera）属性：1.value：定义目前所处状态（数值）2.min：最低数值3.max：最高数值4.low：最低显示（低于该值为为黄色）5.high：最高显示（高于该值为黄色）6.optimum：最优值用法一&lt;meter value=&apos;220&apos; min=&apos;20&apos; max=&apos;380&apos; low=&apos;200&apos; high=&apos;240&apos; optimum=&apos;220&apos;&gt;&lt;/meter&gt; 75%&lt;meter value=&apos;0.75&apos;&gt;75%&lt;/meter&gt; ** progress：显示任务过程：安装、加载等（目前只支持谷歌，火狐和opera）属性1.value：当前的状态值2.max：最大状态值用法一：显示正在加载状态** 列表标签* datalist：为input标签定义一个下拉列表，配合option（兼容火狐和谷歌）用法：input标签中的list属性的值和datalist标签中的id必须相同，才能进行下拉拓展&lt;input type=&quot;text&quot; placeholder=&quot;111&quot; list=&apos;phonelist&apos;&gt; &lt;datalist id=&quot;phonelist&quot;&gt; &lt;option value=&quot;三星&quot;&gt;&lt;/option&gt; &lt;option value=&quot;华为&quot;&gt;&lt;/option&gt; &lt;option value=&quot;苹果&quot;&gt;&lt;/option&gt; &lt;option value=&quot;小米&quot;&gt;&lt;/option&gt; &lt;option value=&quot;大春&quot;&gt;&lt;/option&gt; &lt;/datalist&gt; * details：定义一个元素的详细内容，配合summary标签，用于展示省略的信息（兼容谷歌和其他一些高版本浏览器）用法：另外可以配合summary标签修改标题的显示很多的a* Menu标签（很多浏览器都不支持，建议少用或不用）menu：命令列表menuitem：menu命令列表标签（只有火狐8.0以上支持）command：menu标签定义的一个命令按钮（只有IE9支持，以上或以下都不支持）* 注释标签（不是平时的注释，这个标签主要用于类似注释拼音之类，会显示出来）ruby和rt标签用法：用ruby标签将字括起来，然后rt标签填写注释信息&lt;p&gt;注&lt;ruby&gt;释&lt;rt&gt;shi&lt;/rt&gt;&lt;/ruby&gt;标签&lt;/p&gt; mark：用于标黄（所有主流浏览器都支持，IE要9以上）&lt;p&gt;&lt;mark&gt;aaaaa&lt;/mark&gt;aaaaa&lt;/p&gt; *** 三、使用HTML5新标签进行布局的意义1.提升语义化特性和网页的质量2.减少了用于css调用的class和id属性3.对搜索引擎更友好","categories":[{"name":"HTML5","slug":"HTML5","permalink":"https://algate.coding.me/categories/HTML5/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://algate.coding.me/tags/HTML5/"}]},{"title":"2018最新学习 - 持续更新ing","slug":"2018最新研究内容","date":"2018-05-19T01:56:30.000Z","updated":"2019-02-27T03:27:59.517Z","comments":true,"path":"2018/05/19/2018最新研究内容/","link":"","permalink":"https://algate.coding.me/2018/05/19/2018最新研究内容/","excerpt":"持续更新… 未完待续…1.Fetch https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetchhttp://taobaofed.org/blog/2016/03/09/server-in-front-end/&lt;!-- fetchApi.js --&gt; eg：import { baseURL } from &apos;config/GlobalConfig&apos;; let fetchApi = (url, type, params) =&gt; { return fetch(`${baseURL + url}`, {method: type, body: JSON.stringify(params)}).then( response =&gt; response.json() ).catch(error =&gt; console.error(&apos;Error:&apos;, error)); }; export default fetchApi; &lt;!-- html --&gt; 引用: import fetchApi from &apos;fetchApi.js&apos;; fetchApi(&apos;url&apos;, &apos;get/post/put/delete…&apos;, params).then((r) =&gt; { console.log(r) })","text":"持续更新… 未完待续…1.Fetch https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetchhttp://taobaofed.org/blog/2016/03/09/server-in-front-end/&lt;!-- fetchApi.js --&gt; eg：import { baseURL } from &apos;config/GlobalConfig&apos;; let fetchApi = (url, type, params) =&gt; { return fetch(`${baseURL + url}`, {method: type, body: JSON.stringify(params)}).then( response =&gt; response.json() ).catch(error =&gt; console.error(&apos;Error:&apos;, error)); }; export default fetchApi; &lt;!-- html --&gt; 引用: import fetchApi from &apos;fetchApi.js&apos;; fetchApi(&apos;url&apos;, &apos;get/post/put/delete…&apos;, params).then((r) =&gt; { console.log(r) }) 2.ES6 http://es6.ruanyifeng.com/#docs/object—-ES6-进阶 http://taobaofed.org/blog/2016/11/03/es6-advanced/3.React - 组件间通信 http://taobaofed.org/blog/2016/11/17/react-components-communication/4.TypeScript https://www.tslang.cn/samples/index.html5.WebAssembly https://developer.mozilla.org/zh-CN/docs/WebAssembly6.&lt;&lt;数据结构与算法JavaScript描述&gt;&gt; – 吸毒并且敲一遍代码-反复理解和记忆。7.&lt;&lt;微信小程序实战入门&gt;&gt; – 写一个属于自己的小程序…8.wepy熟悉和使用9.webRTC 是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。WebRTC包含的这些标准使用户在无需安装任何插件或者第三方的软件的情况下，创建点对点（Peer-to-Peer）的数据分享和电话会议成为可能。10.mvvm框架实现-vue源码解读https://zhuanlan.zhihu.com/p/2702824211.es6全面分析和精通 http://es6.ruanyifeng.com12.","categories":[{"name":"其他","slug":"其他","permalink":"https://algate.coding.me/categories/其他/"}],"tags":[{"name":"前端最新知识","slug":"前端最新知识","permalink":"https://algate.coding.me/tags/前端最新知识/"}]},{"title":"React-单页面路由创建","slug":"React-单页面路由创建","date":"2018-05-17T12:30:30.000Z","updated":"2019-02-27T03:27:59.602Z","comments":true,"path":"2018/05/17/React-单页面路由创建/","link":"","permalink":"https://algate.coding.me/2018/05/17/React-单页面路由创建/","excerpt":"","text":"react 渲染路由的方法：HashRouter hash实现路由BrowserRouter H5 Api实现路由跳转addEventListener(‘hashchange’);histor.pushState({p:path})add(‘popstate’, e =&gt; {})context.jsHashRouter.js新增的方法：{Provider , Consumer} React.createContext();export {Provider, Consumer}export default class HashRouter extends Component{constructor(){super();}}Route.jsreturn{state=&gt;{}}","categories":[{"name":"React","slug":"React","permalink":"https://algate.coding.me/categories/React/"}],"tags":[{"name":"react路由","slug":"react路由","permalink":"https://algate.coding.me/tags/react路由/"}]},{"title":"把内容复制到粘贴板","slug":"JS进阶-复制到粘贴板","date":"2018-05-17T10:02:30.000Z","updated":"2019-03-14T06:12:41.379Z","comments":true,"path":"2018/05/17/JS进阶-复制到粘贴板/","link":"","permalink":"https://algate.coding.me/2018/05/17/JS进阶-复制到粘贴板/","excerpt":"需求: 点击按钮 复制 一部分不相关的文字内容 到粘贴板// 复制到粘贴板1234567891011121314151617181920212223copyTextToClipboard(text) &#123; var textArea = document.createElement('textarea'); textArea.style.position = 'fixed'; textArea.style.top = 0; textArea.style.left = 0; textArea.style.width = '2em'; textArea.style.height = '2em'; textArea.style.padding = 0; textArea.style.border = 'none'; textArea.style.outline = 'none'; textArea.style.boxShadow = 'none'; textArea.style.background = 'transparent'; textArea.value = text ? text : ''; document.body.appendChild(textArea); textArea.select(); try &#123; var msg = document.execCommand('copy') ? '成功' : '失败'; this.$message.success('复制' + msg); &#125; catch (err) &#123; console.log('浏览器不支持该功能，sorry！'); &#125; document.body.removeChild(textArea);&#125;","text":"需求: 点击按钮 复制 一部分不相关的文字内容 到粘贴板// 复制到粘贴板1234567891011121314151617181920212223copyTextToClipboard(text) &#123; var textArea = document.createElement('textarea'); textArea.style.position = 'fixed'; textArea.style.top = 0; textArea.style.left = 0; textArea.style.width = '2em'; textArea.style.height = '2em'; textArea.style.padding = 0; textArea.style.border = 'none'; textArea.style.outline = 'none'; textArea.style.boxShadow = 'none'; textArea.style.background = 'transparent'; textArea.value = text ? text : ''; document.body.appendChild(textArea); textArea.select(); try &#123; var msg = document.execCommand('copy') ? '成功' : '失败'; this.$message.success('复制' + msg); &#125; catch (err) &#123; console.log('浏览器不支持该功能，sorry！'); &#125; document.body.removeChild(textArea);&#125;这是之前写页面复制到剪贴板，没有问题可以使用！直到我写移动端，我的Android手机怎么测试都ok，而玩测试的同学一本正经的跟我说不行。bug打开关闭打开，我就纳闷了。我找到测试的同学，想让复现一下。当同学拿出她硕大的iPhone 6/7/8/x*(不知道是什么型号)，我说不用复现了，我先回去看看。fu*k，ie的bug时代结束了，迎来的是ios的bug！直接上代码：123456789101112131415161718192021222324252627282930313233343536373839&lt;button id=\"copy\" style=\"margin:20px;padding:8px;font-size:16px;\"&gt;敢玩我&lt;/button&gt;&lt;script type=\"text/javascript\"&gt;function copyTextToClipboard(text) &#123; var textArea = document.createElement('textarea'); textArea.style.position = 'fixed'; textArea.style.top = 0; textArea.style.left = 0; textArea.style.width = '2em'; textArea.style.height = '2em'; textArea.style.padding = 0; textArea.style.border = 'none'; textArea.style.outline = 'none'; textArea.style.boxShadow = 'none'; textArea.style.background = 'transparent'; textArea.value = text ? text : \"what's copyed?\"; document.body.appendChild(textArea); if (navigator.userAgent.match(/(iPhone|iPod|iPad);?/i)) &#123;//区分iPhone设备 window.getSelection().removeAllRanges();//这段代码必须放在前面否则无效 // var Url2=document.getElementById(\"biaoios\");//要复制文字的节点 var range = document.createRange(); // 选中需要复制的节点 range.selectNode(textArea); // 执行选中元素 window.getSelection().addRange(range); // 执行 copy 操作 var successful = document.execCommand('copy'); // 移除选中的元素 window.getSelection().removeAllRanges(); &#125; else &#123; textArea.select(); var msg = document.execCommand(\"Copy\"); &#125; document.body.removeChild(textArea);&#125;document.querySelector('#copy').onclick = function()&#123; var str = '敢玩我？'; copyTextToClipboard(str);&#125;&lt;/script&gt;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://algate.coding.me/categories/Javascript/"}],"tags":[{"name":"复制内容","slug":"复制内容","permalink":"https://algate.coding.me/tags/复制内容/"},{"name":"粘贴板","slug":"粘贴板","permalink":"https://algate.coding.me/tags/粘贴板/"}]},{"title":"Vue中CropperJs图片裁切功能实现","slug":"Vue-CropperJs图片裁切功能实现","date":"2018-05-16T06:01:30.000Z","updated":"2019-02-27T03:27:59.620Z","comments":true,"path":"2018/05/16/Vue-CropperJs图片裁切功能实现/","link":"","permalink":"https://algate.coding.me/2018/05/16/Vue-CropperJs图片裁切功能实现/","excerpt":"页面html代码：&lt;div&gt; &lt;el-button class=&quot;mt_10&quot; type=&quot;primary&quot; size=&quot;small&quot; onclick=&quot;chooseSeat.click()&quot;&gt;选择文件&lt;/el-button&gt; &lt;input id=&quot;chooseSeat&quot; name=&quot;files&quot; style=&quot;display:none;&quot; type=&quot;file&quot; @change=&quot;onFileSelect()&quot; accept=&quot;image/png,image/jpeg,image/jpg&quot;/&gt; &lt;div style=&quot;width: 480px;min-height:280px;background: #ccc;margin-top:10px;margin-bottom: 10px;&quot;&gt; &lt;div style=&quot;width: 100%;min-height:100%;background: #ccc;&quot;&gt; &lt;img id=&quot;Img_uploadImg&quot; style=&quot;max-width: 100%;&quot; alt=&quot;原始图&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;margin-bottom: 10px;&quot;&gt; &lt;img :src=&quot;Img_cropperImg&quot; style=&quot;width:120px;height:120px;background: #ccc;&quot; alt=&quot;裁切图&quot;&gt; &lt;/div&gt; &lt;el-button type=&quot;primary&quot; size=&quot;small&quot; @click=&quot;J_savePortrait&quot;&gt;保存&lt;/el-button&gt; &lt;a :href=&quot;Img_download&quot; download=&quot;头像&quot;&gt;&lt;/a&gt; &lt;/div&gt;","text":"页面html代码：&lt;div&gt; &lt;el-button class=&quot;mt_10&quot; type=&quot;primary&quot; size=&quot;small&quot; onclick=&quot;chooseSeat.click()&quot;&gt;选择文件&lt;/el-button&gt; &lt;input id=&quot;chooseSeat&quot; name=&quot;files&quot; style=&quot;display:none;&quot; type=&quot;file&quot; @change=&quot;onFileSelect()&quot; accept=&quot;image/png,image/jpeg,image/jpg&quot;/&gt; &lt;div style=&quot;width: 480px;min-height:280px;background: #ccc;margin-top:10px;margin-bottom: 10px;&quot;&gt; &lt;div style=&quot;width: 100%;min-height:100%;background: #ccc;&quot;&gt; &lt;img id=&quot;Img_uploadImg&quot; style=&quot;max-width: 100%;&quot; alt=&quot;原始图&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;margin-bottom: 10px;&quot;&gt; &lt;img :src=&quot;Img_cropperImg&quot; style=&quot;width:120px;height:120px;background: #ccc;&quot; alt=&quot;裁切图&quot;&gt; &lt;/div&gt; &lt;el-button type=&quot;primary&quot; size=&quot;small&quot; @click=&quot;J_savePortrait&quot;&gt;保存&lt;/el-button&gt; &lt;a :href=&quot;Img_download&quot; download=&quot;头像&quot;&gt;&lt;/a&gt; &lt;/div&gt; 首先需要引入cropperjs;import Cropper from &apos;cropperjs&apos;; script:data () { return { files: {}, Img_cropperImg: &apos;&apos;, cropper: null, Img_download: &apos;&apos; }; }, 选择文件方法：onFileSelect() { let v = this; let oFiles = document.querySelector(&apos;#chooseSeat&apos;).files; this.files = oFiles[0]; let reader = new FileReader(); reader.onload = function (e) { console.log(e); document.querySelector(&apos;#Img_uploadImg&apos;).src = e.target.result; let src = e.target.result; if (this.cropper) { v.cropper.destroy(); } v.startCropper(src); }; reader.readAsDataURL(this.files); // this.ImguploadImg = URL.createObjectURL(this.files); // 可以转化为blob文件 } startCropper(src) { let v = this; var image = document.getElementById(&apos;Img_uploadImg&apos;); this.cropper = new Cropper(image, { aspectRatio: 1 / 1, ready: function (e) { console.log(e.type); }, cropstart: function (e) { console.log(e.type, e.detail.action); }, cropmove: function (e) { console.log(e.type, e.detail.action); }, cropend: function (e) { console.log(e.type, e.detail.action); }, crop: function (e) { let src = this.cropper.getCroppedCanvas({width: 120, height: 120}).toDataURL(&apos;image/png&apos;); v.Img_cropperImg = src; this.cropper.getCroppedCanvas({width: 120, height: 120}).toBlob((blob) =&gt; { v.Img_download = blob; }); }, zoom: function (e) { console.log(e.type, e.detail.ratio); } }); },","categories":[{"name":"Vue","slug":"Vue","permalink":"https://algate.coding.me/categories/Vue/"}],"tags":[{"name":"cropperJs","slug":"cropperJs","permalink":"https://algate.coding.me/tags/cropperJs/"},{"name":"图片裁切","slug":"图片裁切","permalink":"https://algate.coding.me/tags/图片裁切/"}]},{"title":"Js - url参数拼接","slug":"Js-URL参数拼接","date":"2018-05-14T06:36:30.000Z","updated":"2019-02-27T03:27:59.579Z","comments":true,"path":"2018/05/14/Js-URL参数拼接/","link":"","permalink":"https://algate.coding.me/2018/05/14/Js-URL参数拼接/","excerpt":"url已经带参数还没有带都可以使用url传参以及get请求参数paramsJoin(url, params) { let paramsArray = []; Object.keys(params).forEach(key =&gt; paramsArray.push(key + &apos;=&apos; + params[key])); if (url.search(/\\?/) === -1) { url += &apos;?&apos; + paramsArray.join(&apos;&amp;&apos;); } else { url += &apos;&amp;&apos; + paramsArray.join(&apos;&amp;&apos;); } return url; }","text":"url已经带参数还没有带都可以使用url传参以及get请求参数paramsJoin(url, params) { let paramsArray = []; Object.keys(params).forEach(key =&gt; paramsArray.push(key + &apos;=&apos; + params[key])); if (url.search(/\\?/) === -1) { url += &apos;?&apos; + paramsArray.join(&apos;&amp;&apos;); } else { url += &apos;&amp;&apos; + paramsArray.join(&apos;&amp;&apos;); } return url; }","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://algate.coding.me/categories/Javascript/"}],"tags":[{"name":"params","slug":"params","permalink":"https://algate.coding.me/tags/params/"}]},{"title":"Diary - 前端星计划三周年庆一天行","slug":"Diary-360前端星计划三周年庆","date":"2018-05-11T23:31:30.000Z","updated":"2019-02-27T03:27:59.530Z","comments":true,"path":"2018/05/12/Diary-360前端星计划三周年庆/","link":"","permalink":"https://algate.coding.me/2018/05/12/Diary-360前端星计划三周年庆/","excerpt":"《北京编程梦》 —- Algate内容不多，但是收获或多或少还是有的。阿里的前端大牛，360事业部的星计划创始人月影…… 请原谅我的记性不是很好。名字可记不住从WEB发展历史到WEB发展的现状以及WEB未来的发展方向都有深刻理解；微信小程序的火热，以及快应用的诞生，app应用等向跨平台、快启动，免安装等方向发展；wepy框架的应用，前端组件化框架，组件等让开发变得越来越方便；es6等新规范的诞生，flash即将全面禁用。加入webassembly、媒体资源扩展、webRTC等最新规范。让WEB发展如火如荼，正经历着每天都有新内容的变革。市面上出现的许多组件，框架，针对某个应用开发的各种版本应用等等的内容；现阶段，web发展给社会进步，市场繁荣也尽了自己的一份力量，web能如此热情高涨的发展下去。………大家合影留念我没有吃蛋糕，360纸水杯作为纪念；","text":"《北京编程梦》 —- Algate内容不多，但是收获或多或少还是有的。阿里的前端大牛，360事业部的星计划创始人月影…… 请原谅我的记性不是很好。名字可记不住从WEB发展历史到WEB发展的现状以及WEB未来的发展方向都有深刻理解；微信小程序的火热，以及快应用的诞生，app应用等向跨平台、快启动，免安装等方向发展；wepy框架的应用，前端组件化框架，组件等让开发变得越来越方便；es6等新规范的诞生，flash即将全面禁用。加入webassembly、媒体资源扩展、webRTC等最新规范。让WEB发展如火如荼，正经历着每天都有新内容的变革。市面上出现的许多组件，框架，针对某个应用开发的各种版本应用等等的内容；现阶段，web发展给社会进步，市场繁荣也尽了自己的一份力量，web能如此热情高涨的发展下去。………大家合影留念我没有吃蛋糕，360纸水杯作为纪念；","categories":[{"name":"日记","slug":"日记","permalink":"https://algate.coding.me/categories/日记/"}],"tags":[{"name":"前端星计划","slug":"前端星计划","permalink":"https://algate.coding.me/tags/前端星计划/"}]},{"title":"css - 元素选择器","slug":"CSS-你不知道的元素选择器","date":"2018-05-11T06:07:30.000Z","updated":"2019-02-27T03:27:59.526Z","comments":true,"path":"2018/05/11/CSS-你不知道的元素选择器/","link":"","permalink":"https://algate.coding.me/2018/05/11/CSS-你不知道的元素选择器/","excerpt":"1.属性选择器：如果您希望把包含标题（title）的所有元素变为红色，可以写作：*[title] {color:red;} 与上面类似，可以只对有 href 属性的锚（a 元素）应用样式：a[href] {color:red;} 还可以根据多个属性进行选择，只需将属性选择器链接在一起即可。例如，为了将同时有 href 和 title 属性的 HTML 超链接的文本设置为红色，可以这样写：a[href][title] {color:red;}","text":"1.属性选择器：如果您希望把包含标题（title）的所有元素变为红色，可以写作：*[title] {color:red;} 与上面类似，可以只对有 href 属性的锚（a 元素）应用样式：a[href] {color:red;} 还可以根据多个属性进行选择，只需将属性选择器链接在一起即可。例如，为了将同时有 href 和 title 属性的 HTML 超链接的文本设置为红色，可以这样写：a[href][title] {color:red;} 可以对所有带有 alt 属性的图像应用样式，从而突出显示这些有效的图像：img[alt] {border: 5px solid red;} 提示：上面这个特例更适合用来诊断而不是设计，即用来确定图像是否确实有效。例如，假设希望将指向 Web 服务器上某个指定文档的超链接变成红色，可以这样写：a[href=&quot;http://www.w3school.com.cn/about_us.asp&quot;] {color: red;} 与简单属性选择器类似，可以把多个属性-值选择器链接在一起来选择一个文档。a[href=&quot;http://www.w3school.com.cn/&quot;][title=&quot;W3School&quot;] {color: red;} |||| - 属性与属性值必须完全匹配:如果属性值包含用空格分隔的值列表，匹配就可能出问题。请考虑一下的标记片段：&lt;p class=&quot;important warning&quot;&gt;This paragraph is a very important warning.&lt;/p&gt; 如果写成 p[class=&quot;important&quot;]，那么这个规则不能匹配示例标记。要根据具体属性值来选择该元素，必须这样写：p[class=&quot;important warning&quot;] {color: red;} |||| - 根据部分属性值选择如果需要根据属性值中的词列表的某个词进行选择，则需要使用波浪号（~）。假设您想选择 class 属性中包含 important 的元素，可以用下面这个选择器做到这一点：p[class~=&quot;important&quot;] {color: red;} 如果忽略了波浪号，则说明需要完成完全值匹配。|||| - 子串匹配属性选择器下面为您介绍一个更高级的选择器模块。下表是对这些选择器的简单总结：[attribute] 用于选取带有指定属性的元素。[attribute=value] 用于选取带有指定属性和值的元素。[attribute~=value] 用于选取属性值中包含指定词汇的元素。[attribute|=value] 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。(value和value-)[attribute^=value] 匹配属性值以指定值开头的每个元素。[attribute$=value] 匹配属性值以指定值结尾的每个元素。[attribute*=value] 匹配属性值中包含指定值的每个元素。|||| - 特定属性选择类型*[lang|=&quot;en&quot;] {color: red;} 上面这个规则会选择 lang 属性等于 en 或以 en- 开头的所有元素。因此，以下示例标记中的前三个元素将被选中，而不会选择后两个元素：Hello!Greetings!G’day!Bonjour!Jrooana!|||| - 一般来说，[att|=”val”] 可以用于任何属性及其值。假设一个 HTML 文档中有一系列图片，其中每个图片的文件名都形如 figure-1.jpg 和 figure-2.jpg。就可以使用以下选择器匹配所有这些图像：img[src|=&quot;figure&quot;] {border: 1px solid gray;} 2.子元素选择器：您希望选择只作为 h1 元素子元素的 strong 元素，可以这样写：h1 &gt; strong {color:red;} 这个规则会把第一个 h1 下面的两个 strong 元素变为红色，但是第二个 h1 中的 strong 不受影响：&lt;h1&gt;This is &lt;strong&gt;very&lt;/strong&gt; &lt;strong&gt;very&lt;/strong&gt; important.&lt;/h1&gt; &lt;h1&gt;This is &lt;em&gt;really &lt;strong&gt;very&lt;/strong&gt;&lt;/em&gt; important.&lt;/h1&gt; 3.相邻兄弟选择器如果需要选择紧接在另一个元素后的元素，而且二者有相同的父元素，可以使用相邻兄弟选择器（Adjacent sibling selector）li + li {font-weight:bold;} 上面这个选择器只会把列表中的第二个和第三个列表项变为粗体。第一个列表项不受影响。4.伪类（ :focus :checked :not() a:link:visited:hover:active :first-child :lang() ）这里只介绍一种不常用的:lang&lt;html&gt; &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; q:lang(no) { quotes: &quot;~&quot; &quot;~&quot; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;文字&lt;q lang=&quot;no&quot;&gt;段落中的引用的文字&lt;/q&gt;文字&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 我自己试了，不起作用。5.伪元素 ( :before :after)伪元素的语法：selector:pseudo-element {property:value;} |||| - :first-line 伪元素“first-line” 伪元素用于向文本的首行设置特殊样式。在下面的例子中，浏览器会根据 “first-line” 伪元素中的样式对 p 元素的第一行文本进行格式化：实例p:first-line { color:#ff0000; font-variant:small-caps; } 注释：”first-line” 伪元素只能用于块级元素。注释：下面的属性可应用于 “first-line” 伪元素：fontcolorbackgroundword-spacingletter-spacingtext-decorationvertical-aligntext-transformline-heightclear|||| - :first-letter 伪元素“first-letter” 伪元素用于向文本的首字母设置特殊样式：p:first-letter { color:#ff0000; font-size:xx-large; } 注释：”first-letter” 伪元素只能用于块级元素。注释：下面的属性可应用于 “first-letter” 伪元素：fontcolorbackgroundmarginpaddingbordertext-decorationvertical-align (仅当 float 为 none 时)text-transformline-heightfloatclear","categories":[{"name":"Css","slug":"Css","permalink":"https://algate.coding.me/categories/Css/"}],"tags":[{"name":"选择器","slug":"选择器","permalink":"https://algate.coding.me/tags/选择器/"}]},{"title":"we-微信小程序","slug":"we-微信小程序入门","date":"2018-05-05T07:53:30.000Z","updated":"2019-02-27T03:27:59.653Z","comments":true,"path":"2018/05/05/we-微信小程序入门/","link":"","permalink":"https://algate.coding.me/2018/05/05/we-微信小程序入门/","excerpt":"官方给了一个非常简洁的描述：小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。最大的优势就是：很多App在微信打开后需要跳转，而小程序依靠月活10亿的微信用户，可以直接在微信中打开运行。购物类小程序打开后界面类似其他商城App，让用户购物体验更好。也可以直接在微信群分享，熟人分享转化率更高。微信群里的小游戏像病毒一样刷屏，虽然腾讯表示会阻止这样的病毒式分享，但是依然无法阻挡小游戏的火爆。这是一条很好的变现方式。碎片化时间的利用充分展示了小程序的优越性，用完就走，无需安装和留存，腾讯给小程序开放了很多入口，首页下拉可以看到小程序的使用记录。好处多多。对于这么火爆的新生派实力小程序，虽然工作中我不需要开发，但是也阻挡不了我对他的热情。so—开发一个属于自己的小程序就很有必要。既可以提升自己的逼格，又可以成为众多开发者的一员……。我忍不住就像开发。","text":"官方给了一个非常简洁的描述：小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。最大的优势就是：很多App在微信打开后需要跳转，而小程序依靠月活10亿的微信用户，可以直接在微信中打开运行。购物类小程序打开后界面类似其他商城App，让用户购物体验更好。也可以直接在微信群分享，熟人分享转化率更高。微信群里的小游戏像病毒一样刷屏，虽然腾讯表示会阻止这样的病毒式分享，但是依然无法阻挡小游戏的火爆。这是一条很好的变现方式。碎片化时间的利用充分展示了小程序的优越性，用完就走，无需安装和留存，腾讯给小程序开放了很多入口，首页下拉可以看到小程序的使用记录。好处多多。对于这么火爆的新生派实力小程序，虽然工作中我不需要开发，但是也阻挡不了我对他的热情。so—开发一个属于自己的小程序就很有必要。既可以提升自己的逼格，又可以成为众多开发者的一员……。我忍不住就像开发。首先我用微信小程序的官方看了流程，注册，完善信息，下载开发软件，绑定appID就可以实时获取用户信息，简直是不能再方便。最后手机微信端直接就可以预览，调试，实时查看开始效果。完美了。小程序有集成的相关组件可以直接使用，非常之方便。开发文档–非常之详细和明白* 1.注册 （要想在手机微信预览这个必须要有，之后还得绑定开发的小程序项目）在微信小程序官方网站，注册成为小程序开发者。有开发文档，也有完善的社区平台；* 2.安装开发环境官方给出了一个比较完美的小程序开发工具现在有个第三方的开发框架-wepy。让我们不需要官方微信小程序工具。直接像vue、react、angular等直接在本地构建代码不过我们还需要编译为微信小程序开发需要的文件。项目里边生成了不同类型的文件:.json 后缀的 JSON 配置文件 .wxml 后缀的 WXML 模板文件 .wxss 后缀的 WXSS 样式文件 .js 后缀的 JS 脚本逻辑文件 …… 直接看官方文档会很明白。纵然是个小白，你也可以看着官方文档创建一个属于自己的微信小程序，只要你认识字。* 3.后续工作程序和页面代码开发上传小程序代码微信预览开发版和体验版* 4.上线提交审核发布运营数据* 5.体验小程序具体的操作流程请看小程序官方文档","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://algate.coding.me/categories/微信小程序/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://algate.coding.me/tags/微信小程序/"}]},{"title":"vue-elementUI使用相关问题","slug":"Vue-elementUI使用相关问题","date":"2018-04-25T10:52:30.000Z","updated":"2019-02-27T05:17:16.596Z","comments":true,"path":"2018/04/25/Vue-elementUI使用相关问题/","link":"","permalink":"https://algate.coding.me/2018/04/25/Vue-elementUI使用相关问题/","excerpt":"1.form表格排序在el-table需要排序的那一列加入 sortbale&lt;el-table-column prop=&quot;createDate&quot; label=&quot;申请日期&quot; width=&quot;200&quot; sortable :sort-method=&quot;auditSortby&quot;&gt; sort-by sort-method都是自定义排序规则 sort-method跟[]的sort类似。so数字相关的可以这样写 &lt;!-- js --&gt; auditSortby(a, b) { return new Date(a.createDate).getTime() - new Date(b.createDate).getTime(); },","text":"1.form表格排序在el-table需要排序的那一列加入 sortbale&lt;el-table-column prop=&quot;createDate&quot; label=&quot;申请日期&quot; width=&quot;200&quot; sortable :sort-method=&quot;auditSortby&quot;&gt; sort-by sort-method都是自定义排序规则 sort-method跟[]的sort类似。so数字相关的可以这样写 &lt;!-- js --&gt; auditSortby(a, b) { return new Date(a.createDate).getTime() - new Date(b.createDate).getTime(); }, 2.格式化数据下边介绍两种方法：Number - 1: &lt;el-table-column prop=&quot;status&quot; label=&quot;状态&quot; width=&quot;140&quot; sortable sort-by&gt; &lt;template slot-scope=&quot;scope&quot;&gt;{{ scope.row.status==='0'?'启用':'禁用' }}&lt;/template&gt; &lt;/el-table-column&gt; Number - 2: &lt;el-table-column prop=&quot;sex&quot; label=&quot;性别&quot; width=&quot;100&quot; :formatter=&quot;data_set_sex&quot;&gt; &lt;/el-table-column&gt; &lt;!-- js --&gt; data_set_sex (row) { return row.sex === &apos;0&apos; ? &apos;男&apos; : &apos;女&apos;; }, 3.form - 更多按钮显示多项操作通过绑定command来实现&lt;el-table-column fixed=&quot;right&quot; label=&quot;操作&quot; align=&quot;center&quot; min-width=&quot;120&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button type=&quot;text&quot; size=&quot;small&quot; @click=&quot;J_addOrEdit(scope.row,&apos;edit&apos;)&quot;&gt;编辑&lt;/el-button&gt; &lt;el-dropdown trigger=&quot;click&quot; @command=&quot;J_handle&quot;&gt; &lt;span class=&quot;el-dropdown-link&quot;&gt;更多&lt;/span&gt; &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt; &lt;el-dropdown-item :command=&apos;{&quot;handle&quot;:&quot;J_reset&quot;,&quot;row&quot;:scope.row}&apos;&gt;重置密码 &lt;/el-dropdown-item&gt; &lt;el-dropdown-item v-if=&quot;scope.row.status===&apos;1&apos;&quot; :command=&apos;{&quot;handle&quot;:&quot;J_enable&quot;,&quot;row&quot;:scope.row}&apos;&gt;启用 &lt;/el-dropdown-item&gt; &lt;el-dropdown-item v-if=&quot;scope.row.status===&apos;0&apos;&quot; :command=&apos;{&quot;handle&quot;:&quot;J_disabled&quot;,&quot;row&quot;:scope.row}&apos;&gt;禁用 &lt;/el-dropdown-item&gt; &lt;el-dropdown-item :command=&apos;{&quot;handle&quot;:&quot;J_delete&quot;,&quot;row&quot;:scope.row}&apos;&gt;删除 &lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;!-- JS --&gt; J_handle (command) { switch (command.handle) { case &apos;J_reset&apos;: this.flag.flag_dialog_reset = true; this.user = Object.assign({}, command.row); console.log(command.row); break; case &apos;J_enable&apos;: this.flag.flag_dialog_enable = true; this.user = Object.assign({}, command.row); this.$refs.ref_user_status.enablesize = &apos;启用&apos;; break; case &apos;J_disabled&apos;: this.flag.flag_dialog_enable = true; this.user = Object.assign({}, command.row); this.$refs.ref_user_status.enablesize = &apos;禁用&apos;; break; case &apos;J_delete&apos;: this.flag.flag_dialog_delete = true; this.dialog_data.userid = command.row.id; break; } } 4.多项checkbox选择如下图所示:&lt;el-table-column prop=&quot;fronts&quot; label=&quot;前台功能权限&quot; min-width=&quot;400&quot;&gt; &lt;template slot-scope=&quot;scope&quot; &gt; &lt;!-- &lt;el-checkbox-group&gt; --&gt; &lt;el-checkbox v-for=&quot;fun in scope.row.fronts&quot; :label=&quot;fun.funName&quot; :key=&quot;fun.id&quot; v-model=&quot;fun.checked&quot;&gt; &lt;/el-checkbox&gt; &lt;!-- &lt;/el-checkbox-group&gt; --&gt; &lt;/template&gt; &lt;/el-table-column&gt; 如果给所有选中的复制： &lt;!-- Js --&gt; fetchApi(`rest/rights/role/function/${role.id}`, &apos;GET&apos;).then(r =&gt; { let tempOldprivilege = r.data; for (var i = 0; i &lt; this.data_privilege.length; i++) { this.data_privilege[i].fronts.forEach((key) =&gt; { tempOldprivilege.forEach(value =&gt; { key.id === value.id ? (() =&gt; { console.log(key.id, key.checked, key.funName); this.$set(key, &apos;checked&apos;, true); })() : null; }); }); this.data_privilege[i].afters.forEach((key) =&gt; { tempOldprivilege.forEach(value =&gt; { key.id === value.id ? (() =&gt; { console.log(key.id, key.checked, key.funName); this.$set(key, &apos;checked&apos;, true); })() : null; }); }); } }); tempOldprivilege为所有选中的列表，fronts为表格某一列的，afters为另一列；但是有时候我们需要把重新选中的罗列出来let tempPrivilege = []; for (var i = 0; i &lt; this.data_privilege.length; i++) { let F = this.data_privilege[i].fronts.filter((key) =&gt; { return key.checked; }); let A = this.data_privilege[i].afters.filter((key) =&gt; { return key.checked; }); tempPrivilege = tempPrivilege.concat(F.concat(A)); } filter为js的迭代器算法–具体参考&lt;&lt;数据结构与算法-迭代器算法&gt;&gt;tempPrivilege为选中的所有的数组，F和A分别代表两列数组选中的数组5.未完待续…","categories":[{"name":"Vue","slug":"Vue","permalink":"https://algate.coding.me/categories/Vue/"}],"tags":[{"name":"elementUI","slug":"elementUI","permalink":"https://algate.coding.me/tags/elementUI/"}]},{"title":"ES6-Generator 函数的异步应用","slug":"ES6-Generator函数的异步应用","date":"2018-04-19T10:00:30.000Z","updated":"2019-02-27T03:27:59.533Z","comments":true,"path":"2018/04/19/ES6-Generator函数的异步应用/","link":"","permalink":"https://algate.coding.me/2018/04/19/ES6-Generator函数的异步应用/","excerpt":"异步编程对 JavaScript 语言太重要。Javascript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。传统方法ES6 诞生以前，异步编程的方法，大概有下面四种。回调函数事件监听发布/订阅Promise 对象Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。","text":"异步编程对 JavaScript 语言太重要。Javascript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。传统方法ES6 诞生以前，异步编程的方法，大概有下面四种。回调函数事件监听发布/订阅Promise 对象Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。function* helloWorldGenerator() { yield &apos;hello&apos;; yield &apos;world&apos;; return &apos;ending&apos;; } var hw = helloWorldGenerator(); 然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。hw.next() // { value: &apos;hello&apos;, done: false } hw.next() // { value: &apos;world&apos;, done: false } hw.next() // { value: &apos;ending&apos;, done: true } hw.next() // { value: undefined, done: true } Generator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。function* f() { console.log(&apos;执行了！&apos;) } var generator = f(); setTimeout(function () { generator.next() }, 2000); 上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是，函数f是一个 Generator 函数，就变成只有调用next方法时，函数f才会执行。另外需要注意，yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。var arr = [1, [[2, 3], 4], [5, 6]]; var flat = function* (a) { a.forEach(function (item) { if (typeof item !== &apos;number&apos;) { yield* flat(item); } else { yield item; } }); }; for (var f of flat(arr)){ console.log(f); } 上面代码也会产生句法错误，因为forEach方法的参数是一个普通函数，但是在里面使用了yield表达式（这个函数里面还使用了yield*表达式，详细介绍见后文）。一种修改方法是改用for循环。var arr = [1, [[2, 3], 4], [5, 6]]; var flat = function* (a) { var length = a.length; for (var i = 0; i &lt; length; i++) { var item = a[i]; if (typeof item !== &apos;number&apos;) { yield* flat(item); } else { yield item; } } }; for (var f of flat(arr)) { console.log(f); } // 1, 2, 3, 4, 5, 6 另外，yield表达式如果用在另一个表达式之中，必须放在圆括号里面。function* demo() { console.log(&apos;Hello&apos; + yield); // SyntaxError console.log(&apos;Hello&apos; + yield 123); // SyntaxError console.log(&apos;Hello&apos; + (yield)); // OK console.log(&apos;Hello&apos; + (yield 123)); // OK } yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。function* demo() { foo(yield &apos;a&apos;, yield &apos;b&apos;); // OK let input = yield; // OK }","categories":[{"name":"Es6","slug":"Es6","permalink":"https://algate.coding.me/categories/Es6/"}],"tags":[{"name":"Generator","slug":"Generator","permalink":"https://algate.coding.me/tags/Generator/"}]},{"title":"ES6-fetch","slug":"ES6-fetch","date":"2018-04-19T10:00:30.000Z","updated":"2019-02-27T03:27:59.539Z","comments":true,"path":"2018/04/19/ES6-fetch/","link":"","permalink":"https://algate.coding.me/2018/04/19/ES6-fetch/","excerpt":"123456let fetchApi = (url, type, params) =&gt; &#123; return fetch(`$&#123;baseURL + url&#125;`, &#123;method: type, body: JSON.stringify(params)&#125;).then( response =&gt; response.json() ).catch(error =&gt; console.error(&apos;Error:&apos;, error));&#125;;export default fetchApi;","text":"123456let fetchApi = (url, type, params) =&gt; &#123; return fetch(`$&#123;baseURL + url&#125;`, &#123;method: type, body: JSON.stringify(params)&#125;).then( response =&gt; response.json() ).catch(error =&gt; console.error(&apos;Error:&apos;, error));&#125;;export default fetchApi;Get请求需要对params做处理。下边给出最简单直接的修改处理let params = {}; // 参数 let temp = Object.keys(params).map(key =&gt; `${key}=${params[key]}`); // 转化成带等号的数组 &lt;!-- 对url的处理 --&gt; if (url.search(/\\?/) === -1) { url += &apos;?&apos; + temp.join(&apos;&amp;&apos;); } else { url += &apos;&amp;&apos; + temp.join(&apos;&amp;&apos;); }","categories":[{"name":"Es6","slug":"Es6","permalink":"https://algate.coding.me/categories/Es6/"}],"tags":[{"name":"fetch","slug":"fetch","permalink":"https://algate.coding.me/tags/fetch/"}]},{"title":"React-creat-app按需加载antd","slug":"React-create-react-app按需加载配置antd","date":"2018-04-17T02:35:30.000Z","updated":"2019-02-27T03:27:59.598Z","comments":true,"path":"2018/04/17/React-create-react-app按需加载配置antd/","link":"","permalink":"https://algate.coding.me/2018/04/17/React-create-react-app按需加载配置antd/","excerpt":"","text":"create-react-app运行代码，在此不做操作演示引入antdyarn add antd 修改 src/App.js，引入 antd 的按钮组件。import Button from &apos;antd/lib/button&apos;; 修改 src/App.css，在文件顶部引入 antd/dist/antd.css。@import &apos;~antd/dist/antd.css&apos;; 上述步骤在未运行eject之前是没有问题的。但是在实际开发过程中还有很多问题，例如上面的例子实际上加载了全部的 antd 组件的样式（对前端性能是个隐患）。此时我们需要对 create-react-app 的默认配置进行自定义，这里我们使用 react-app-rewired （一个对 create-react-app 进行自定义配置的社区解决方案）。下面讲解在运行eject前后，对组件react-app-rewired的不同配置；1.eject之前，就是默认配置/* package.json */ &quot;scripts&quot;: { - &quot;start&quot;: &quot;react-scripts start&quot;, + &quot;start&quot;: &quot;react-app-rewired start&quot;, - &quot;build&quot;: &quot;react-scripts build&quot;, + &quot;build&quot;: &quot;react-app-rewired build&quot;, - &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;, + &quot;test&quot;: &quot;react-app-rewired test --env=jsdom&quot;, } 然后在项目根目录创建一个 config-overrides.js 用于修改默认配置。module.exports = function override(config, env) { // do stuff with the webpack config... return config; }; 使用 babel-plugin-import#babel-plugin-import 是一个用于按需加载组件代码和样式的 babel 插件（原理），现在我们尝试安装它并修改 config-overrides.js 文件。$ yarn add babel-plugin-import --dev + const { injectBabelPlugin } = require(&apos;react-app-rewired&apos;); module.exports = function override(config, env) { + config = injectBabelPlugin([&apos;import&apos;, { libraryName: &apos;antd&apos;, libraryDirectory: &apos;es&apos;, style: &apos;css&apos; }], config); return config; }; 然后移除前面在 src/App.css 里全量添加的 @import ‘~antd/dist/antd.css’; 样式代码，并且按下面的格式引入模块。// App.js - @import &apos;~antd/dist/antd.css&apos;; // App.js做如下修改 - import Button from &apos;antd/lib/button&apos;; + import { Button } from &apos;antd&apos;; 是不是代码简洁了许多，并且还实现了按需加载。多美酸爽和惬意。2.运行eject之后，如果按照上述步骤进行处理，你会发现启动失败了package.json做如下修改是不行的。即时提示你需要升级react-scripts也是徒劳的。/* package.json */ &quot;scripts&quot;: { - &quot;start&quot;: &quot;node scripts/start&quot;, + &quot;start&quot;: &quot;react-app-rewired scripts/start&quot;, - &quot;build&quot;: &quot;node scripts/build&quot;, + &quot;build&quot;: &quot;react-app-rewired scripts/build&quot;, - &quot;test&quot;: &quot;node scripts/test --env=jsdom&quot;, + &quot;test&quot;: &quot;react-app-rewired scripts/test --env=jsdom&quot;, } 其实,package.json是不需要再作出修改的,so,保持eject之后的样子就ok了.npm install antd babel-plugin-import --save-dev 安装按需加载组件之后。 既然eject已经把配置信息暴露出来了，so 我们需要修改的就是配置信息了 在config -&gt; webpack.config.dev.js 和 webpack.config.prod.js 里（或者 .babelrc 文件）的babel-loader的options配置里，加入如下代码:plugins: [ [&apos;import&apos;, { libraryName: &apos;antd&apos;, libraryDirectory: &apos;es&apos;, style: &apos;css&apos; }] ] 如果使用自定义主题的话,我们可以引入react-app-rewire 的 less 插件 react-app-rewire-less 来帮助加载 less 样式（后续来补充吧）修改上一个代码中的 style:&#39;true&#39;, 如果启用了 style:true 那就必须是装less了。","categories":[{"name":"React","slug":"React","permalink":"https://algate.coding.me/categories/React/"}],"tags":[{"name":"antd","slug":"antd","permalink":"https://algate.coding.me/tags/antd/"},{"name":"add react-app-rewired","slug":"add-react-app-rewired","permalink":"https://algate.coding.me/tags/add-react-app-rewired/"}]},{"title":"后端导出excel文件","slug":"Vue-后端接口导出excel文件","date":"2018-04-16T06:02:30.000Z","updated":"2019-02-27T03:27:59.632Z","comments":true,"path":"2018/04/16/Vue-后端接口导出excel文件/","link":"","permalink":"https://algate.coding.me/2018/04/16/Vue-后端接口导出excel文件/","excerpt":"方法有很多种，这里介绍比较简单的两种方法：方法一：使用a链接，把后端给的流文件url直接写到href里，浏览器就会自动处理流文件url，直接实现下载；vue-html：&lt;a :href=&quot;href_dialog_upload_error&quot; v-show=&quot;flag.flag_uploaderror&quot;&gt;&lt;el-button type=&quot;primary&quot; size=&quot;small&quot;&gt;导出错误数据&lt;/el-button&gt;&lt;/a&gt; &lt;!-- &lt;el-button type=&quot;primary&quot; size=&quot;small&quot; v-show=&quot;flag.flag_uploaderror&quot; @click=&quot;J_dialog_export_error&quot;&gt;导出错误数据&lt;/el-button&gt; --&gt;","text":"方法有很多种，这里介绍比较简单的两种方法：方法一：使用a链接，把后端给的流文件url直接写到href里，浏览器就会自动处理流文件url，直接实现下载；vue-html：&lt;a :href=&quot;href_dialog_upload_error&quot; v-show=&quot;flag.flag_uploaderror&quot;&gt;&lt;el-button type=&quot;primary&quot; size=&quot;small&quot;&gt;导出错误数据&lt;/el-button&gt;&lt;/a&gt; &lt;!-- &lt;el-button type=&quot;primary&quot; size=&quot;small&quot; v-show=&quot;flag.flag_uploaderror&quot; @click=&quot;J_dialog_export_error&quot;&gt;导出错误数据&lt;/el-button&gt; --&gt; vue-js:data() { return { href_dialog_upload_error: &apos;&apos; } } // service配置： let uploadService = { exportError: baseURL + &apos;rest/rights/user/export&apos; }； // 然后给href赋值(v.excelBatch为错误代码参数) this.href_dialog_upload_error = `${uploadService.exportError}?excelbatch=${v.excelbatch}`; 方法二：设置后台返回的responseType属性。使用URL转化为浏览器可识别的url链接来实现；vue-html：&lt;el-button type=&quot;primary&quot; size=&quot;small&quot; v-show=&quot;flag.flag_uploaderror&quot; @click=&quot;J_dialog_export_error&quot;&gt;导出错误数据&lt;/el-button&gt; vue-js:server接口中设置 { responseType: ‘arraybuffer’ }返回的接口中，把data文件转为为blob文件，通过URL转化为浏览器可以识别的链接地址；// server let uploadService = { exportError(params) { return new Promise((resolve, reject) =&gt; { axios.get(baseURL + &apos;rest/rights/user/export&apos;, {params: params, responseType: &apos;arraybuffer&apos;}).then((r) =&gt; { resolve(r); }).catch((r) =&gt; { console.log(r); }); }); } } // js methods: { J_dialog_export_error() { let params = { excelbatch: this.excelbatch }; uploadService.exportError(params).then(r =&gt; { console.log(r); let blob = new Blob([r.data], {type: &apos;application/vnd.ms-excel&apos;}); window.location.href = window.URL.createObjectURL(blob); }); } } 此处如果想指定文件名：可以创建一个a标签。触发a的href并且指定download属性名就可以实现var link = document.createElement(‘a’);link.href = window.URL.createObjectURL(blob);link.download = ‘fileName’;link.click();window.URL.revokeObjectURL(link.href);URL.revokeObjectURL(之前文章提到过，具体看Media视频加密相关文章)URL.revokeObjectURL()方法会释放一个通过URL.createObjectURL()创建的对象URL. 当你要已经用过了这个对象URL,然后要让浏览器知道这个URL已经不再需要指向对应的文件的时候,就需要调用这个方法.具体的意思就是说,一个对象URL,使用这个url是可以访问到指定的文件的,但是我可能只需要访问一次,一旦已经访问到了,这个对象URL就不再需要了,就被释放掉,被释放掉以后,这个对象URL就不再指向指定的文件了.比如一张图片,我创建了一个对象URL,然后通过这个对象URL,我页面里加载了这张图.既然已经被加载,并且不需要再次加载这张图,那我就把这个对象URL释放,然后这个URL就不再指向这张图了.还有其他方法，比如说：1.创建一个隐藏的 iframe，把 iframe 的 src 指向这个 url，就可以下载了2.vue可以使用组件： https://github.com/kennethjiang/js-file-download","categories":[{"name":"Vue","slug":"Vue","permalink":"https://algate.coding.me/categories/Vue/"}],"tags":[{"name":"blob","slug":"blob","permalink":"https://algate.coding.me/tags/blob/"},{"name":"upload","slug":"upload","permalink":"https://algate.coding.me/tags/upload/"}]},{"title":"JS - 基础面试内容","slug":"Js-基本面试内容","date":"2018-04-14T02:46:30.000Z","updated":"2019-02-27T03:27:59.584Z","comments":true,"path":"2018/04/14/Js-基本面试内容/","link":"","permalink":"https://algate.coding.me/2018/04/14/Js-基本面试内容/","excerpt":"1.Doctype作用？标准模式与兼容模式各有什么区别?（1）、&lt;!DOCTYPE&gt;声明位于HTML文档中的第一行，处于 &lt;html&gt;标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。（2）、标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。2.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？（1）行内元素有：a b span img input select strong（强调的语气）（2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p（3）常见的空元素：&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;鲜为人知的是：&lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;","text":"1.Doctype作用？标准模式与兼容模式各有什么区别?（1）、&lt;!DOCTYPE&gt;声明位于HTML文档中的第一行，处于 &lt;html&gt;标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。（2）、标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。2.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？（1）行内元素有：a b span img input select strong（强调的语气）（2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p（3）常见的空元素：&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;鲜为人知的是：&lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;3.页面导入样式时，使用link和@import有什么区别？（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;(4)link支持使用js控制DOM去改变样式，而@import不支持;4.介绍一下你对浏览器内核的理解？主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。JS引擎则：解析和执行javascript来实现网页的动态效果。最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。5.常见的浏览器内核有哪些？Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;]Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）]6.html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。绘画 canvas;用于媒介回放的 video 和 audio 元素;本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;sessionStorage 的数据在浏览器关闭后自动删除;语意化更好的内容元素，比如 article、footer、header、nav、section;表单控件，calendar、date、time、email、url、search、tel、number;新的技术webworker, websocket, Geolocation;移除的元素：纯表现的元素：basefont，big，center，font, s，strike，tt，u;对可用性产生负面影响的元素：frame，frameset，noframes；支持HTML5新标签：IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式。当然也可以直接使用成熟的框架、比如html5shim;&lt;!--[if lt IE 9]&gt; &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; &lt;![endif]--&gt; 如何区分HTML5： DOCTYPE声明\\新增的结构元素\\功能元素7.简述一下你对HTML语义化的理解？用正确的标签做正确的事情。html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。8.HTML5的离线储存怎么使用，工作原理能不能解释一下？https://yanhaijing.com/html/2014/12/28/html5-manifest/在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。如何使用：1、页面头部像下面一样加入一个manifest的属性；2、在cache.manifest文件的编写离线存储的资源；3、在离线状态时，操作window.applicationCache进行需求实现。浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。离线的情况下，浏览器就直接使用离线存储的资源。9.请描述一下 cookies，sessionStorage 和 localStorage 的区别？cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。存储大小：cookie数据大小不能超过4k。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。有期时间：localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage 数据在当前浏览器窗口关闭后自动删除。cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭10.iframe有那些缺点？iframe会阻塞主页面的Onload事件；搜索引擎的检索程序无法解读这种页面，不利于SEO;iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。11.Label的作用是什么？是怎么用的？label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。&lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt; &lt;input type=“text“name=&quot;Name&quot; id=&quot;Name&quot;/&gt; &lt;label&gt;Date:&lt;input type=&quot;text&quot; name=&quot;B&quot;/&gt;&lt;/label&gt; 12.如何实现浏览器内多个标签页之间的通信? (阿里)WebSocket、SharedWorker；也可以调用localstorge、cookies等本地存储方式；localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信；注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常；13.webSocket如何兼容低浏览器？(阿里)Adobe Flash Socket 、ActiveX HTMLFile (IE) 、基于 multipart 编码发送 XHR 、基于长轮询的 XHR14.网页验证码是干嘛的，是为了解决什么安全问题。区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。15.介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？（1）有两种， IE 盒子模型、W3C 盒子模型；（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；（3）区 别： IE的content部分把 border 和 padding计算了进去;16.CSS选择符有哪些？哪些属性可以继承？1.id选择器（ # myid）2.类选择器（.myclassname）3.标签选择器（div, h1, p）4.相邻选择器（h1 + p）5.子选择器（ul &gt; li）6.后代选择器（li a）7.通配符选择器（ * ）8.属性选择器（a[rel = “external”]）9.伪类选择器（a:hover, li:nth-child）可继承的样式： font-size font-family color, UL LI DL DD DT;不可继承的样式：border padding margin width height ;17.CSS优先级算法如何计算？优先级就近原则，同权重情况下样式定义最近者为准;载入样式以最后载入的定位为准;优先级为:同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。!important &gt; id &gt; class &gt; tagimportant 比 内联优先级高18.CSS3新增伪类有那些？举例：p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 ::after 在元素之前添加内容,也可以用来做清除浮动。 ::before 在元素之后添加内容 :enabled :disabled 控制表单控件的禁用状态。 :checked 单选框或复选框被选中。 19.display有哪些值？说明他们的作用。block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。 none 缺省值。象行内元素类型一样显示。 inline 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。 inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。 list-item 象块类型元素一样显示，并添加样式列表标记。 table 此元素会作为块级表格来显示。 inherit 规定应该从父元素继承 display 属性的值。 20.position的值relative和absolute定位原点是？absolute生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。fixed （老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。relative生成相对定位的元素，相对于其正常位置进行定位。static默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。inherit规定从父元素继承 position 属性的值。21.CSS3有哪些新特性？新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）圆角 （border-radius:8px）多列布局 （multi-column layout）阴影和反射 （Shadow\\Reflect）文字特效 （text-shadow、）文字渲染 （Text-decoration）线性渐变 （gradient）旋转 （transform）缩放,定位,倾斜,动画,多背景例如:transform:\\scale(0.85,0.90)\\ translate(0px,-30px)\\ skew(-9deg,0deg)\\Animation:22.请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。在布局上有了比以前更加灵活的空间。http://www.w3cplus.com/css3/flexbox-basics.html23.一个满屏 品 字布局 如何设计?简单的方式：上面的div宽100%，下面的两个div分别宽50%，然后用float或者inline使其不换行即可24.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.浏览器默认的margin和padding不同。解决方案是加一个全局的 nodeName{margin:0;padding:0;}来统一。IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;}这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用“\\9”这一标记，将IE游览器从所有情况中分离出来。接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。css:.bb{ background-color:red;/*所有识别*/ background-color:#00deff\\9; /*IE6、7、8识别*/ +background-color:#a200ff;/*IE6、7识别*/ \\_background-color:#1e0bd1;/*IE6识别*/ } IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;Firefox下,只能使用getAttribute()获取自定义属性。解决方法:统一通过getAttribute()获取自定义属性。IE下,even对象有x,y属性,但是没有pageX,pageY属性;Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。25.超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:L-V-H-A : a:link {} a:visited {} a:hover {} a:active {} 26.li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。27.为什么要初始化CSS样式。因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。最简单的初始化方法： *{padding: 0; margin: 0;} （强烈不建议）淘宝的样式初始化代码：body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; } body, button, input, select, textarea { font:12px/1.5tahoma, arial, \\5b8b\\4f53; } h1, h2, h3, h4, h5, h6{ font-size:100%; } address, cite, dfn, em, var { font-style:normal; } code, kbd, pre, samp { font-family:couriernew, courier, monospace; } small{ font-size:12px; } ul, ol { list-style:none; } a { text-decoration:none; } a:hover { text-decoration:underline; } sup { vertical-align:text-top; } sub{ vertical-align:text-bottom; } legend { color:#000; } fieldset, img { border:0; } button, input, select, textarea { font-size:100%; } table { border-collapse:collapse; border-spacing:0; } 28.CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？对于普通元素visibility:collapse;会将元素完全隐藏,不占据页面布局空间,与display:none;表现相同. 如果目标元素为table,visibility:collapse;将table隐藏,但是会占据页面布局空间. 仅在Firefox下起作用,IE会显示元素,Chrome会将元素隐藏,但是占据空间.29.对BFC规范(块级格式化上下文：block formatting context)的理解？（W3C CSS 2.1 规范中的一个概念,它是一个独立容器，决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。）一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型。不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部30.css定义的权重以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值：123456789101112131415161718/*权重为1*/div&#123;&#125;/*权重为10*/.class1&#123;&#125;/*权重为100*/#id1&#123;&#125;/*权重为100+1=101*/#id1 div&#123;&#125;/*权重为10+1=11*/.class1 div&#123;&#125;/*权重为10+10+1=21*/.class1 .class2 div&#123;&#125;如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现31.请解释一下为什么需要清除浮动？清除浮动的方式清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。1、父级div定义height；2、父级div 也一起浮动；3、常规的使用一个class；.clearfix::before, .clearfix::after { content: &quot; &quot;; display: table; } .clearfix::after { clear: both; } .clearfix { \\*zoom: 1; } 4、SASS编译的时候，浮动元素的父级div定义伪类:after&amp;::after,&amp;::before{ content: &quot; &quot;; visibility: hidden; display: block; height: 0; clear: both; } 解析原理：1) display:block 使生成的元素以块级元素显示,占满剩余空间;2) height:0 避免生成内容破坏原有布局的高度。3) visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互;4）通过 content:”.”生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的 content:”.”,有些版本可能content 里面内容为空,一丝冰凉是不推荐这样做的,firefox直到7.0 content:”” 仍然会产生额外的空隙；5）zoom：1 触发IE hasLayout。通过分析发现，除了clear：both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size0，line-height：0。32.zoom:1的清除浮动原理?清除浮动，触发hasLayout；Zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等。来龙去脉大概如下：当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。Zoom属是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标准化，出现在 CSS 3.0 规范草案中。目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？可以通过css3里面的动画属性scale进行缩放。33.移动端的布局用过媒体查询吗？假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来， 而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。 当媒体查询返回假， 标签上带有媒体查询的样式表 仍将被下载 （只不过不会被应用）。包含了一个媒体类型和至少一个使用 宽度、高度和颜色等媒体属性来限制样式表范围的表达式。 CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。&lt;style&gt; @media (min-width: 700px) and (orientation: landscape){ .sidebar { display: none; } } &lt;/style&gt; 34.CSS优化、提高性能的方法有哪些？关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）；如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）；提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性;使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）；35.如何修改chrome记住密码后自动填充表单的黄色背景 ？input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill { background-color: rgb(250, 255, 189); /* #FAFFBD; */ background-image: none; color: rgb(0, 0, 0); } 36.如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms37.么是CSS 预处理器 / 后处理器？预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。38.介绍js的基本数据类型。Undefined、Null、Boolean、Number、String、 ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 ) 39.介绍js有哪些内置对象？Object 是 JavaScript 中所有对象的父对象参考：http://www.ibm.com/developerworks/cn/web/wa-objectsinjs-v1b/index.html40.说几条写JavaScript的基本规范？1.不要在同一行声明多个变量。2.请使用 ===/!==来比较true/false或者数值3.使用对象字面量替代new Array这种形式4.不要使用全局函数。5.Switch语句必须带有default分支6.函数不应该有时候有返回值，有时候没有返回值。7.For循环必须使用大括号8.If语句必须使用大括号9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。41.JavaScript原型，原型链 ? 有什么特点？每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。关系：instance.constructor.prototype = instance.proto特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。function Func(){} Func.prototype.name = &quot;Sean&quot;; Func.prototype.getInfo = function() { return this.name; } var person = new Func();//现在可以参考var person = Object.create(oldObject); console.log(person.getInfo());//它拥有了Func的属性和方法 //&quot;Sean&quot; console.log(Func.prototype); // Func { name=&quot;Sean&quot;, getInfo=function()} 42.写一个通用的事件侦听器函数。event(事件)工具集，来源：github.com/markyunmarkyun.Event = { // 页面加载完成后 readyEvent : function(fn) { if (fn==null) { fn=document; } var oldonload = window.onload; if (typeof window.onload != &apos;function&apos;) { window.onload = fn; } else { window.onload = function() { oldonload(); fn(); }; } }, // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent : function(element, type, handler) { if (element.addEventListener) { //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); } else if (element.attachEvent) { element.attachEvent(&apos;on&apos; + type, function() { handler.call(element); }); } else { element[&apos;on&apos; + type] = handler; } }, // 移除事件 removeEvent : function(element, type, handler) { if (element.removeEventListener) { element.removeEventListener(type, handler, false); } else if (element.datachEvent) { element.detachEvent(&apos;on&apos; + type, handler); } else { element[&apos;on&apos; + type] = null; } }, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation : function(ev) { if (ev.stopPropagation) { ev.stopPropagation(); } else { ev.cancelBubble = true; } }, // 取消事件的默认行为 preventDefault : function(event) { if (event.preventDefault) { event.preventDefault(); } else { event.returnValue = false; } }, // 获取事件目标 getTarget : function(event) { return event.target || event.srcElement; }, // 获取event对象的引用，取到事件的所有信息，确保随时能使用event； getEvent : function(e) { var ev = e || window.event; if (!ev) { var c = this.getEvent.caller; while (c) { ev = c.arguments[0]; if (ev &amp;&amp; Event == ev.constructor) { break; } c = c.caller; } } return ev; } }; 43.事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件；ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;）44.什么是闭包（closure），为什么要用它？闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。闭包的特性：1.函数内再嵌套函数2.内部函数可以引用外层的参数和变量3.参数和变量不会被垃圾回收机制回收li节点的onclick事件都能正确的弹出当前被点击的li索引&lt;ul id=&quot;testUL&quot;&gt; &lt;li&gt; index = 0&lt;/li&gt; &lt;li&gt; index = 1&lt;/li&gt; &lt;li&gt; index = 2&lt;/li&gt; &lt;li&gt; index = 3&lt;/li&gt; &lt;/ul&gt; &lt;script type=&quot;text/javascript&quot;&gt; var nodes = document.getElementsByTagName(&quot;li&quot;); for(i = 0;i&lt;nodes.length;i+= 1){ nodes[i].onclick = (function(i){ return function() { console.log(i); } //不用闭包的话，值每次都是4 })(i); } &lt;/script&gt; 执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源因为say667()的内部函数的执行需要依赖say667()中的变量这是对闭包作用的非常直白的描述function say667() { // Local variable that ends up within closure var num = 666; var sayAlert = function() { alert(num); } num++; return sayAlert; } var sayAlert = say667(); sayAlert()//执行结果应该弹出的667 45.javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值;全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用；消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同;提高编译器效率，增加运行速度；为未来新版本的Javascript标准化做铺垫。46.new操作符具体干了什么呢?1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。2、属性和方法被加入到 this 引用的对象中。3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。var obj = {}; obj.__proto__ = Base.prototype; Base.call(obj); 47.[].forEach.call($$(&quot;*&quot;),function(a){a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？$$(‘a’) 你可以在自己的浏览器上面运行一下，就是页面上所有的a标签~~ 看在浏览器上面的运行(所以~~的作用就相当于parseInt)var a=12.233~~as12var b=-123.455~~b-1231&lt;&lt;24 也就是1向左移24位 也就是2的24次方48.js延迟加载的方式有哪些？defer和async、动态创建DOM方式（用得最多）、按需异步载入js49.Ajax 是什么? 如何创建一个Ajax？ajax的全称：Asynchronous Javascript And XML。异步传输+js+xml。所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息(3)设置响应HTTP请求状态变化的函数(4)发送HTTP请求(5)获取异步调用返回的数据(6)使用JavaScript和DOM实现局部刷新50.Ajax 解决浏览器缓存问题？1、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。2、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。3、在URL后面加上一个随机数： “fresh=” + Math.random();。4、在URL后面加上时间戳：”nowtime=” + new Date().getTime();。5、如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。51.如何解决跨域问题?jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面52.AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。区别：对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：// CMDdefine(function(require, exports, module) { var a = require(&apos;./a&apos;) a.doSomething() // 此处略去 100 行 var b = require(&apos;./b&apos;) // 依赖可以就近书写 b.doSomething() // ... }) // AMD 默认推荐define([&apos;./a&apos;, &apos;./b&apos;], function(a, b) { // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() // ... }) 53.DOM操作——怎样添加、移除、移动、复制、创建和查找节点?（1）创建新节点createDocumentFragment() //创建一个DOM片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点（2）添加、移除、替换、插入appendChild()removeChild()replaceChild()insertBefore() //在已有的子节点前插入一个新的子节点（3）查找getElementsByTagName() //通过标签名称getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)getElementById() //通过元素Id，唯一性54.js函数节流和函数防抖函数节流应用的实际场景，多数在监听页面元素滚动事件的时候会用到。因为滚动事件，是一个高频触发的事件。函数防抖的应用场景，最常见的就是用户注册时候的手机号码验证和邮箱验证了。只有等用户输入完毕后，前端才需要检查格式是否正确，如果不正确，再弹出提示语。概念解释函数节流: 频繁触发,但只在特定的时间内才执行一次代码函数防抖: 频繁触发,但只在特定的时间内没有触发执行条件才执行一次代码// 普通滚动document.getElementById(&quot;nothing&quot;).onscroll = function(){ console.log(&quot;普通滚动&quot;); }; // 函数节流var canRun = true; document.getElementById(&quot;throttle&quot;).onscroll = function(){ if(!canRun){ // 判断是否已空闲，如果在执行中，则直接return return; } canRun = false; setTimeout(function(){ console.log(&quot;函数节流&quot;); canRun = true; }, 300); }; // 函数防抖var timer = false; document.getElementById(&quot;debounce&quot;).onscroll = function(){ clearTimeout(timer); // 清除未执行的代码，重置回初始化状态 timer = setTimeout(function(){ console.log(&quot;函数防抖&quot;); }, 300); }; 55.描述一下React 生命周期渲染过程调用到的生命周期函数，主要几个要知道；constructor getInitialState getDefaultProps componentWillMount render componentDidMount 更新过程componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate 卸载过程componentWillUnmount 56.实现组件有哪些方式？React.createClass 使用API来定义组件React ES6 class component 用 ES6 的class 来定义组件Functional stateless component 通过函数定义无状态组件57.页面重构怎么操作？网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。对于传统的网站来说重构通常是：表格(table)布局改为DIV+CSS使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)对于移动平台的优化针对于SEO进行优化深层次的网站重构应该考虑的方面减少代码间的耦合让代码保持弹性严格按规范编写代码设计可扩展的API代替旧有的框架、语言(如VB)增强用户体验通常来说对于速度的优化也包含在重构中压缩JS、CSS、image等前端资源(通常是由服务器来解决)程序的性能优化(如数据读写)采用CDN来加速资源加载对于JS DOM的优化HTTP服务器的文件缓存58.什么叫优雅降级和渐进增强？优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。如：border-shadow渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验；59.你有用过哪些前端性能优化的方法？（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。（4） 当需要设置的样式很多时设置className而不是直接操作style。（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。（7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。（8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。60.http状态码有那些？分别代表是什么意思？简单版[100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息200 OK 正常返回信息201 Created 请求成功并且服务器创建了新的资源202 Accepted 服务器已接受请求，但尚未处理301 Moved Permanently 请求的网页已永久移动到新位置。302 Found 临时性重定向。303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。304 Not Modified 自从上次请求后，请求的网页未修改过。400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。401 Unauthorized 请求未授权。403 Forbidden 禁止访问。404 Not Found 找不到如何与 URI 相匹配的资源。500 Internal Server Error 最常见的服务器端错误。503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。]完整版1**(信息类)：表示接收到请求并且继续处理 100——客户必须继续发出请求101——客户要求服务器根据请求转换HTTP协议版本2**(响应成功)：表示动作被成功接收、理解和接受 200——表明该请求被成功地完成，所请求的资源发送回客户端201——提示知道新文件的URL202——接受和处理、但处理未完成203——返回信息不确定或不完整204——请求收到，但返回信息为空205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件206——服务器已经完成了部分用户的GET请求3**(重定向类)：为了完成指定的动作，必须接受进一步处理 300——请求的资源可在多处得到301——本网页被永久性转移到另一个URL302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。303——建议客户访问其他URL或访问方式304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用305——请求的资源必须从服务器指定的地址得到306——前一版本HTTP中使用的代码，现行版本中不再使用307——申明请求的资源临时性删除4**(客户端错误类)：请求包含错误语法或不能正确执行 400——客户端请求有语法错误，不能被服务器所理解401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用HTTP 401.1 - 未授权：登录失败HTTP 401.2 - 未授权：服务器配置问题导致登录失败HTTP 401.3 - ACL 禁止访问资源HTTP 401.4 - 未授权：授权被筛选器拒绝HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败402——保留有效ChargeTo头响应403——禁止访问，服务器收到请求，但是拒绝提供服务HTTP 403.1 禁止访问：禁止可执行访问HTTP 403.2 - 禁止访问：禁止读访问HTTP 403.3 - 禁止访问：禁止写访问HTTP 403.4 - 禁止访问：要求 SSLHTTP 403.5 - 禁止访问：要求 SSL 128HTTP 403.6 - 禁止访问：IP 地址被拒绝HTTP 403.7 - 禁止访问：要求客户证书HTTP 403.8 - 禁止访问：禁止站点访问HTTP 403.9 - 禁止访问：连接的用户过多HTTP 403.10 - 禁止访问：配置无效HTTP 403.11 - 禁止访问：密码更改HTTP 403.12 - 禁止访问：映射器拒绝访问HTTP 403.13 - 禁止访问：客户证书已被吊销HTTP 403.15 - 禁止访问：客户访问许可过多HTTP 403.16 - 禁止访问：客户证书不可信或者无效HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL405——用户在Request-Line字段定义的方法不允许406——根据用户发送的Accept拖，请求资源不可访问407——类似401，用户必须首先在代理服务器上得到授权408——客户端没有在用户指定的饿时间内完成请求409——对当前资源状态，请求不能完成410——服务器上不再有此资源且无进一步的参考地址411——服务器拒绝用户定义的Content-Length属性请求412——一个或多个请求头字段在当前请求中错误413——请求的资源大于服务器允许的大小414——请求的资源URL长于服务器允许的长度415——请求资源不支持请求项目格式416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。5**(服务端错误类)：服务器不能正确执行一个正确的请求 HTTP 500 - 服务器遇到错误，无法完成请求HTTP 500.100 - 内部服务器错误 - ASP 错误HTTP 500-11 服务器关闭HTTP 500-12 应用程序重新启动HTTP 500-13 - 服务器太忙HTTP 500-14 - 应用程序无效HTTP 500-15 - 不允许请求 global.asaError 501 - 未实现HTTP 502 - 网关错误HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常61.一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；详细版：1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;4、进行HTTP协议会话，客户端发送报头(请求报头);5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。简洁版：浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；载入解析到的资源文件，渲染页面，完成。62.前端工程师参与项目，快速高质量完成实现效果图，精确到1px；与团队成员，UI设计，产品经理的沟通；做好的页面结构，页面重构和用户体验；处理hack，兼容、写出优美的代码格式；针对服务器的优化、拥抱最新前端技术。63.平时如何管理你的项目？先期团队必须确定好全局样式（global.css），编码模式(utf-8) 等；编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；页面进行标注（例如 页面 模块 开始和结束）；CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；JS 分文件夹存放 命名以该JS功能为准的英文翻译。图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理64.兼容性问题1.如果图片加a标签在IE9-中会有边框2.rgba不支持IE83.display:inline-block ie6/7不支持display:inline-block; *display:inline; 4.height不能小于16px,设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度解决方案:overflow设置为hidden 5.png图片 IE6里面的png图片不能透明 兼容版本和无声明版本都是解决方案:&lt;!--[if IE ]&gt; &lt;style type=&quot;text/css&quot;&gt; #DIVname{ background:none; filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(enabled=true, sizingMethod=scale, src=&quot;pngtouming.png&quot; } &lt;/style&gt; &lt;![endif]--&gt; 6.CSS3前缀-webkit- webkit渲染引擎 chrome/safari -moz- gecko渲染引擎 firefox -ms- trident渲染引擎 IE -o- opeck渲染引擎 opera 7.渐变filter: progid:DXImageTransform.Microsoft.Gradient(gradientType=0,startColorStr=#35FEA1,endColorStr=#6E9DFF); /*IE 6 7 8*/ background: -ms-linear-gradient(top, #35FEA1, #6E9DFF);/* IE 10 */ background:-moz-linear-gradient(top, #35FEA1, #6E9DFF); /*火狐*/ background:-webkit-gradient(linear, 0% 0%, 0% 100%,from(#35FEA1), to(#6E9DFF));/*谷歌*/ background: -webkit-gradient(linear, 0% 0%, 0% 100%,from(#35FEA1), to(#6E9DFF));/* Safari 4-5, Chrome 1-9*/ background: -webkit-linear-gradient(top, #35FEA1, #6E9DFF);/*Safari5.1 Chrome 10+*/ background: -o-linear-gradient(top, #35FEA1, #6E9DFF);/*Opera 11.10+*/ 8.PIE.htc 可以实现很多css3属性在IE下的兼容性 如:圆角、阴影、渐变(1) 圆角 border-radius.signBtn{ height: 40px; background-color:#08BCD2; color: #fff; -webkit-border-radius: 3px; -moz-border-radius: 3px; border-radius: 3px; behavior: url(css/PIE.htc); } (2)阴影 box-shadow.box{ width:200px; height:200px; -webkit-box-shadow:1px 0 10px; -moz-box-shadow:1px 0 10px; box-shadow: 1px 0 10px; background-color: #fff; behavior: url(css/PIE.htc);/*IE边框阴影*/ } (3)背景透明rgba.box{ background-color:rgba(12, 154, 171, 0.29); behavior: url(css/PIE.htc); -pie-background:rgba(12, 154, 171, 0.29); } (4)渐变.box{ width:200px; height:400px; background:-webkit-gradient(linear, 0 0, 0 bottom, from(#9F9), to(#393)); background:-moz-linear-gradient(#9F9, #393); -pie-background:linear-gradient(#9F9, #393); behavior:url(pie.htc); } 注:PIE.htc文件路径相对是相对于css文件,并非html文件,以上例子是将PIE.htc文件放在与css样式文件同一个文件夹css内,而对应的html问价与css文件夹同级65.标准浏览器和IE浏览器Dom操作DOM标准的浏览器事件是通过addEventListener方法注册的，而IE内核的浏览器则是通过attachEvent方法注册的。IE内核的浏览器事件模型是冒泡型事件，也就是说，在IE内核下，时间句柄的出发顺序是从ChildNode到ParentNode。DOM标准的浏览器中多了一个事件捕获过程，也就是说，当开发者在一个元素上注册了事件后，这个事件的相应顺序是从window（顶层）开始一级一级向下传播，然后到了该元素后事件捕获过程结束，事件开始冒泡，一级一级向父元素冒泡。阻止浏览器默认行为当我们要阻止浏览器中某个DOM元素的默认行为时，在W3C标准里调用e.preventDefault()，而在IE下则是通过设置window.event.returnValue=false来实现 阻止冒泡事件在W3C标准里调用e.stopPropagation()，而在IE下通过设置window.event.cancelBubble=true来实现 2.event对象有x、y两属性，FireFox中没有;相对的在FireFox中，event对象有pageX、pageY两属性3.在IE中event对象有srcElement属性,但是没有target属性; 在Firefox中event对象有target属性,但是没有srcElement属性event.target|| event.srcElement4.var boy = someone.firstElementChild || someone.firstChild;66. typeof 和 instanceof判断一个变量的类型尝尝会用 typeof 运算符instanceof 运算符用于识别正在处理的对象的类型（判断一个实例是否属于构造函数类型）var oStringObject = new String(&quot;hello world&quot;); console.log(oStringObject instanceof String); instanceof 常规用法// 判断 foo 是否是 Foo 类的实例function Foo(){}var foo = new Foo();console.log(foo instanceof Foo)//trueinstanceof 在继承中关系中的用法// 判断 foo 是否是 Foo 类的实例 , 并且是否是其父类型的实例function Aoo(){}function Foo(){}Foo.prototype = new Aoo();//JavaScript 原型继承var foo = new Foo();console.log(foo instanceof Foo)//trueconsole.log(foo instanceof Aoo)//true4.instanceof 复杂用法console.log(Object instanceof Object);//trueconsole.log(Function instanceof Function);//trueconsole.log(Number instanceof Number);//falseconsole.log(String instanceof String);//falseconsole.log(Function instanceof Object);//trueconsole.log(Foo instanceof Function);//trueconsole.log(Foo instanceof Foo);//false","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://algate.coding.me/categories/Javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://algate.coding.me/tags/基础知识/"}]},{"title":"arguments.callee","slug":"JS进阶-arguments.callee","date":"2018-04-14T02:46:30.000Z","updated":"2019-02-27T03:27:59.566Z","comments":true,"path":"2018/04/14/JS进阶-arguments.callee/","link":"","permalink":"https://algate.coding.me/2018/04/14/JS进阶-arguments.callee/","excerpt":"arguments是JS的一个内置（隐藏）的对象，当在调用函数时，就会实例化出这个对象，而arguments.callee是一个指向正在执行的函数的指针，这样就可以通过arguments.callee来调用函数，尤其是在编写递归函数的时候。在函数内部，有两个特殊的对象：arguments 和 this。其中， arguments 的主要用途是保存函数参数， 但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。 请看下面这个非常经典的阶乘函数function factorial(num){ if (num &lt;=1) { return 1; } else { return num * factorial(num-1) } } 如果像下面这样使用它，则会出错：var fcopy = factorial;factorial = null;alert(fcopy(3));因为fcopy指向的函数实体调用了factorial，而factorial已经被释放。解决有下边两种办法","text":"arguments是JS的一个内置（隐藏）的对象，当在调用函数时，就会实例化出这个对象，而arguments.callee是一个指向正在执行的函数的指针，这样就可以通过arguments.callee来调用函数，尤其是在编写递归函数的时候。在函数内部，有两个特殊的对象：arguments 和 this。其中， arguments 的主要用途是保存函数参数， 但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。 请看下面这个非常经典的阶乘函数function factorial(num){ if (num &lt;=1) { return 1; } else { return num * factorial(num-1) } } 如果像下面这样使用它，则会出错：var fcopy = factorial;factorial = null;alert(fcopy(3));因为fcopy指向的函数实体调用了factorial，而factorial已经被释放。解决有下边两种办法1.定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。为 了消除这种紧密耦合的现象，可以像下面这样使用 arguments.calleefunction factorial(num){if (num &lt;=1) { return 1; } else { return num * arguments.callee(num-1); } }在这个重写后的 factorial()函数的函数体内，没有再引用函数名 factorial。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。例如function factorial(num){ if(num &lt;= 1){ return 1; }else{ return num * arguments.callee(num-1); } } var trueFactorial = factorial; alert(trueFactorial(5)); //120 factorial = function() { return 0; } alert(trueFactorial(5));// 120 如果没有使用arguments.callee，将返回0 2.使用函数表达式var factorial = (function f(n){if (n&lt;=1) { return 1; }else{ return f(n-1)*n; } })这并非使用了什么新的技术，只是在原来概念上的一种应用，在定义 factorial 时，直接创建一个函数，再将此函数的引用赋值给factorial。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://algate.coding.me/categories/Javascript/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://algate.coding.me/tags/递归/"},{"name":"arguments.callee","slug":"arguments-callee","permalink":"https://algate.coding.me/tags/arguments-callee/"}]},{"title":"Vue - 表单验证规则","slug":"Vue-表单验证规则","date":"2018-04-13T10:12:30.000Z","updated":"2019-02-27T03:27:59.646Z","comments":true,"path":"2018/04/13/Vue-表单验证规则/","link":"","permalink":"https://algate.coding.me/2018/04/13/Vue-表单验证规则/","excerpt":"","text":"表单相关代码：&lt;header class=&quot;c_dialog_header&quot;&gt; &lt;span&gt;{{title}}&lt;/span&gt; &lt;i class=&quot;el-icon-close right&quot; @click=&quot;close(&apos;info_user&apos;)&quot;&gt;&lt;/i&gt; &lt;/header&gt; &lt;el-form :model=&quot;info_user&quot; label-width=&quot;80px&quot; :rules=&quot;rules&quot; ref=&quot;info_user&quot;&gt; &lt;el-form-item label=&quot;账号&quot; prop=&quot;loginName&quot;&gt; &lt;el-input v-model=&quot;info_user.loginName&quot; placeholder=&quot;账号&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;姓名&quot;&gt; &lt;el-input v-model=&quot;info_user.name&quot; placeholder=&quot;姓名&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;!-- &lt;el-form-item label=&quot;机构&quot;&gt; &lt;el-input v-model=&quot;info_user.deptName&quot; placeholder=&quot;机构&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; --&gt; &lt;el-form-item label=&quot;性别&quot;&gt; &lt;el-radio-group v-model=&quot;info_user.sex&quot;&gt; &lt;el-radio label=&quot;0&quot;&gt;男&lt;/el-radio&gt; &lt;el-radio label=&quot;1&quot;&gt;女&lt;/el-radio&gt; &lt;/el-radio-group&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;角色&quot; v-if=&quot;userType===3&quot;&gt; &lt;el-checkbox-group v-model=&quot;info_user.userType&quot;&gt; &lt;el-checkbox label=&quot;老师&quot;&gt;&lt;/el-checkbox&gt; &lt;el-checkbox label=&quot;校领导&quot;&gt;&lt;/el-checkbox&gt; &lt;el-checkbox label=&quot;站点管理员&quot;&gt;&lt;/el-checkbox&gt; &lt;/el-checkbox-group&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;邮箱&quot;&gt; &lt;el-input v-model=&quot;info_user.email&quot; placeholder=&quot;邮箱&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;电话&quot;&gt; &lt;el-input v-model=&quot;info_user.phone&quot; placeholder=&quot;电话&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;footer class=&quot;c_dialog_footer&quot;&gt; &lt;el-button type=&quot;info&quot; size=&quot;small&quot; plain @click=&quot;close(&apos;info_user&apos;)&quot;&gt;取消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; size=&quot;small&quot; @click=&quot;J_dialog_data_save(&apos;info_user&apos;)&quot;&gt;确定&lt;/el-button&gt; &lt;/footer&gt; 此处代码为弹层 about 添加和编辑功能时使用的代码script:data() {&lt;!-- 自定义规则 validateLoginname --&gt; let validateLoginname = (rule, value, callback) =&gt; { &lt;!-- 如果使用v-if，value为undefined；如果使用v-show，可以判断 value===&apos;&apos; --&gt; if (!value) { callback(); } else { if (this.info_user.loginName !== &apos;&apos;) { let params = { loginName: this.info_user.loginName }; userService.check_loginname(params).then(r =&gt; { r.data.code !== 0 ? callback(new Error(&apos;重新输入账户名&apos;)) : callback(); }); } } }; return { userType: &apos;&apos;, title: &apos;&apos;, rules: { loginName: [ { required: true, message: &apos;请输入账号名&apos; }, { validator: validateLoginname, trigger: &apos;blur&apos; } ] } }; }script-methodmethods: {close(form) { &lt;!-- 需要移除校验结果 --&gt; // 这是个弹层，用的v-show显示的弹层。直接关闭弹层需要清除校验结果使用的方法 this.$refs[form].resetFields(); this.$emit(&apos;close&apos;); }, J_dialog_data_save(form) { &lt;!-- 验证方法 --&gt; this.$refs[form].validate((valid) =&gt; { /* eslint-disable no-unused-expressions */ valid ? () =&gt; { if (this.title === &apos;用户编辑&apos;) { // save edit data let params = { id: this.info_user.id, deptId: this.deptId, loginName: this.info_user.loginName, name: this.info_user.name, sex: this.info_user.sex, email: this.info_user.email, phone: this.info_user.phone }; userService.editUser(params).then(r =&gt; { r.data.code === 0 ? this.$message.success(r.data.msg) : this.$message.error(r.data.msg); this.$emit(&apos;close&apos;, r.data.code === 0 ? &apos;update&apos; : null); }); } else { // save add data let params = { deptId: this.deptId, loginName: this.info_user.loginName, name: this.info_user.name, sex: this.info_user.sex, userType: this.userType, email: this.info_user.email, phone: this.info_user.phone }; userService.addUser(params).then(r =&gt; { r.data.code === 0 ? this.$message.success(r.data.msg) : this.$message.error(r.data.msg); this.$emit(&apos;close&apos;, r.data.code === 0 ? &apos;update&apos; : null); }); } } : null; }); } }","categories":[{"name":"Vue","slug":"Vue","permalink":"https://algate.coding.me/categories/Vue/"}],"tags":[{"name":"表单验证","slug":"表单验证","permalink":"https://algate.coding.me/tags/表单验证/"}]},{"title":"数据结构与算法 - 高级算法","slug":"数据结构与算法-高级算法","date":"2018-04-12T09:48:30.000Z","updated":"2019-02-27T03:27:59.668Z","comments":true,"path":"2018/04/12/数据结构与算法-高级算法/","link":"","permalink":"https://algate.coding.me/2018/04/12/数据结构与算法-高级算法/","excerpt":"本文探讨两个高级主题：动态规划 和 贪心算法。【一】 动态规划动态规划被认为是一种与递归相反的技术，递归是从顶部开始将问题分解。1.使用递归解决问题虽然简洁，但是效率不高。包括JavaScript在内的众多语言，不能高效的将递归代码解析为机器代码，尽管写出来的代码简洁，但是执行效率低下。但并不是说使用递归是件坏事。2.本质上，只是那些指令式编程语言和面向对象的编程语言对递归的实现不够完善（它们没有将递归作为高级编程的特性）。3.许多使用递归去解决的编程问题，可以重写为使用动态规划的技巧去解决。动态规划方案通常会使用一个数组来简历一张表，用于存放被分解成众多子问题的解。下边看一个菲波那切数列的例子：1.动态规划实例：计算菲波那切数列0,1,1,2,3,5,8,13,21,34,55，… 该序列是由前两个数值相加而成的。这是一个简单的递归函数。JavaScript代码：function recurFib(n) { if (n &lt; 2) { return n; } else { return recurFib(n-1) + recurFib(n-2); } }","text":"本文探讨两个高级主题：动态规划 和 贪心算法。【一】 动态规划动态规划被认为是一种与递归相反的技术，递归是从顶部开始将问题分解。1.使用递归解决问题虽然简洁，但是效率不高。包括JavaScript在内的众多语言，不能高效的将递归代码解析为机器代码，尽管写出来的代码简洁，但是执行效率低下。但并不是说使用递归是件坏事。2.本质上，只是那些指令式编程语言和面向对象的编程语言对递归的实现不够完善（它们没有将递归作为高级编程的特性）。3.许多使用递归去解决的编程问题，可以重写为使用动态规划的技巧去解决。动态规划方案通常会使用一个数组来简历一张表，用于存放被分解成众多子问题的解。下边看一个菲波那切数列的例子：1.动态规划实例：计算菲波那切数列0,1,1,2,3,5,8,13,21,34,55，… 该序列是由前两个数值相加而成的。这是一个简单的递归函数。JavaScript代码：function recurFib(n) { if (n &lt; 2) { return n; } else { return recurFib(n-1) + recurFib(n-2); } } 上边的算法，有太多值在递归调用中被重新计算。我们使用动态规划的技巧来设计效率更高的算法。function dynFib(n) { var val = []; for (var i = 0; i &lt;= n; ++i) { val[i] = 0; } if (n == 1 || n == 2) { return 1; } else { val[1] = 1; val[2] = 2; for (var i = 3; i &lt;= n; ++i) { val[i] = val[i-1] + val[i-2]; } return val[n-1]; } } 未完待续…","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://algate.coding.me/categories/数据结构与算法/"}],"tags":[{"name":"高级算法","slug":"高级算法","permalink":"https://algate.coding.me/tags/高级算法/"}]},{"title":"数据结构与算法 - 检索算法","slug":"数据结构与算法-检索算法","date":"2018-04-05T06:42:30.000Z","updated":"2019-02-27T03:27:59.664Z","comments":true,"path":"2018/04/05/数据结构与算法-检索算法/","link":"","permalink":"https://algate.coding.me/2018/04/05/数据结构与算法-检索算法/","excerpt":"在列表中查找数据有两种方式：顺序查找 和 二分查找。顺序查找适用于元素随机排列的列表；二分查找适用于元素已排序的列表；（二分查找效率更高，但是查找之前需要额外的时间对列表中的元素排序）【一】 顺序查找(又称为线性查找)从第一个元素开始查找，循环列表，逐个对比查找","text":"在列表中查找数据有两种方式：顺序查找 和 二分查找。顺序查找适用于元素随机排列的列表；二分查找适用于元素已排序的列表；（二分查找效率更高，但是查找之前需要额外的时间对列表中的元素排序）【一】 顺序查找(又称为线性查找)从第一个元素开始查找，循环列表，逐个对比查找function seqSearch(arr, data) { for (var i = 0; i &lt; arr.length; ++i) { if (arr[i] == data) { return true; } } return false; } &lt;!-- 返回索引 --&gt; function seqSearch(arr, data) { for (var i = 0; i &lt; arr.length; ++i) { if (arr[i] == data) { return i; } } return -1; } 需要注意的是这种方式，比内置的Array.indexof()方法慢。1.查找最大值和最小值function findMin(arr) { var min = arr[0]; for (var i = 1; i &lt; arr.length; ++i) { if (arr[i] &lt; min) { min = arr[i]; } } return min; } 2.使用自组织数据对数据的查找遵循“80-20原则”。[80-20原则：指对某一数据集执行的80%的查找操作都是对其中20%的数据元素进行查找。自组织的方式会把这20%的数据置于数据集的起始位置，这样便可以通过一个简单的顺序查找快速找到他们]；其实，类似这种“80-20原则”的概率分布被称为帕累托（Pareto）分布，他是有帕累托(Vilfredo Pareto)在19世纪末期研究收入和财富的分布时发现的。下面对正常的顺序查找加入自组织方式function seqSearch(arr, data) { for (var i = 0; i &lt; arr.length; ++i) { if (arr[i] == data) { if (i &gt; 0) { &lt;!-- swap(arr,i,i-1); --&gt; arr.swap(i,i-1); } return true; } } return false; } swap() 方法是对数组的数据进行调换的方法；Array.prototype.swap = function(index1, index2) { let temp = this[index1]; this[index1] = this[index2]; this[index2] = temp; return this; } 另外一种添加自组织数据的方法： 将找到的数据移动到数据集的其实位置，但是如果这个元素已经接近其实位置，则不会对它进行交换。我们只对距离数据集起始位置一定范围外的元素进行交换。我们只需要定义哪些是离数据集起始位置足够近的元素。再次参照“80-20原则”，我们确定原则：仅当数据位于数据集的前20%元素之外时，该数据才需要被重新移动到数据集的起始位置。function seqSearch(arr, data) { for (var i = 0; i &lt; arr.length; ++i) { if (arr[i] == data &amp;&amp; i &gt; (arr.length * 0.2)) { swap(arr,i,0); return true; } else if (arr[i] == data) { return true; } } return false; } 【二】 二分查找算法如果要查找的数据是有序的，二分查找算法比顺序查找算法更高效。举个简单的例子，我买了件衣服，朋友觉得不错，想知道衣服的价格，让朋友来猜衣服的价格。我告诉他结果，无非就三种情况出现，直接猜对了，猜大了，猜小了；将这个策略实现为二分查找算法，不过，这个算法只对有序的数据集有效。算法描述如下：(1)将数组的第一个位置设为下边界(2)将数组的最后一个元素所在的位置设置为上边界(数组的长度减一)(3)若下边界等于或小于上边界，做如下操作a.将中点位置设置为(上边界加下边界)除以2b.如果中点的元素小于查询的值，则将下边界设置为中点元素所在下标加1c.如果中点的元素大于查询的值，则将上边界设置为中点元素所在下边减1d.否则中点元素即为要查找的数据，可以进行返回function binSearch(arr, data) { var upperBound = arr.length-1; var lowerBound = 0; while (lowerBound &lt;= upperBound) { var mid = Math.floor((upperBound + lowerBound) / 2); if (arr[mid] &lt; data) { lowerBound = mid + 1; } else if (arr[mid] &gt; data) { upperBound = mid - 1; } else { return mid; } } return -1; } var nums = []; for (var i = 0; i &lt; 100; ++i) { nums[i] = Math.floor(Math.random() * 101); } insertionsort(nums); dispArr(nums); print(); putstr(&quot;Enter a value to search for: &quot;); var val = parseInt(readline()); var retVal = binSearch(nums, val); if (retVal &gt;= 0) { print(&quot;Found &quot; + val + &quot; at position &quot; + retVal); } else { print(val + &quot; is not in array.&quot;); } 计算重复次数(在二分查找的基础上，向上和向下查找相同的值)function count(arr, data) { var count = 0; var position = binSearch(arr, data); if (position &gt; -1) { ++count; for (var i = position-1; i &gt; 0; --i) { if (arr[i] == data) { ++count; } else { break; } } for (var i = position+1; i &lt; arr.length; ++i) { if (arr[i] == data) { ++count; } else { break; } } } return count; } 【三】 查找文本数据function binSearch(arr, data) { var upperBound = arr.length-1; var lowerBound = 0; while (lowerBound &lt;= upperBound) { var mid = Math.floor((upperBound + lowerBound) / 2); if (arr[mid] &lt; data) { lowerBound = mid + 1; } else if (arr[mid] &gt; data) { upperBound = mid - 1; } else { return mid; } } return -1; } function insertionsort(arr) { var temp, inner; for (var outer = 1; outer &lt;= arr.length-1; ++outer) { temp = arr[outer]; inner = outer; while (inner &gt; 0 &amp;&amp; (arr[inner-1] &gt;= temp)) { arr[inner] = arr[inner-1]; --inner; } arr[inner] = temp; } } var words = read(&quot;words.txt&quot;).split(&quot; &quot;); insertionsort(words); var word = &quot;rhetoric&quot;; var start = new Date().getTime(); var position = binSearch(words, word); var stop = new Date().getTime(); var elapsed = stop - start; if (position &gt;= 0) { print(&quot;Found &quot; + word + &quot; at position &quot; + position + &quot;.&quot;); print(&quot;Binary search took &quot; + elapsed + &quot; milliseconds.&quot;); } else { print(word + &quot; is not in the file.&quot;); } 文章结尾总结：在这个高速处理器的时代，除非面向大数据集，否则要测量顺序查找和二分查找耗时上的区别变得越来越困难。然而，处理大数据集时二分查找要比顺序查找速度快，这一观点在数学理论上已经得到证明。在决定算法性能的每一步循环嵌套中，二分查找减少了一半的查找量。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://algate.coding.me/categories/数据结构与算法/"}],"tags":[{"name":"检索算法","slug":"检索算法","permalink":"https://algate.coding.me/tags/检索算法/"}]},{"title":"JS-WebAssembly系列","slug":"JS-WebAssembly系列","date":"2018-04-01T06:02:30.000Z","updated":"2019-02-27T03:27:59.561Z","comments":true,"path":"2018/04/01/JS-WebAssembly系列/","link":"","permalink":"https://algate.coding.me/2018/04/01/JS-WebAssembly系列/","excerpt":"Google推出了Native Client，让开发者将一些C/C++代码打包集成到浏览器中，然而，只有Chrome支持这项技术，达不到广义上的可移植要求。几年前，Mozilla发布了asm.js，打开了性能优化的大门。他们最早提出了使用JS中的严格子集。通过限制语言的功能性，他们能够预测虚拟机的下一步反应，从而通过移除某些不必要的检查操作以提高性能。但这种技术也会影响语言的动态行为。所有的这些技术构成了今天WA诞生的基础。WebAssembly运行在JS虚拟机内部，使用了JS的部分功能，这意味着它不仅能够与运行最新Web浏览器的设备兼容，也能做到向前兼容。为了实现这一点，设计人员正在开发一个polyfill，核心思想是将每个函数转换为语义上等效的JS代码，虽然这样做会影响运行性能，但至少能解决代码的运行问题。","text":"Google推出了Native Client，让开发者将一些C/C++代码打包集成到浏览器中，然而，只有Chrome支持这项技术，达不到广义上的可移植要求。几年前，Mozilla发布了asm.js，打开了性能优化的大门。他们最早提出了使用JS中的严格子集。通过限制语言的功能性，他们能够预测虚拟机的下一步反应，从而通过移除某些不必要的检查操作以提高性能。但这种技术也会影响语言的动态行为。所有的这些技术构成了今天WA诞生的基础。WebAssembly运行在JS虚拟机内部，使用了JS的部分功能，这意味着它不仅能够与运行最新Web浏览器的设备兼容，也能做到向前兼容。为了实现这一点，设计人员正在开发一个polyfill，核心思想是将每个函数转换为语义上等效的JS代码，虽然这样做会影响运行性能，但至少能解决代码的运行问题。什么是WebAssemblyWebAssembly 是为 Web 而设计的、可以生成浏览器可执行的二进制文件的编程语言。并且于2017 年 2 月 28 日，四个主要的浏览器一致同意宣布 WebAssembly 的 MVP 版本已经完成，即将推出一个浏览器可以搭载的稳定版本。WebAssembly 的一个主要目标就是变快。本文将给出一些它如何变快的技术细节。当然，“快”是相对的概念。相比于JavaScript和其他动态语言，WebAssembly的快主要是因为它的静态类型特性和方便优化特性。WebAssembly 意在速度上能够达到和本地执行一样快，其实 asm.js 已经比较接近这一目标了，但是 WebAssembly 要进一步缩短和本地执行速度之间的差距。因此本文着重介绍为什么 WebAssembly 比 asm.js 更快。在开始介绍之前，先做一些说明：新的技术总是有一些还没来得及优化的情况，所以目前来说，并不是所有情况下 WebAssembly 都是最快的。本文主要表达的是 WebAssembly 为什么应该是更快的。对于它还不是那么快的一些情况，也是未来需要 fix 的问题。WebAssembly 比 JavaScript 执行更快是因为：文件抓取阶段，WebAssembly 比 JavaScript 抓取文件更快。即使 JavaScript 进行了压缩，WebAssembly 文件的体积也比 JavaScript 更小； 解析阶段，WebAssembly 的解码时间比 JavaScript 的解析时间更短； 编译和优化阶段，WebAssembly 更具优势，因为 WebAssembly 的代码更接近机器码，而 JavaScript 要先通过服务器端进行代码优化。 重优化阶段，WebAssembly 不会发生重优化现象。而 JS 引擎的优化假设则可能会发生“抛弃优化代码&lt;-&gt;重优化”现象。 执行阶段，WebAssembly 更快是因为开发人员不需要懂太多的编译器技巧，而这在 JavaScript 中是需要的。WebAssembly 代码也更适合生成机器执行效率更高的指令。 垃圾回收阶段，WebAssembly 垃圾回收都是手动控制的，效率比自动回收更高。 这就是为什么在大多数情况下，同一个任务 WebAssembly 比 JavaScript 表现更好的原因。但是，还有一些情况 WebAssembly 表现的会不如预期；同时 WebAssembly 的未来也会朝着使 WebAssembly 执行效率更高的方向发展。WebAssembly 的现在与未来2017 年 2 月 28 日，四个主要的浏览器一致同意宣布 WebAssembly 的MVP 版本已经完成，它是一个浏览器可以搭载的稳定版本。它提供了浏览器可以搭载的稳定核，这个核并没有包含 WebAssembly 组织所计划的所有特征，而是提供了可以使 WebAssembly 稳定运行的基本版本。这样一来开发者就可以使用 WebAssembly 代码了。对于旧版本的浏览器，开发者可以通过 asm.js 来向下兼容代码，asm.js 是 JavaScript 的一个子集，所有 JS 引擎都可以使用它。另外，通过 Emscripten 工具，你可以把你的应用编译成 WebAssembly 或者 asm.js。尽管是第一个版本，WebAssembly 已经能发挥出它的优势了，未来通过不断地改善和融入新特征，WebAssembly 会变的更快。提升浏览器中 WebAssembly 的性能随着各种浏览器都使自己的引擎支持 WebAssembly，速度提升就变成自然而然的了，目前各大浏览器厂商都在积极推动这件事情。JavaScript 和 WebAssembly 之间调用的中间函数目前，在 JS 中调用 WebAssembly 的速度比本应达到的速度要慢。这是因为中间需要做一次“蹦床运动”。JIT 没有办法直接处理 WebAssembly，所以 JIT 要先把 WebAssembly 函数发送到懂它的地方。这一过程是引擎中比较慢的地方。按理来讲，如果 JIT 知道如何直接处理 WebAssembly 函数，那么速度会有百倍的提升。如果你传递的是单一任务给 WebAssembly 模块，那么不用担心这个开销，因为只有一次转换，也会比较快。但是如果是频繁地从 WebAssembly 和 JavaScript 之间切换，那么这个开销就必须要考虑了。快速加载JIT 必须要在快速加载和快速执行之间做权衡。如果在编译和优化阶段花了大量的时间，那么执行的必然会很快，但是启动会比较慢。目前有大量的工作正在研究，如何使预编译时间和程序真正执行时间两者平衡。WebAssembly 不需要对变量类型做优化假设，所以引擎也不关心在运行时的变量类型。这就给效率的提升提供了更多的可能性，比如可以使编译和执行这两个过程并行。加之最新增加的 JavaScript API 允许 WebAssembly 的流编译，这就使得在字节流还在下载的时候就启动编译。FireFox 目前正在开发两个编译器系统。一个编译器先启动，对代码进行部分优化。在代码已经开始运行时，第二个编译器会在后台对代码进行全优化，当全优化过程完毕，就会将代码替换成全优化版本继续执行。添加后续特性到 WebAssembly 标准的过程WebAssembly 的发展是采用小步迭代的方式，边测试边开发，而不是预先设计好一切。这就意味着有很多功能还在襁褓之中，没有经过彻底思考以及实际验证。它们想要写进标准，还要通过所有的浏览器厂商的积极参与。这些特性叫做：未来特性。这里列出几个。直接操作 DOM目前 WebAssembly 没有任何方法可以与 DOM 直接交互。就是说你还不能通过比如element.innerHTML 的方法来更新节点。想要操作 DOM，必须要通过 JS。那么你就要在 WebAssembly 中调用 JavaScript 函数（WebAssembly 模块中，既可以引入 WebAssembly 函数，也可以引入 JavaScript 函数）。不管怎么样，都要通过 JS 来实现，这比直接访问 DOM 要慢得多，所以这是未来一定要解决的一个问题。共享内存的并发性提升代码执行速度的一个方法是使代码并行运行，不过有时也会适得其反，因为不同的线程在同步的时候可能会花费更多的时间。这时如果能够使不同的线程共享内存，那就能降低这种开销。实现这一功能 WebAssembly 将会使用 JavaScript 中的 SharedArrayBuffer，而这一功能的实现将会提高程序执行的效率。SIMD（单指令，多数据）如果你之前了解过 WebAssembly 相关的内容，你可能会听说过 SIMD，全称是：Single Instruction, Multiple Data（单指令，多数据），这是并行化的另一种方法。SIMD 在处理存放大量数据的数据结构有其独特的优势。比如存放了很多不同数据的 vector（容器），就可以用同一个指令同时对容器的不同部分做处理。这种方法会大幅提高复杂计算的效率，比如游戏或者 VR。这对于普通 web 应用开发者不是很重要，但是对于多媒体、游戏开发者非常关键。异常处理许多语言都仿照 C++ 式的异常处理，但是 WebAssembly 并没有包含异常处理。如果你用 Emscripten 编译代码，就知道它会模拟异常处理，但是这一过程非常之慢，慢到你都想用“DISABLEEXCEPTIONCATCHING” 标记把异常处理关掉。如果异常处理加入到了 WebAssembly，那就不用采用模拟的方式了。而异常处理对于开发者来讲又特别重要，所以这也是未来的一大功能点。其他改进——使开发者开发起来更简单一些未来特性不是针对性能的，而是使开发者开发 WebAssembly 更方便。一流的开发者工具。目前在浏览器中调试 WebAssembly 就像调试汇编一样，很少的开发者可以手动地把自己的源代码和汇编代码对应起来。我们在致力于开发出更加适合开发者调试源代码的工具。 垃圾回收。如果你能提前确定变量类型，那就可以把你的代码变成 WebAssembly，例如 TypeScript 代码就可以编译成 WebAssembly。但是现在的问题是 WebAssembly 没办法处理垃圾回收的问题，WebAssembly 中的内存操作都是手动的。所以 WebAssembly 会考虑提供方便的 GC 功能，以方便开发者使用。 ES6 模块集成。目前浏览器在逐渐支持用 script 标记来加载 JavaScript 模块。一旦这一功能被完美执行，那么像 &lt;script src=url type=&quot;module&quot;&gt; 这样的标记就可以运行了，这里的 url可以换成 WebAssembly 模块。 本文摘自知乎：WebAssembly系列（六）WebAssembly的现在与未来","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://algate.coding.me/categories/Javascript/"}],"tags":[{"name":"WebAssembly","slug":"WebAssembly","permalink":"https://algate.coding.me/tags/WebAssembly/"}]},{"title":"数据结构与算法 - 高级排序算法","slug":"数据结构与算法-高级排序算法","date":"2018-03-26T06:42:30.000Z","updated":"2019-02-27T03:27:59.667Z","comments":true,"path":"2018/03/26/数据结构与算法-高级排序算法/","link":"","permalink":"https://algate.coding.me/2018/03/26/数据结构与算法-高级排序算法/","excerpt":"【1】 高级排序算法1.希尔排序这个算法在插入排序的基础上做了很大的改善。希尔排序的核心理念与插入排序不同，它会首先比较距离较远的元素，而非相邻的元素。，用这个算法遍历数据集时，所有元素之间的距离会不断减小。工作原理：定义一个间隔序列来表示在排序过程中进行比较的元素之间有多远的间隔。有一些公开定义的间隔序列。（算法用到的间隔序列提前定义好）；function shellsort() { var dataStore = this; var gaps = [5, 3, 1]; for (var g = 0; g &lt; gaps.length; ++g) { for (var i = gaps[g]; i &lt; dataStore.length; ++i) { var temp = dataStore[i]; for (var j = i; j &gt;= gaps[g] &amp;&amp; dataStore[j-gaps[g]] &gt; temp; j -= gaps[g]) { dataStore[j] = dataStore[j - gaps[g]]; } dataStore[j] = temp; } } return this; } Array.prototype.shellsort = shellsort;","text":"【1】 高级排序算法1.希尔排序这个算法在插入排序的基础上做了很大的改善。希尔排序的核心理念与插入排序不同，它会首先比较距离较远的元素，而非相邻的元素。，用这个算法遍历数据集时，所有元素之间的距离会不断减小。工作原理：定义一个间隔序列来表示在排序过程中进行比较的元素之间有多远的间隔。有一些公开定义的间隔序列。（算法用到的间隔序列提前定义好）；function shellsort() { var dataStore = this; var gaps = [5, 3, 1]; for (var g = 0; g &lt; gaps.length; ++g) { for (var i = gaps[g]; i &lt; dataStore.length; ++i) { var temp = dataStore[i]; for (var j = i; j &gt;= gaps[g] &amp;&amp; dataStore[j-gaps[g]] &gt; temp; j -= gaps[g]) { dataStore[j] = dataStore[j - gaps[g]]; } dataStore[j] = temp; } } return this; } Array.prototype.shellsort = shellsort; 计算动态间隔序列var N = dataStore.length;var h = 1;while (h &lt; N/3) {h = 3*h +1;}动态计算间隔序列的希尔排序function shellsort1() { var dataStore = this; &lt;!-- 动态间隔序列 --&gt; var N = dataStore.length; var h = 1; while (h &lt; N/3) { h = 3 * h + 1; } while (h &gt;= 1) { for (var i = h; i &lt; N; i++) { for (var j = i; j &gt;= h &amp;&amp; dataStore[j] &lt; dataStore[j-h]; j -= h) { dataStore.swap(j, j-h); } } h = (h-1)/3; } } 2.归并排序把一系列排好序的子序列合并成一个大的完整的有序序列。1.自顶向下的归并排序，这种算法的递归深度对它来讲太深了。所以我们将使用一种非递归的方式来实现这个算法，即自底向上的归并排序；2.自底向上的归并排序。function mergeSort(arr) { if (arr.length &lt; 2) { return; } var step = 1; var left, right; while (step &lt; arr.length) { left = 0; right = step; while (right + step &lt;= arr.length) { mergeArrays(arr, left, left+step, right, right+step); left = right + step; right = left + step; } if (right &lt; arr.length) { mergeArrays(arr, left, left+step, right, arr.length); } step *= 2; } } function mergeArrays(arr, startLeft, stopLeft, startRight, stopRight) { var rightArr = new Array(stopRight - startRight + 1); var leftArr = new Array(stopLeft - startLeft + 1); k = startRight; for (var i = 0; i &lt; (rightArr.length-1); ++i) { rightArr[i] = arr[k]; ++k; } k = startLeft; for (var i = 0; i &lt; (leftArr.length-1); ++i) { leftArr[i] = arr[k]; ++k; } rightArr[rightArr.length-1] = Infinity; // a sentinel value leftArr[leftArr.length-1] = Infinity; // a sentinel value var m = 0; var n = 0; for (var k = startLeft; k &lt; stopRight; ++k) { if (leftArr[m] &lt;= rightArr[n]) { arr[k] = leftArr[m]; m++; } else { arr[k] = rightArr[n]; n++; } } print(&quot;left array - &quot;, leftArr); print(&quot;right array - &quot;, rightArr); } 3.快速排序处理大数据集最快的排序算法之一。是一种分而治之的算法，通过递归的方式将数据一次分解为包含较小元素和较大元素的不同子序列。首先要在列表中选择一个元素作为基准值，数据排序围绕基准值进行，将列表中小于基准值的的元素移到数组的底部，将大于基准值的元素移动到数组的底部。function qSort(arr) { if (arr.length == 0) { return []; } var left = []; var right = []; var pivot = arr[0]; for (var i = 1; i &lt; arr.length; i++) { if (arr[i] &lt; pivot) { left.push(arr[i]); } else { right.push(arr[i]); } } return qSort(left).concat(pivot, qSort(right)); } var a = []; for (var i = 0; i &lt; 10; ++i) { a[i] = Math.floor((Math.random()*100)+1); } print(a); print(qSort(a)); 需要知道的是：快速排序算法非常适用于大型数据集合；而在小数据集时性能反而会有所下降","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://algate.coding.me/categories/数据结构与算法/"}],"tags":[{"name":"高级排序算法","slug":"高级排序算法","permalink":"https://algate.coding.me/tags/高级排序算法/"}]},{"title":"Vue - 常见问题汇总","slug":"Vue-常见问题汇总","date":"2018-03-24T22:31:30.000Z","updated":"2019-02-27T05:16:44.850Z","comments":true,"path":"2018/03/25/Vue-常见问题汇总/","link":"","permalink":"https://algate.coding.me/2018/03/25/Vue-常见问题汇总/","excerpt":"1.class样式问题：&lt;span class=&quot;c_v_i_state&quot; :class=&quot;[video == &apos;1&apos;?&apos;bgcolor1aaf60&apos;:video == &apos;2&apos;?&apos;bgcolor2dabff&apos;:video == &apos;3&apos;?&apos;bgcolorff8b2d&apos;:&apos;&apos;]&quot;&gt;{{video == '1'?'正在直播':video == '2'?'即将开始':video == '3'?'直播回放':''}}&lt;/span&gt; 除了三元运算符，也可以用普通的方法实现：&lt;span class=&quot;c_v_i_state&quot; :class=&quot;{&apos;bgcolor1aaf60&apos;:video == &apos;1&apos;}&quot; v-if=&apos;video == 1&apos;&gt;正在直播&lt;/span&gt; &lt;span class=&quot;c_v_i_state&quot; :class=&quot;{&apos;bgcolor2dabff&apos;:video == &apos;2&apos;}&quot; v-if=&apos;video == 2&apos;&gt;即将开始&lt;/span&gt; &lt;span class=&quot;c_v_i_state&quot; :class=&quot;{&apos;bgcolorff8b2d&apos;:video == &apos;3&apos;}&quot; v-if=&apos;video == 3&apos;&gt;直播回放&lt;/span&gt;","text":"1.class样式问题：&lt;span class=&quot;c_v_i_state&quot; :class=&quot;[video == &apos;1&apos;?&apos;bgcolor1aaf60&apos;:video == &apos;2&apos;?&apos;bgcolor2dabff&apos;:video == &apos;3&apos;?&apos;bgcolorff8b2d&apos;:&apos;&apos;]&quot;&gt;{{video == '1'?'正在直播':video == '2'?'即将开始':video == '3'?'直播回放':''}}&lt;/span&gt; 除了三元运算符，也可以用普通的方法实现：&lt;span class=&quot;c_v_i_state&quot; :class=&quot;{&apos;bgcolor1aaf60&apos;:video == &apos;1&apos;}&quot; v-if=&apos;video == 1&apos;&gt;正在直播&lt;/span&gt; &lt;span class=&quot;c_v_i_state&quot; :class=&quot;{&apos;bgcolor2dabff&apos;:video == &apos;2&apos;}&quot; v-if=&apos;video == 2&apos;&gt;即将开始&lt;/span&gt; &lt;span class=&quot;c_v_i_state&quot; :class=&quot;{&apos;bgcolorff8b2d&apos;:video == &apos;3&apos;}&quot; v-if=&apos;video == 3&apos;&gt;直播回放&lt;/span&gt; 2.有关数据绑定的问题&lt;span class=&quot;c_digit&quot; v-for=&quot;num in num_visit_arr&quot; :key=&quot;num&quot;&gt;&lt;i :class=&quot;&apos;iconfont icon-shuzi&apos;+num&quot;&gt;&lt;/i&gt;&lt;/span&gt; :class=&quot;&#39;iconfont icon-shuzi&#39;+num&quot; 中，num是变量，iconfont icon-shuzi则是字符串。3.其他问题后续更新1代码片段解析","categories":[{"name":"Vue","slug":"Vue","permalink":"https://algate.coding.me/categories/Vue/"}],"tags":[{"name":"vue问题汇总","slug":"vue问题汇总","permalink":"https://algate.coding.me/tags/vue问题汇总/"}]},{"title":"数据结构与算法 - 排序算法","slug":"数据结构与算法-排序算法","date":"2018-03-20T04:31:30.000Z","updated":"2019-02-27T03:27:59.663Z","comments":true,"path":"2018/03/20/数据结构与算法-排序算法/","link":"","permalink":"https://algate.coding.me/2018/03/20/数据结构与算法-排序算法/","excerpt":"【1】 基本排序算法1.冒泡排序 (比较容易实现，但是是最慢的排序算法之一)数据像气泡一样从数组的一端漂浮到另一端。算法会多次在数组中移动，比较相邻的数据，当左侧值大于右侧值时将它们互换。里层循环是两个相互比较，把最大的值放到最右边。外层循环表示把最大值放到最右边的循环的次数，直到最后剩下两个比较；","text":"【1】 基本排序算法1.冒泡排序 (比较容易实现，但是是最慢的排序算法之一)数据像气泡一样从数组的一端漂浮到另一端。算法会多次在数组中移动，比较相邻的数据，当左侧值大于右侧值时将它们互换。里层循环是两个相互比较，把最大的值放到最右边。外层循环表示把最大值放到最右边的循环的次数，直到最后剩下两个比较；&lt;!-- 写到数组原型上可以直接调用 --&gt; function bubbleSort() { var dataStore = this; var numElements = dataStore.length; var temp; for (var outer = numElements; outer &gt;= 2; --outer) { for (var inner = 0; inner &lt;= outer-1; ++inner) { if (dataStore[inner] &gt; dataStore[inner+1]) { &lt;!-- swap(dataStore, inner, inner+1); --&gt; dataStore.swap(inner, inner+1); } } } return this; } Array.prototype.bubbleSort = bubbleSort; swap是一个交换数组的方法// 写到原型链上Array.prototype.swap = function(index1, index2) {let temp = this[index1];this[index1] = this[index2];this[index2] = temp;return this;}2.选择排序从数组的开头开始，将第一个元素和其他元素进行比较，检查完所有元素后，最小的元素会被放到元素的第一个位置，然后算法会从第二个位置继续第一个元素的操作。取出数组中的每一位，然后和剩下的元素比较，把最小的放到首位。&lt;!-- 写到数组原型上可以直接调用 --&gt; function selectionSort() { var dataStore = this; var min, temp; for (var outer = 0; outer &lt;= dataStore.length-2; ++outer) { min = outer; for (var inner = outer + 1;inner &lt;= dataStore.length-1; ++inner) { if (dataStore[inner] &lt; dataStore[min]) { min = inner; } } dataStore.swap(outer, min); } return this; } Array.prototype.selectionSort = selectionSort; 3.插入排序用一个很形象的例子来解说插入排序吧。 就好比一摞钱，里边1分，一角，一元，两元，五元，十元，五十，一百……等等，大小规格都一样，按照大小顺序排列。我们先拿出一张，再拿第二张，如果比第一张小，就放在它前面，如果比他大呢，就放在第一张的后边。再放第三张，第四张……以此类推。直至结束。&lt;!-- 写到数组原型上可以直接调用 --&gt; function insertionSort() { var dataStore = this; var temp, inner; for (var outer = 1; outer &lt;= dataStore.length-1; ++outer) { temp = dataStore[outer]; inner = outer; while (inner &gt; 0 &amp;&amp; (dataStore[inner-1] &gt;= temp)) { dataStore[inner] = dataStore[inner-1]; --inner; } dataStore[inner] = temp; } return this; } Array.prototype.insertionSort = insertionSort; 这三种基本排序算法，当处理的数据量小（100,1000）的时候，计时是差不多的，看不错区别的，但是当数据量达到10000甚至更多时就会出现计时不同的问题。对算法测试比较：对10000个元素冒泡排序消耗的时间为1096ms，选择排序消耗计时为591毫秒，插入排序消耗计时为471毫秒。下一章，高级排序算法。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://algate.coding.me/categories/数据结构与算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"https://algate.coding.me/tags/排序算法/"}]},{"title":"数据结构与算法 - 迭代器方法","slug":"数据结构与算法-迭代器方法","date":"2018-03-01T00:31:30.000Z","updated":"2019-02-27T03:27:59.665Z","comments":true,"path":"2018/03/01/数据结构与算法-迭代器方法/","link":"","permalink":"https://algate.coding.me/2018/03/01/数据结构与算法-迭代器方法/","excerpt":"【1】 第一组迭代器方法不产生任何新数组，要么对于数组中的每个元素执行某种操作，要么返回一个值；1.forEach() 接受一个函数作为参数，对数组中的每个元素使用该函数123456789function square(num) &#123; print(num, num * num);&#125;var nums = [];for (var i = 0; i &lt; 10; ++i) &#123; nums[i] = i+1;&#125;nums.forEach(square);","text":"【1】 第一组迭代器方法不产生任何新数组，要么对于数组中的每个元素执行某种操作，要么返回一个值；1.forEach() 接受一个函数作为参数，对数组中的每个元素使用该函数123456789function square(num) &#123; print(num, num * num);&#125;var nums = [];for (var i = 0; i &lt; 10; ++i) &#123; nums[i] = i+1;&#125;nums.forEach(square);2.every() 接受一个返回值为布尔类型的函数，对数组中的每个元素使用该函数。对于所有的元素，改函数返回true，则该方法返回true123456789101112function isEven(num) &#123; return num % 2 == 0;&#125;var nums = [2,4,6,8,10];var even = nums.every(isEven);if (even) &#123; print(&quot;all numbers are even&quot;);&#125;else &#123; print(&quot;some numbers are odd&quot;);&#125;some() 方法也接受一个返回值为布尔类型的函数，只要有一个元素使得该函数返回true，该方法就返回true。1234567891011121314151617181920function isEven(num) &#123; return num % 2 == 0;&#125;var nums = [1,2,3,4,5,6,7,8,9,10];var someEven = nums.some(isEven);if (someEven) &#123; print(&quot;some numbers are even&quot;);&#125;else &#123; print(&quot;no numbers are even&quot;);&#125;nums = [1,3,5,7,9];var someEven = nums.some(isEven);if (someEven) &#123; print(&quot;some numbers are even&quot;);&#125;else &#123; print(&quot;no numbers are even&quot;);&#125;3.reduce() 接受一个函数，返回一个值。 它会从一个累加值开始，不断对累加值和数组中的后续元素调用该函数，最后返回累加值。也可以用来将数组中的元素连接成一个长字符串reduceRight() 与 reduce()类似，是从右往左执行。【2】 生成新数组的迭代器方法1.map() 和forEach()有点儿像，对数组中的每个元素使用某个函数。区别就是，map()返回一个新的数组，该数组的元素是对原有元素应用某个函数得到的结果。123456function curve(grade) &#123; retuan grade += 5;&#125;var grades = [77, 65, 81, 92, 83];var newgrades = grade.map(curve);print(newgrades);2.filter() 和every类似，传入一个返回值为布尔类型的函数。和every()和some()不同的是，当对数组中的所有元素应用该函数，返回结果均为true时，该方法并不返回true，而是返回一个新的数组，该数组只包含原数组元素应用该函数后返回结果为true的元素。123456789101112131415161718function isEven(num) &#123; return num % 2 == 0;&#125;function isOdd(num) &#123; return num % 2 != 0;&#125;var nums = [];for (var i = 0; i &lt; 20; ++i) &#123; nums[i] = i+1;&#125;var evens = nums.filter(isEven);print(&quot;Even numbers: &quot;);print(evens);var odds = nums.filter(isOdd);print(&quot;Odd numbers: &quot;);print(odds);","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://algate.coding.me/categories/数据结构与算法/"}],"tags":[{"name":"迭代器方法","slug":"迭代器方法","permalink":"https://algate.coding.me/tags/迭代器方法/"}]},{"title":"Vue - 相关功能性组件","slug":"Vue-相关功能组件","date":"2018-03-01T00:31:30.000Z","updated":"2019-02-27T03:27:59.643Z","comments":true,"path":"2018/03/01/Vue-相关功能组件/","link":"","permalink":"https://algate.coding.me/2018/03/01/Vue-相关功能组件/","excerpt":"牛人总结vue组件库1.vue-stomp(地址自行search吧) 实现mqtt消息推送通知2.vue-video-player video播放器(基于videojs-关于flash-html5跟版本有关系)参考3.cropper.js 裁剪图片并上传(引入组件css样式有问题)中文翻译","text":"牛人总结vue组件库1.vue-stomp(地址自行search吧) 实现mqtt消息推送通知2.vue-video-player video播放器(基于videojs-关于flash-html5跟版本有关系)参考3.cropper.js 裁剪图片并上传(引入组件css样式有问题)中文翻译","categories":[{"name":"Vue","slug":"Vue","permalink":"https://algate.coding.me/categories/Vue/"}],"tags":[{"name":"vue组件","slug":"vue组件","permalink":"https://algate.coding.me/tags/vue组件/"}]},{"title":"upload导入表格图片等，显示进度条(axios实现)","slug":"Vue-upload导入表格图片以及显示进度条","date":"2018-02-26T09:31:30.000Z","updated":"2019-02-27T03:27:59.630Z","comments":true,"path":"2018/02/26/Vue-upload导入表格图片以及显示进度条/","link":"","permalink":"https://algate.coding.me/2018/02/26/Vue-upload导入表格图片以及显示进度条/","excerpt":"基础代码部分搭建：请访问另一篇博客 dialog弹层组件全面解析-实现思路一添加编辑数据(一个组件)，删除数据弹层里边包括多个弹层，不过大都雷同，这篇文章里补充弹层 user_import 子组件相关内容具体介绍导入和进度条相关内容：1.正式大型项目为了统一接口，单独把接口封装一个service","text":"基础代码部分搭建：请访问另一篇博客 dialog弹层组件全面解析-实现思路一添加编辑数据(一个组件)，删除数据弹层里边包括多个弹层，不过大都雷同，这篇文章里补充弹层 user_import 子组件相关内容具体介绍导入和进度条相关内容：1.正式大型项目为了统一接口，单独把接口封装一个serviceuploadServices.jsimport axios from &apos;axios&apos;; import { baseURL } from &apos;config/GlobalConfig&apos;; // axios请求带上cookie配置 axios.defaults.withCredentials = true; let uploadService = { uploadExcel (params, config) { return new Promise((resolve, reject) =&gt; { axios.post(baseURL + &apos;/uploadExcel&apos;, params, config).then((r) =&gt; { resolve(r); }).catch((r) =&gt; { console.log(r); }); }); } }; export { uploadService }; 子组件 user_import.vue&lt;template&gt; &lt;div class=&quot;c_dialog_box&quot;&gt; &lt;div class=&quot;c_dialog&quot;&gt; &lt;header class=&quot;c_dialog_header&quot;&gt; &lt;span&gt;导入数据&lt;/span&gt; &lt;i class=&quot;el-icon-close right&quot; @click=&quot;close&quot;&gt;&lt;/i&gt; &lt;/header&gt; &lt;section class=&quot;c_dialog_center&quot;&gt; &lt;div v-if=&quot;!flag.flag_progress&quot;&gt; &lt;p&gt;模板提供学生数据的导入，&lt;a href=&quot;&quot; download=&quot;数据模板&quot;&gt;下载导入模板&lt;/a&gt;&lt;/p&gt; &lt;el-button class=&quot;mt_20&quot; type=&quot;primary&quot; size=&quot;small&quot; onclick=&quot;chooseSeat.click()&quot;&gt;选择文件&lt;/el-button&gt; &lt;input id=&quot;chooseSeat&quot; name=&quot;files&quot; style=&quot;display:none;&quot; type=&quot;file&quot; @change=&quot;onFileSelect()&quot; accept=&quot;application/vnd.ms-excel&quot;/&gt; &lt;p class=&quot;mt_20&quot; v-if=&quot;files.name&quot;&gt;{{files.name}}&lt;/p&gt; &lt;/div&gt; &lt;div v-show=&quot;flag.flag_progress&quot;&gt; &lt;p&gt;准备导入&lt;/p&gt; &lt;progress id=&quot;uploadprogress&quot; class=&quot;mt_20 c_dialog_import_progress&quot; min=&quot;0&quot; max=&quot;100&quot; :value=&quot;progress&quot;&gt;&lt;/progress&gt; &lt;p class=&quot;mt_20&quot;&gt;导入进行到：{{progress}} %&lt;/p&gt; &lt;/div&gt; &lt;/section&gt; &lt;footer class=&quot;c_dialog_footer&quot;&gt; &lt;el-button type=&quot;info&quot; size=&quot;small&quot; plain @click=&quot;close&quot;&gt;取消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; size=&quot;small&quot; v-show=&quot;!flag.flag_progress&quot; @click=&quot;J_dialog_import&quot;&gt;开始导入&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; size=&quot;small&quot; v-show=&quot;flag.flag_progress&quot; @click=&quot;J_dialog_cancelimport&quot;&gt;取消导入&lt;/el-button&gt; &lt;/footer&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; 像开头那篇文章，引入相对应的组件，样式等关于axios的内容，不做过多解释直接找官网：github-axiosaxios-中文文档&lt;script&gt; import {uploadService} from &apos;services/upload.service&apos;; // import axios from &apos;axios&apos;; export default { data () { return { files: {}, curGrade: {}, flag: { flag_progress: false }, source: null, // 取消上传 progress: 0 }; }, methods: { close () { this.$emit(&apos;close&apos;); }, onFileSelect () { let oFiles = document.querySelector(&apos;#chooseSeat&apos;).files; // 多个文件或者单个文件 /* for (let i = 0; i &lt; oFiles.length; i++) { this.files.push(oFiles[i]); } */ this.files = oFiles[0]; console.log(this.files); }, startUpload () { let v = this; let formData = new FormData(); /* for (let i = 0; i &lt; this.files.length; i++) { let file = this.files[i]; formData.append(&apos;file&apos;, file); // 根据需要这里可能需要作出不同的修改：formData.append(file.name, file); } */ formData.append(&apos;file&apos;, v.files); formData.append(&apos;deptid&apos;, v.curGrade.id); console.log(formData); let cancelToken = axios.CancelToken; v.source = cancelToken.source(); let config = { onUploadProgress: function (progressEvent) { v.progress = Math.round(ProgressEvent.loaded * 100 / ProgressEvent.total); } }; uploadService.uploadExcel(formData, config).then(function(r) { console.log(r); }).catch((thrown) =&gt; { if (axios.isCancel(thrown)) { v.close(); console.log(&apos;取消上传操作成功&apos;); } else { console.log(&apos;取消上传操作失败&apos;); } }); }, J_dialog_import () { this.flag.flag_progress = true; this.startUpload(); }, J_dialog_cancelimport () { let that = this; if (that.source) { // 我先判断soucre是否存在，因为如果我打开弹框不作任何操作，点击取消按钮没有这一层判断的话，that.source.cancel(&apos;取消上传&apos;);会报错。 that.source.cancel(&apos;取消上传&apos;); // &quot;取消上传&quot;这几个字，会在上面catch（）的error中输出的，可以console看一下。 } that.flag.flag_progress = false; } } }; &lt;/script&gt; &lt;style lang=&quot;scss&quot;&gt; @import &quot;src/style/c_dialog&quot;; &lt;/style&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://algate.coding.me/categories/Vue/"}],"tags":[{"name":"progress","slug":"progress","permalink":"https://algate.coding.me/tags/progress/"},{"name":"upload","slug":"upload","permalink":"https://algate.coding.me/tags/upload/"}]},{"title":"那个从来不加班的年轻人，后来过得怎么样？","slug":"Extract-那个从来不加班的年轻人，后来过得怎么样？","date":"2018-02-22T09:30:30.000Z","updated":"2019-02-27T05:08:06.108Z","comments":true,"path":"2018/02/22/Extract-那个从来不加班的年轻人，后来过得怎么样？/","link":"","permalink":"https://algate.coding.me/2018/02/22/Extract-那个从来不加班的年轻人，后来过得怎么样？/","excerpt":"","text":"有个朋友，几年前辞掉了工作，自己创业，自从身份和角色转换了之后，经常听他念叨，老板难当。其实，我早给他打过预防针了。过去，老板和员工是纯粹的金钱关系，只要你有钱，总有人给你干活。可现如今，年轻人在择业的时候除了看工资，还得看看你这个公司的企业文化，说得直白点，不仅得赚钱，还得舒服地赚。这一点我深有体会，前年帮公司去做校园招聘的时候，一提起966的工作制，99%的人都掩饰不住惊讶和惋惜，公司再好，加班我不干。有人说，总有一天，你会知道，没有一份工作，值得8小时以上的工作。后来，公司为了招人，不得不改了制度，变成灵活工时，你想966，那就给加班费。你想965，你就休双休。这一改不要紧，很快就看出了人与人的差距。那个从来不加班的年轻人就拿我们部门去年新来的一个应届毕业生来说，妥妥地变成了老板的眼中钉。这个男孩名校毕业，能力超强，脑子活分，还特别会聊，同事们都喜欢他，每次听老板提起他，都是赞赏，我一直觉得他是个好苗子。可没想到，自从周六变成了休息日，你就再也别想找到人，无论提前多长时间通知他加班，都是一句，我家里有事。整个周末，办公室的人都忙成狗，他潇洒地去吃了大餐、看了电影，成了整个部门生活品质最高的人。结果可想而知，升职加薪是别想了，老板从不委以重任，各部门一提他就头大，所有的合作都默默地绕开他，最近一年多，公司的大项目不断，却没有一个和他有关。他经常问我，为什么大家都不重视他，好项目从来不带着他。我只能无可奈何地回答：因为每个项目都不能保证不加班。他不说话了。花样年华，谁愿意把大好青春埋没在格子间。可是，人生里，每一年的意义都不一样。30岁不是另一个20岁，头十年没做的事，后十年可能根本没机会弥补。看看身边那些三十多岁才焦虑的人，多半是二十几岁不努力。平凡如你我，没有雄厚的家底，没有杰出的天赋，唯一能拼的就是那么一点咬牙坚持和不懈努力，而这些常常需要更多的时间和精力。的确，有些加班是装模做样，但更多的人是真心诚意地想多学东西，承担更多的责任，给自己博一个出彩的未来。而那些年轻时只想好好生活的人，过着过着，生活就没了。没有一种成功来得容易不知道从什么时候开始，加班变成了人们口中的“奴性”。大家都说，加班是最无用的勤奋，它要么说明公司的人员配备不合理，要么说明你的能力欠费。如果是前者，你得赶紧走人。如果是后者，那只能说明你无能。于是，有人傻傻地听了，换了一家又一家公司，发现没有一个地方新人不用加班。年初，我辞职的时候，和前老板聊了很久职场生存之道。我从大学毕业就跟着他，到去年，整整八年。分别时，他给了一个让我特别骄傲的评语，过去这八年，够你用到退休了。是不是真的够，我不知道。但我在他的推荐下，找了一个从不加班又薪资丰厚的好工作。其实，这一点都是他教我的。他可能已经不记得了，我入职第一天，他跟我说的一句话：30岁前不拼命和30岁还在拼命的人，都是一样失败的。他就是这样，用10年的勤奋努力换来后半生的屹立不倒。行业里的人一提起他，无不竖起大拇指，再也没有人能让他加班，都是他挑谁来当客户。价格自然也水涨船高，每年不用拼死拼活地干，也能保持高品质的生活。公司的年轻人经常好奇地问，为什么老板每天打打球、喝喝茶，躺着都能赚钱。每到这时，老人们就会说，你不知道他过去有多苦。听他的老朋友说，过去他每天都是最后一个离开办公室的，别人吃饭聚餐的时候，他在办公室默默地翻过去的旧档案，电话24小时待命，加班加点总是他先上。年轻时没吃过苦的人，年老了多半会受罪。没有一种成功来得容易，你只是不知道那些优秀的人背后吃了多少苦而已。今天的苦日子都是为了明天的好日子，懂得这个道理需要点眼光和格局。只有极度认真工作才能扭转人生稻盛和夫曾经说：“只有极度认真工作，才能扭转人生。”他的人生就是这句话最好的印证。很多人都知道，今天的稻盛和夫是日本的“经营四圣”之一，27岁创办京瓷，52岁创办第二电信，这两家公司都成功闯入世界五百强。78岁接手垮掉的日航，一年反败为胜。可很少有人知道，他的第一份工作有多苦。大学毕业，他就来到了濒临倒闭的松风工业。发不出工资是家常便饭。一起入职的大学生，陆续有人离开，最后只剩下他一个人。但是，他却没走。稻盛和夫的回忆稻盛和夫后来这样回忆道：随着社会逐步西方化，日本人的劳动观发生了巨大的变化。许多日本人把劳动看作一项单纯的苦差事，甚至厌恶劳动，厌恶工作。我原本也不是一个热爱劳动的人，而且我曾经认为，在劳动中要遭受苦难的考验简直是不能接受的事。孩童时代，父母常用鹿儿岛方言教导我：“年轻时的苦难，出钱也该买。”我总是反驳说：“苦难？能卖了最好。”那时的我还是一个出言不逊的孩子。通过艰苦的劳动可以磨炼自己的人格，可以修身养性，这样的道德说教，同现在大多数年轻人一样，我也曾不屑一顾。但是，大学毕业的我，在京都一家濒临破产的企业——松风工业就职以后，年轻人的这种浅薄的想法就被现实彻底地粉碎了。松风工业是一家制造绝缘瓷瓶的企业，原是在日本行业内颇具代表性的优秀企业之一。但在我入社时早已面目全非，迟发工资是家常便饭，公司已经走到了濒临倒闭的边缘。业主家族内讧不断，劳资争议不绝。我去附近商店购物时，店主用同情的口吻对我说：“你怎么到这儿来了，待在那样的破企业，老婆也找不到啊！”因此，我们同期入社的人，一进公司就觉得“这样的公司令人生厌，我们应该有更好的去处”。大家聚到一块儿时就牢骚不断。当时正处于经济萧条时期，我也是靠恩师介绍才好不容易进了这家公司，本应心怀感激，情理上就更不该说公司的坏话了。然而，当时的我年少气盛，早把介绍人的恩义抛在一边，尽管自己对公司还没做出任何贡献，但牢骚怪话却比别人还多。入公司还不到一年，同期加入公司的大学生就相继辞职了，最后留在这家破公司的除了我之外，只剩一位九州天草出身的京都大学毕业的高才生。后来，他也离开了，报考了自卫队干部候补生学校。最后，只剩我一个人留在了这家破败的公司。我非常苦恼。但是，被逼到这一步，我反而清醒了。“要辞职离开公司，总得有一个义正词严的理由吧，只是因为感觉不满就辞职，那么今后的人生也未必就会一帆风顺吧。”当时，我还找不到一个必须辞职的充分理由，所以我决定：先埋头工作。不再发牢骚，不再说怪话，我把心思都集中到自己当前的本职工作中来，聚精会神，全力以赴。这时候我才开始发自内心并用格斗的气魄，以积极的态度认真面对自己的工作。从此以后，我工作的认真程度，真的可以用“极度”二字来形容。在这家公司里，我的任务是研究最尖端的新型陶瓷材料。我把锅碗瓢盆都搬进了实验室，睡在那里，昼夜不分，连一日三餐也顾不上吃，全身心地投入了研究工作。这种“极度认真”的工作状态，从旁人看来，真有一种悲壮的色彩。当然，因为是最尖端的研究，像拉马车的马匹一样，光用死劲是不够的。我订购了刊载有关新型陶瓷最新论文的美国专业杂志，一边翻辞典一边阅读，还到图书馆借阅专业书籍。我往往都是在下班后的夜间或休息日抓紧时间，如饥似渴地学习、钻研。在这样拼命努力的过程中，不可思议的事情发生了！大学时我的专业是有机化学，我只在毕业前为了求职，突击学了一点无机化学。可是当时，在我还是一个不到25岁的毛头小伙子的时候，我居然一次又一次取得了出色的科研成果，成为无机化学领域崭露头角的新星。这全都得益于我专心投入工作这个重要的决定。与此同时，进公司后要辞职的念头以及“自己的人生将会怎样”之类的迷惑和烦恼，都奇迹般地消失了。不仅如此，我甚至产生了“工作太有意思了，太有趣了，简直不知如何形容才好”这样的感觉。这时候，辛苦不再被当作辛苦，我更加努力地工作，周围人们对我的评价也越来越高。从此以后，不知不觉中，我的人生步入了良性循环。不久，我人生的第一次“大成功”就降临了——京瓷上市了。当时，我所持有的原始股还一股未抛，而发行新股所获的利润全部归公司所有。当时我还不到40岁，但我思考的是趁上市的机会“从今以后得更加努力地工作”。上市后，我不仅要继续为员工及其家属谋福利，还要为普通投资者的幸福做更多事。不仅不能休闲放松，我负的责任还将更大、更重。你必须非常努力才能在职场随心所欲稻盛和夫成功了，这个25岁不到的年轻人成功研制出顶尖的陶瓷材料，形容自己的工作时，他用了两个字：极致。可有几个人知道这两个字背后有多少不眠不休的日夜。稻盛和夫说，要想拥有一个充实的人生，你只有两种选择：从事自己喜欢的工作，或者，让自己喜欢上工作。可是，有几个年轻人大学一毕业就能做上自己喜欢的工作呢？可是，十年后，有人依旧在厌恶的工作中挣扎，有人却早已实现了财务自由。而拉开距离的正是那些谁都不喜欢的工作。曾经有个九零后姑娘问我，公司里所有人都讨厌加班，六点就纷纷往外走，每次有人见她不走，都冷嘲热讽，说她假装勤奋。可是，她真的想多学点东西，再把工作认真检查一遍。我告诉她一句话，努力从来不丢人。不想努力工作的人，永远觉得努力没用。他们总相信，人生有一条通向成功的捷径，却从来不相信，一个人必须非常努力，才能在职场随心所欲。混迹职场，有能力远远不够，你的工作态度才是真正的招牌。有能力没态度的人尚且不能幸存，更何况，年轻的时候，你懂得比别人少，做得比别人慢，还理直气壮地踩点下班，多一份力都不出，怎么可能不吃亏。我一直觉得，对年轻人来说，工作头几年是最好的升值期。那时候，学东西最快，犯错又最容易被原谅。唯一的代价就是你要多受点累。并不是所有加班都毫无价值，有些加班就是年轻人该吃的苦。讲真，这个世界上没有一份工作是不辛苦的。只不过那些成功了的人从来不向你诉苦。下班后的一小时，决定一个人的未来。你在办公室披荆斩棘，还是在家葛优瘫，过得就是不一样的人生。不要等到无路可走，才后悔自己没有拼尽全力。","categories":[{"name":"摘抄","slug":"摘抄","permalink":"https://algate.coding.me/categories/摘抄/"}],"tags":[{"name":"勉励","slug":"勉励","permalink":"https://algate.coding.me/tags/勉励/"}]},{"title":"Video自定义组件controls的实现","slug":"Video-controls组件自定义","date":"2018-02-02T09:31:30.000Z","updated":"2019-02-27T05:14:54.136Z","comments":true,"path":"2018/02/02/Video-controls组件自定义/","link":"","permalink":"https://algate.coding.me/2018/02/02/Video-controls组件自定义/","excerpt":"项目参考地址 video-contral-rewrite效果如下：","text":"项目参考地址 video-contral-rewrite效果如下：html12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Custom HTML5 Video Player&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;normalize.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;iconfont.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;container&quot; style=&quot;position: relative;background: #000; z-index: 0;overflow: hidden;font-size:0;&quot; tabindex=&quot;0&quot;&gt; &lt;div id=&quot;video_container&quot;&gt; &lt;video preload poster=&quot;&quot; style=&quot;width:100%;&quot;&gt; &lt;!-- &lt;source src=&quot;http://nettuts.s3.amazonaws.com/763_sammyJSIntro/trailer_test.mp4&quot; type=&quot;video/mp4&quot;&gt; --&gt; &lt;source src=&quot;/yingyong_720p.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;/video&gt; &lt;/div&gt; &lt;div id=&quot;videoControls&quot; class=&quot;player_control_bar skin_0 show&quot;&gt; &lt;div id=&quot;play&quot; class=&quot;player_control_bar_toggle player_control_bar_iconfont&quot;&gt;&lt;/div&gt; &lt;div id=&quot;progressText&quot; style=&quot;font-size: 14px;line-height: 40px;color:#fff;float:left;&quot;&gt;00:00&lt;/div&gt; &lt;div id=&quot;progress&quot; class=&quot;player_control_bar_progress&quot;&gt; &lt;div id=&quot;play_progress&quot; class=&quot;player_control_bar_progress_played&quot;&gt;&lt;/div&gt; &lt;div id=&quot;buffer_progress&quot; class=&quot;player_control_bar_progress_buffer&quot;&gt; &lt;!-- &lt;span&gt;&lt;/span&gt; --&gt; &lt;/div&gt; &lt;div id=&quot;progress_box&quot; class=&quot;player_control_bar_click player_control_bar_candrag&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;progress_line&quot; class=&quot;player_control_bar_hint&quot;&gt; &lt;div class=&quot;player_control_bar_picture&quot;&gt;&lt;/div&gt; &lt;div id=&quot;progress_line_time&quot; class=&quot;player_control_bar_hover_time&quot;&gt;01:01&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;audio-line&quot;&gt; &lt;div class=&quot;audio-line-head player_control_bar_iconfont&quot;&gt;&lt;/div&gt; &lt;span class=&quot;audio-line-bar&quot;&gt;&lt;span class=&quot;audio-line-bar-volume&quot;&gt;&lt;/span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div id=&quot;fullScreen&quot; title=&quot;FullScreen Toggle&quot; class=&quot;player_control_bar_fullscreen player_control_bar_iconfont&quot;&gt;&lt;/div&gt; &lt;!-- http://videojj.com --&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;player_control_bar_logo&quot; target=&quot;_blank&quot; style=&quot;color:#fff;font-size:24px;&quot;&gt;&lt;i class=&quot;icon-youtube2&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/videoplayer.js&quot;&gt;&lt;/script&gt;&lt;/html&gt;cssiconfont.css 为字体文件样式style.css 为自定义播放器控制条样式js12345678910111213141516var video = document.getElementsByTagName(&apos;video&apos;)[0], videoContainer = document.getElementById(&apos;video_container&apos;), videoControls = document.getElementById(&apos;videoControls&apos;), play = document.getElementById(&apos;play&apos;), progressContainer = document.getElementById(&quot;progress&quot;), progressHolder = document.getElementById(&quot;progress_box&quot;), playProgressBar = document.getElementById(&quot;play_progress&quot;), progressLine = document.getElementById(&quot;progress_line&quot;), progressLineTime = document.getElementById(&quot;progress_line_time&quot;), progressText = document.getElementById(&apos;progressText&apos;), bufferProgress = document.getElementById(&apos;buffer_progress&apos;), fullScreenToggleButton = document.getElementById(&quot;fullScreen&quot;), // Boolean that allows us to &quot;remember&quot; the current size of the video player. isVideoFullScreen = false, playProgressInterval = null, currentLineTime;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137var videoPlayer = &#123; init : function() &#123; // this is equal to the videoPlayer object. var that = this; this.addSource(); // Helpful CSS trigger for JS. document.documentElement.className = &apos;js&apos;; // Get rid of the default controls, because we&apos;ll use our own. video.removeAttribute(&apos;controls&apos;); // When meta data is ready, show the controls &lt;!-- video.addEventListener(&apos;loadeddata&apos;, this.initializeControls, false); --&gt; // 当浏览器正在下载指定的音频/视频时，会发生 progress 事件。 video.addEventListener(&apos;progress&apos;,this.videoBufferedProgress, false); // When play, pause buttons are pressed. // 当浏览器能够开始播放指定的音频/视频时，发生 canplay 事件 video.addEventListener(&apos;canplay&apos;,function()&#123; if(video.readyState == 4)&#123; bufferProgress.style.width = &quot;100%&quot;; &#125; else &#123; var curWidth = Number(bufferProgress.style.width.replace(&apos;%&apos;,&apos;&apos;)); (function addWidth()&#123; bufferProgress.style.width = (curWidth) + (i++) + &quot;%&quot;; if(Number(bufferProgress.style.width.replace(&apos;%&apos;,&apos;&apos;)) &gt;= 100)&#123; bufferProgress.style.width = &quot;100%&quot;; clearTimeout(allbufferProgressInterval); &#125;else&#123; var allbufferProgressInterval = setTimeout(addWidth, 50); &#125; &#125;)(i=1); &#125; &#125;,false); this.handleButtonPresses(); // When the full screen button is pressed... fullScreenToggleButton.addEventListener(&quot;click&quot;, function()&#123; isVideoFullScreen ? that.fullScreenOff() : that.fullScreenOn(); &#125;, true); this.videoScrubbing(); &#125;, videoBufferedProgress: function()&#123; if(video.buffered.length)&#123; var bufferPercent = video.buffered.end(0)/video.duration * 100; bufferProgress.style.width = bufferPercent + &apos;%&apos;; &#125; &#125;, handleButtonPresses : function() &#123; video.addEventListener(&apos;click&apos;, this.playPause, false); play.addEventListener(&apos;click&apos;, this.playPause, false); video.addEventListener(&apos;play&apos;, function() &#123; play.title = &apos;Pause&apos;; play.innerHTML = &apos;&apos;; // Begin tracking video&apos;s progress. videoPlayer.trackPlayProgress(); &#125;, false); video.addEventListener(&apos;pause&apos;, function() &#123; play.title = &apos;Play&apos;; play.innerHTML = &apos;&apos;; videoPlayer.stopTrackingPlayProgress(); &#125;, false); video.addEventListener(&apos;ended&apos;, function() &#123; this.currentTime = 0; this.pause(); &#125;, false); &#125;, playPause: function() &#123; if ( video.paused || video.ended ) &#123; if ( video.ended ) &#123; video.currentTime = 0; &#125; video.play(); &#125; else &#123; video.pause(); &#125; &#125;, fullScreenOn : function() &#123; isVideoFullScreen = true; video.style.cssText = &apos;background:#000;position: fixed; width:&apos; + window.innerWidth + &apos;px; height: &apos; + window.innerHeight + &apos;px;&apos;; video.className = &apos;fullsizeVideo&apos;; videoControls.style.cssText = &apos;position: fixed;&apos;; fullScreenToggleButton.classList.add(&quot;fs-active&quot;); fullScreenToggleButton.innerHTML = &apos;&apos;; console.log(fullScreenToggleButton.classList); console.log(&apos;full&apos;); document.addEventListener(&apos;keydown&apos;, this.checkKeyCode, false); &#125;, fullScreenOff : function() &#123; isVideoFullScreen = false; video.style.position = &apos;static&apos;; fullScreenToggleButton.classList.remove(&quot;fs-active&quot;); fullScreenToggleButton.innerHTML = &apos;&apos;; console.log(&apos;unfull&apos;) video.style.cssText = &apos;&apos;; videoControls.style.cssText = &apos;&apos;; &#125;, checkKeyCode : function( e ) &#123; e = e || window.event; if ( (e.keyCode || e.which) === 27 ) videoPlayer.fullScreenOff(); &#125;, // Every 50 milliseconds, update the play progress. trackPlayProgress : function()&#123; (function progressTrack() &#123; videoPlayer.updatePlayProgress(); playProgressInterval = setTimeout(progressTrack, 50); &#125;)(); &#125;, updatePlayProgress : function()&#123; playProgressBar.style.width = ( (video.currentTime / video.duration) * (progressHolder.offsetWidth) ) + &quot;px&quot;; progressText.innerHTML = videoPlayer.formatTime(video.currentTime).time2; &#125;, stopTrackingPlayProgress : function()&#123; clearTimeout( playProgressInterval ); &#125;, videoScrubbing : function() &#123; progressHolder.addEventListener(&apos;mouseenter&apos;, function()&#123; progressLine.style.display = &apos;block&apos;; document.onmousemove = function(e) &#123; videoPlayer.setPlayProgress( e.pageX ); &#125; &#125;,false); progressHolder.addEventListener(&apos;mouseleave&apos;, function(e)&#123; progressLine.style.display = &apos;none&apos;; document.onmousemove = null; &#125;,true); progressHolder.addEventListener(&apos;click&apos;,function(e)&#123; video.currentTime = currentLineTime; videoPlayer.updatePlayProgress(); video.play(); &#125;) &#125;, setPlayProgress : function( clickX ) &#123; progressLine.style.left = clickX - progressLine.offsetWidth/2 - videoControls.offsetLeft + &apos;px&apos;; var newPercent = (progressLine.offsetLeft - progressContainer.offsetLeft + progressLine.offsetWidth/2)/progressContainer.offsetWidth; currentLineTime = video.duration * newPercent; progressLineTime.innerHTML = videoPlayer.formatTime(currentLineTime).time2; &#125; // formatTime 格式化时间代码 &#125;; videoPlayer.init();","categories":[{"name":"Javascript插件","slug":"Javascript插件","permalink":"https://algate.coding.me/categories/Javascript插件/"}],"tags":[{"name":"video","slug":"video","permalink":"https://algate.coding.me/tags/video/"},{"name":"controls","slug":"controls","permalink":"https://algate.coding.me/tags/controls/"}]},{"title":"Atom 安装插件失败问题(安装源被墙)解决办法","slug":"Atom-安装插件失败","date":"2018-02-02T00:31:30.000Z","updated":"2019-02-27T03:27:59.519Z","comments":true,"path":"2018/02/02/Atom-安装插件失败/","link":"","permalink":"https://algate.coding.me/2018/02/02/Atom-安装插件失败/","excerpt":"我经常使用的工具是Sublime，偶尔会用到atom。","text":"我经常使用的工具是Sublime，偶尔会用到atom。有关sublime的完美配置请访问我写的关于sublime的配置的文章。sublime好处多多哦！Atom 从外观界面 和 插件支持来讲，是sublime的包裹版。但是启动还是没有sublime快速，没有sublime占用内存小。每次点击安装插件老师failed。我想肯定和安装的源有关系。那就解决安装源的问题吧。安装插件的方式无论是在界面通过 settings &gt;&gt; Install 还是 通过命令行方式安装，都是通过 apm 来下载安装的。而 apm 的安装源总是被墙。此时可以切换成淘宝源：在 C:\\Users\\用户名.atom 目录下，新建文件名为 .apmrc 的文本文件 ( 注意：不是 C:\\Users\\用户名.atom.apm 目录下的.apmrc 文件 )， 然后添加如下内容:registry=https://registry.npm.taobao.org/strict-ssl=false添加文件后，发现安装插件还是报错，那是因为 apm 最终还是走的 npm 源，所以还需要更改 npm 源。通过命令行：npm config set registry https://registry.npm.taobao.org最后通过 apm install --check // 检查安装环境运行结果要是为：Checking for native build tools done //表示可以顺利安装插件了！！！此刻就已经解决 Atom 安装插件被墙的问题了！！！","categories":[{"name":"Atom","slug":"Atom","permalink":"https://algate.coding.me/categories/Atom/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://algate.coding.me/tags/工具/"}]},{"title":"Media Source Extensions","slug":"Media Source Extensions","date":"2018-01-04T09:31:30.000Z","updated":"2019-02-27T03:27:59.586Z","comments":true,"path":"2018/01/04/Media Source Extensions/","link":"","permalink":"https://algate.coding.me/2018/01/04/Media Source Extensions/","excerpt":"Media Source Extensions API1. 前言媒体源扩展 API（MSE） 提供了实现无插件且基于 Web 的流媒体的功能。使用 MSE，媒体串流能够通过 JavaScript 创建，并且能通过使用 &lt;audio&gt; 和 &lt;video&gt; 元素进行播放。","text":"Media Source Extensions API1. 前言媒体源扩展 API（MSE） 提供了实现无插件且基于 Web 的流媒体的功能。使用 MSE，媒体串流能够通过 JavaScript 创建，并且能通过使用 &lt;audio&gt; 和 &lt;video&gt; 元素进行播放。我们已经可以在 Web 应用程序上无插件地播放视频和音频了。但是，现有架构过于简单，只能满足一次播放整个曲目的需要，无法实现拆分/合并数个缓冲文件。流媒体直到现在还在使用 Flash 进行服务，以及通过 RTMP 协议进行视频串流的 Flash 媒体服务器。MSE 使我们可以把通常的单个媒体文件的 src 值替换成引用 MediaSource 对象（一个包含即将播放的媒体文件的准备状态等信息的容器），以及引用多个 SourceBuffer 对象（代表多个组成整个串流的不同媒体块）的元素。MSE 让我们能够根据内容获取的大小和频率，或是内存占用详情（例如什么时候缓存被回收），进行更加精准地控制。 它是基于它可扩展的 API 建立自适应比特率流客户端（例如DASH 或 HLS 的客户端）的基础。在现代浏览器中创造能兼容 MSE 的媒体（assets）非常费时费力，还要消耗大量计算机资源和能源。此外，还须使用外部实用程序将内容转换成合适的格式。虽然浏览器支持兼容 MSE 的各种媒体容器，但采用 H.264 视频编码、AAC 音频编码和 MP4 容器的格式是非常常见的，且一定兼容。MSE 同时还提供了一个 API，用于运行时检测容器和编解码是否受支持。2. 媒体源扩展接口MediaSource代表了将由 HTMLMediaElement 对象播放的媒体资源。SourceBuffer代表了一个经由 MediaSource 对象被传入 HTMLMediaElement 的媒体块。SourceBufferList列出多个 SourceBuffer 对象的简单的容器列表。VideoPlaybackQuality包含了有关正被 &lt;video&gt; 元素播放的视频的质量信息，例如被丢弃或损坏的帧的数量。由 HTMLVideoElement.getVideoPlaybackQuality() 方法返回。TrackDefault为在媒体块的初始化段（initialization segments）中没有包含类型、标签和语言信息的轨道，提供一个包含这些信息的 SourceBuffer。TrackDefaultList列出多个 TrackDefault 对象的简单的容器列表。其他接口的扩展URL.createObjectURL()创建一个指向一个 MediaSource 对象的 URL。要求此 URL 可以被指定为一个用来播放媒体流的 HTML 媒体元素的 src 的值。HTMLMediaElement.seekable当一个 MediaSource 对象被 HTML 媒体元素播放时，此属性将返回一个包含用户能够在什么时间范围内进行调整的对象 TimeRanges。HTMLVideoElement.getVideoPlaybackQuality()针对正在播放的视频，返回一个 VideoPlaybackQuality 对象。AudioTrack.sourceBuffer, VideoTrack.sourceBuffer, TextTrack.sourceBuffer返回创建了相关轨道的 SourceBuffer。2-1.MediaSource是Media Source Extensions API 表示媒体资源HTMLMediaElement（HTML媒体元素接口在属性和方法中添加了 HTML元素来支持基础的媒体相关的能力，就像audio和video一样。HTML 视频元素和 HTML 音频元素元素都继承自此接口）对象的接口。MediaSource对象可以附着在HTMLMediaElement在客户端进行播放。属性：（从父接口EventTarget上继承而来）MediaSource.sourceBuffers 只读返回一个SourceBufferList 对象，包含了这个MediaSource的SourceBuffer的对象列表。MediaSource.activeSourceBuffers 只读Returns a SourceBufferList object containing a subset of the SourceBuffer objects contained within SourceBuffers — the list of objects providing the selected video track, enabled audio tracks, and shown/hidden text tracks.MediaSource.readyState 只读返回一个包含当前MediaSource状态的集合，即使它当前没有附着到一个media元素(closed)，或者已附着并准备接收SourceBuffer 对象 (open)，亦或者已附着但这个流已被MediaSource.endOfStream()关闭(ended.)MediaSource.durationGets and sets the duration of the current media being presented.方法 (Inherits properties from its parent interface, EventTarget)MediaSource.addSourceBuffer()创建一个带有给定MIME类型的新的 SourceBuffer 并添加到 MediaSource 的 SourceBuffers 列表。(SourceBuffer[MediaSource.addSourceBuffer()返回的] 和 SourceBuffers[MediaSource的属性(SourceBuffersList对象)] 是两个不同的概念)MediaSource.removeSourceBuffer()删除指定的SourceBuffer 从这个MediaSource对象中的 SourceBuffers列表。MediaSource.endOfStream()Signals the end of the stream.静态方法MediaSource.isTypeSupported()返回一个 Boolean 值表明给定的MIME类型是否被当前的浏览器——这意味着可以成功的创建这个MIME类型的SourceBuffer 对象。2-2.SourceBufferSourceBuffer 代表一个经由 MediaSource 对象被传入 HTMLMediaElement 的可播放媒体块。PropertiesSourceBuffer.modeControls how the order of media segments in the SourceBuffer is handled, in terms of whether they can be appended in any order, or they have to be kept in a strict sequence.SourceBuffer.updating 只读是否SourceBuffer目前正在更新，SourceBuffer.appendBuffer(),SourceBuffer.appendStream(),或SourceBuffer.remove()操作目前正在进度。SourceBuffer.buffered 只读返回目前SourceBuffer缓冲的时间范围。SourceBuffer.timestampOffsetControls the offset applied to timestamps inside media segments that are subsequently appended to the SourceBuffer.SourceBuffer.audioTracks 只读当前SourceBuffer包含的音轨列表.SourceBuffer.videoTracks 只读当前SourceBuffer包含的视频跟踪列表.SourceBuffer.textTracks 只读当前SourceBuffer包含的文本跟踪列表.SourceBuffer.appendWindowStart控制添加窗口开始的时间戳.这时间戳范围,可用于将过滤媒体数据附加到SourceBuffer上.在这个时间戳范围的媒体编码帧会被附加到SourceBuffer上，不在时间戳范围的不会被附加。SourceBuffer.appendWindowEnd控制添加窗口结束的时间戳SourceBuffer.trackDefaultsSpecifies the default values to use if kind, label, and/or language information is not available in the initialization segment of the media to be appended to the SourceBuffer.Event handlersSourceBuffer.onabortFired whenever SourceBuffer.appendBuffer() or SourceBuffer.appendStream() is ended by a call to SourceBuffer.abort(). SourceBuffer.updating changes from true to false.SourceBuffer.onerrorFired whenever an error occurs during SourceBuffer.appendBuffer() or SourceBuffer.appendStream(). SourceBuffer.updating changes from true to false.SourceBuffer.onupdateFired whenever SourceBuffer.appendBuffer() method or the SourceBuffer.remove() completes. SourceBuffer.updating changes from true to false. This event is fired before onupdateend.SourceBuffer.onupdateendFired whenever SourceBuffer.appendBuffer() method or the SourceBuffer.remove() has ended. This event is fired after onupdate.SourceBuffer.onupdatestartFired whenever the value of SourceBuffer.updating transitions from false to true.MethodsInherits methods from its parent interface, EventTarget.SourceBuffer.appendBuffer()Appends media segment data from an ArrayBuffer or ArrayBufferView object to the SourceBuffer.SourceBuffer.appendStream()Appends media segment data from a ReadableStream object to the SourceBuffer.SourceBuffer.abort()Aborts the current segment and resets the segment parser.SourceBuffer.remove()Removes media segments within a specific time range from the SourceBuffer.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://algate.coding.me/categories/Javascript/"}],"tags":[{"name":"MSE","slug":"MSE","permalink":"https://algate.coding.me/tags/MSE/"}]},{"title":"Meida视频加密五-实现原理","slug":"Media视频加密五-实现","date":"2018-01-02T07:31:30.000Z","updated":"2019-02-27T03:27:59.593Z","comments":true,"path":"2018/01/02/Media视频加密五-实现/","link":"","permalink":"https://algate.coding.me/2018/01/02/Media视频加密五-实现/","excerpt":"5.实现原理Blob() 构造函数var aBlob = new Blob( array, options );XMLHttpRequest.responseType 这是XHR返回响应的类型谁知道可以返回那些类型？XMLHttpRequest.responseType 属性是一个枚举值，返回响应的类型。它还允许作者将响应类型更改为一个”arraybuffer”, “blob”, “document”, “json”, 或 “text” 。如果将一个空字符串设置为responseType的值，则将其假定为类型“text”。","text":"5.实现原理Blob() 构造函数var aBlob = new Blob( array, options );XMLHttpRequest.responseType 这是XHR返回响应的类型谁知道可以返回那些类型？XMLHttpRequest.responseType 属性是一个枚举值，返回响应的类型。它还允许作者将响应类型更改为一个”arraybuffer”, “blob”, “document”, “json”, 或 “text” 。如果将一个空字符串设置为responseType的值，则将其假定为类型“text”。responseType支持以下几种值：ValueData type of response property“”DOMString (this is the default value)“arraybuffer”ArrayBuffer“blob”Blob“document”Document“json”JavaScript object, parsed from a JSON string returned by the server“text”DOMString“moz-blob”Used by Firefox to allow retrieving partial Blob data from progress events. This lets your progress event handler start processing data while it’s still being received.“moz-chunked-text”Similar to “text”, but is streaming. This means that the value in response is only available during dispatch of the “progress” event and only contains the data received since the last “progress” event. When response is accessed during a “progress” event it contains a string with the data. Otherwise it returns null.This mode currently only works in Firefox.“moz-chunked-arraybuffer”Similar to “arraybuffer”, but is streaming. This means that the value in response is only available during dispatch of the “progress” event and only contains the data received since the last “progress” event.When response is accessed during a “progress” event it contains a string with the data. Otherwise it returns null.This mode currently only works in Firefox.“ms-stream”Indicates that the response is part of a streaming download. It is supported only for download requests. This mode is available only in Internet Explorer.大家会看到返回的数据类型里有ArrayBuffer和blob。上代码：arraybufferhtml:&lt;video controls&gt;&lt;/video&gt; javascript:12345678910111213141516171819202122232425262728293031323334353637var video = document.querySelector(&apos;video&apos;);var assetURL = &apos;frag_bunny.mp4&apos;;var mimeCodec = &apos;video/mp4; codecs=&quot;avc1.42E01E, mp4a.40.2&quot;&apos;;if (&apos;MediaSource&apos; in window &amp;&amp; MediaSource.isTypeSupported(mimeCodec)) &#123; var mediaSource = new MediaSource; //console.log(mediaSource.readyState); // closed video.src = URL.createObjectURL(mediaSource); mediaSource.addEventListener(&apos;sourceopen&apos;, sourceOpen);&#125; else &#123; console.error(&apos;Unsupported MIME type or codec: &apos;, mimeCodec);&#125;function sourceOpen (_) &#123;//console.log(this.readyState); // openvar mediaSource = this;var sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);fetchAB(assetURL, function (buf) &#123; console.log(buf); sourceBuffer.addEventListener(&apos;updateend&apos;, function (_) &#123; mediaSource.endOfStream(); video.play(); //console.log(mediaSource.readyState); // ended &#125;); sourceBuffer.appendBuffer(buf); &#125;);&#125;;function fetchAB (url, cb) &#123; var xhr = new XMLHttpRequest; xhr.open(&apos;get&apos;, url); xhr.responseType = &apos;arraybuffer&apos;; xhr.onload = function () &#123; cb(xhr.response); &#125;; xhr.send();&#125;;blob1234567891011121314151617181920212223242526272829303132333435363738window.URL = window.URL || window.webkitURL;var assetURL = &apos;../yingyong_720p.mp4&apos;;var assetURL_2 = &apos;../yingyong_720p_2.mp4&apos;;var assetURL2 = &apos;../frag_bunny.mp4&apos;;var assetURL3 = &apos;../teacher.mp4&apos;;var assetURLnew = &apos;../HTML5_history.mp4&apos;;var xhr = new XMLHttpRequest;xhr.open(&apos;get&apos;, assetURLnew, true);xhr.responseType = &apos;blob&apos;;xhr.onload = function()&#123; console.log(this); if(this.status == 200 &amp;&amp; this.readyState == 4)&#123; var blob = this.response; console.log(blob); var reader = new FileReader(); reader.readAsArrayBuffer(blob); // reader.readAsBinaryString(blob); // reader.readAsDataURL(blob); // reader.readAsText(blob); reader.addEventListener(&quot;loadend&quot;, function() &#123; // reader.result 包含转化为类型数组的blob console.log(reader); var arrayBuffer = reader.result; var dataView = new DataView(arrayBuffer); // 字符串的编码方法是确定的 console.log(dataView); // 回归到了二进制语言，解析计算机语言 1 和 0 。只要你肯花功夫，我觉得你会成功的。 // var abc16str = String.fromCharCode.apply(null, new Uint16Array(dataView)); &#125;); video.onload = function(e)&#123; window.URL.revokeObjectURL(video.src); &#125; video.src =window.URL.createObjectURL(blob); &#125;&#125;xhr.send();如果遇到相关的问题，欢迎留言，如果时间允许，楼主会尽快回复！","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://algate.coding.me/categories/Javascript/"}],"tags":[{"name":"blob","slug":"blob","permalink":"https://algate.coding.me/tags/blob/"},{"name":"视频加密","slug":"视频加密","permalink":"https://algate.coding.me/tags/视频加密/"}]},{"title":"Meida视频加密四-ArrayBuffer","slug":"Media视频加密四-ArrayBuffer","date":"2018-01-02T04:31:30.000Z","updated":"2019-02-27T03:27:59.595Z","comments":true,"path":"2018/01/02/Media视频加密四-ArrayBuffer/","link":"","permalink":"https://algate.coding.me/2018/01/02/Media视频加密四-ArrayBuffer/","excerpt":"4.ArrayBufferBlob() 构造函数var aBlob = new Blob( array, options );array 是一个由ArrayBuffer, ArrayBufferView(TypedArray类型化数组的构造函数), Blob, DOMString 等对象构成的 Array，或者其他类似对象的混合体，它将会被放进Blob。DOMStrings会被编码为UTF-8。ArrayBuffer 对象用来表示通用的、固定长度的原始二进制数据缓冲区。ArrayBuffer 不能直接操作，而是要通过类型数组对象或 DataView 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。ArrayBuffer 对象用来表示通用的、固定长度的原始二进制数据缓冲区。ArrayBuffer 不能直接操作，而是要通过类型数组对象或 DataView 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。","text":"4.ArrayBufferBlob() 构造函数var aBlob = new Blob( array, options );array 是一个由ArrayBuffer, ArrayBufferView(TypedArray类型化数组的构造函数), Blob, DOMString 等对象构成的 Array，或者其他类似对象的混合体，它将会被放进Blob。DOMStrings会被编码为UTF-8。ArrayBuffer 对象用来表示通用的、固定长度的原始二进制数据缓冲区。ArrayBuffer 不能直接操作，而是要通过类型数组对象或 DataView 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。ArrayBuffer 对象用来表示通用的、固定长度的原始二进制数据缓冲区。ArrayBuffer 不能直接操作，而是要通过类型数组对象或 DataView 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。以现有数据获取ArrayBuffer从 Base64 字符串（一组相似的二进制到文本的编码规则，使得二进制数据在解释成radix-64的表现形式后能够用ASCII字符串的格式表示出来。Base64 这个词出自一种MIME数据传输编码。 ）从file文件(File)看到现在是不是凌乱了。我看了三遍！三遍！三遍！那就梳理下：（在文章中找相对应的内容）· ArrayBuffer对象· sourceBuffer.appendBuffer(ArrayBuffer);· sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);· var mediaSource = new MediaSource();MediaSource() 构造并且返回一个新的MediaSource的空对象（with no associated source buffers）· video.src = URL.createObjectURL(mediaSource);So，我们有了ArrayBuffer对象就ok了！接下来就是实现了：Media视频加密五-实现如果遇到相关的问题，欢迎留言，如果时间允许，楼主会尽快回复！","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://algate.coding.me/categories/Javascript/"}],"tags":[{"name":"blob","slug":"blob","permalink":"https://algate.coding.me/tags/blob/"},{"name":"视频加密","slug":"视频加密","permalink":"https://algate.coding.me/tags/视频加密/"}]},{"title":"Meida视频加密三-MediaSource","slug":"Media视频加密三-MediaSource","date":"2018-01-02T02:31:30.000Z","updated":"2019-02-27T03:27:59.591Z","comments":true,"path":"2018/01/02/Media视频加密三-MediaSource/","link":"","permalink":"https://algate.coding.me/2018/01/02/Media视频加密三-MediaSource/","excerpt":"3.MediaSourceMediaSource是Media Source Extensions API 表示媒体资源HTMLMediaElement对象的接口。MediaSource 对象可以附着在HTMLMediaElement在客户端进行播放。Media Source Extensions API是Media Source Extensions API 表示媒体资源HTMLMediaElement（HTML媒体元素接口在属性和方法中添加了 HTML元素来支持基础的媒体相关的能力，就像audio和video一样。HTML 视频元素和 HTML 音频元素元素都继承自此接口）对象的接口。MediaSource对象可以附着在HTMLMediaElement在客户端进行播放。详细资料请查看另一篇文章 Media Source Extensions下边内容是有这篇文章中提取到的部分内容。","text":"3.MediaSourceMediaSource是Media Source Extensions API 表示媒体资源HTMLMediaElement对象的接口。MediaSource 对象可以附着在HTMLMediaElement在客户端进行播放。Media Source Extensions API是Media Source Extensions API 表示媒体资源HTMLMediaElement（HTML媒体元素接口在属性和方法中添加了 HTML元素来支持基础的媒体相关的能力，就像audio和video一样。HTML 视频元素和 HTML 音频元素元素都继承自此接口）对象的接口。MediaSource对象可以附着在HTMLMediaElement在客户端进行播放。详细资料请查看另一篇文章 Media Source Extensions下边内容是有这篇文章中提取到的部分内容。video.src = URL.createObjectURL(mediaSource);URL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。构造函数MediaSource() 构造并且返回一个新的MediaSource的空对象（with no associated source buffers）。MediaSource.addSourceBuffer() 创建一个带有给定MIME类型的新的 SourceBuffer 并添加到 MediaSource 的 SourceBuffers 列表。SourceBufferSourceBuffer：代表了一个经由 MediaSource 对象被传入 HTMLMediaElement 的媒体块。MediaSource.addSourceBuffer()sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);SourceBuffer有许多的属性、方法、相关事件SourceBuffer.appendBuffer()Appends media segment data from an ArrayBuffer or ArrayBufferView object to the SourceBuffer.ArrayBuffer或者ArrayBufferView对象追加媒体分段数据到SourceBuffer上用法示例：sourceBuffer.appendBuffer(ArrayBuffer);ArrayBuffer又是什么玩意呢？欢迎进入Meida视频加密四-arraybuffer如果遇到相关的问题，欢迎留言，如果时间允许，楼主会尽快回复！","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://algate.coding.me/categories/Javascript/"}],"tags":[{"name":"blob","slug":"blob","permalink":"https://algate.coding.me/tags/blob/"},{"name":"视频加密","slug":"视频加密","permalink":"https://algate.coding.me/tags/视频加密/"}]},{"title":"Meida视频加密二-Blob对象","slug":"Media视频加密二-Blob对象","date":"2018-01-02T01:31:30.000Z","updated":"2019-02-27T03:27:59.592Z","comments":true,"path":"2018/01/02/Media视频加密二-Blob对象/","link":"","permalink":"https://algate.coding.me/2018/01/02/Media视频加密二-Blob对象/","excerpt":"2. blob1&lt;video src=&quot;blob:http://www.bilibili.com/d0823f0f-2b2a-4fd6-a93a-e4c82173c107&quot;&gt;&lt;/video&gt;a.什么是blob？Blob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。 文件(即File)接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。要从其他非blob对象和数据构造一个Blob，请使用 Blob() 构造函数。要创建包含另一个blob数据的子集blob，请使用 slice()方法。要获取用户文件系统上的文件对应的Blob对象，","text":"2. blob1&lt;video src=&quot;blob:http://www.bilibili.com/d0823f0f-2b2a-4fd6-a93a-e4c82173c107&quot;&gt;&lt;/video&gt;a.什么是blob？Blob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。 文件(即File)接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。要从其他非blob对象和数据构造一个Blob，请使用 Blob() 构造函数。要创建包含另一个blob数据的子集blob，请使用 slice()方法。要获取用户文件系统上的文件对应的Blob对象，File 对象是特殊类型的 Blob，且可以用在任意的 Blob 类型的 context 中。比如说， FileReader, URL.createObjectURL(), createImageBitmap(), 及 XMLHttpRequest.send() 都能处理 Blob 和 File。官方：接受Blob对象的API也被列在 File 文档中(下边有file相关内容的部分，继续浏览)。MDN-BlobBlob属性：Blob.size 只读 Blob 对象中所包含数据的大小（单位为字节）。 Blob.type 只读 一个字符串，表明该Blob对象所包含数据的MIME类型。如果类型无法确定，则返回空字符串。 语法：`var mimetype = instanceOfFile.type` b.如何创建BlobBlobBuilder 接口提供了另外一种创建Blob对象的方式:使用旧方法创建 Blob 对象。链接地址解释：使用 BlobBuilder 来创建一个Blob 实例，并且使用一个 append() 方法，将字符串（或者 ArrayBuffer 或者 Blob，此处用 string 举例）插入，一旦数据插入成功，就可以使用 getBlob() 方法设置一个 mime 。但该方式现在已经废弃，不应继续使用：1234var builder = new BlobBuilder();var fileParts = [&apos;&lt;a id=&quot;a&quot;&gt;&lt;b id=&quot;b&quot;&gt;hey!&lt;/b&gt;&lt;/a&gt;&apos;];builder.append(fileParts[0]);var myBlob = builder.getBlob(&apos;text/xml&apos;);Blob构造函数Blob() 构造函数返回一个新的 Blob 对象。 blob的内容由参数数组中给出的值的串联组成。Blob() 构造函数 允许用其它对象创建 Blob 对象。比如，用字符串构建一个 blob：语法： var aBlob = new Blob( array, options );参数：array 是一个由ArrayBuffer, ArrayBufferView(TypedArray类型化数组的构造函数), Blob, DOMString 等对象构成的 Array，或者其他类似对象的混合体，它将会被放进Blob。DOMStrings会被编码为UTF-8。ArrayBuffer 对象用来表示通用的、固定长度的原始二进制数据缓冲区。ArrayBuffer 不能直接操作，而是要通过类型数组对象或 DataView 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。ArrayBuffer 构造函数用来创建一个指定字节长度的 ArrayBuffer 对象。以现有数据获取 ArrayBuffer123456function b64EncodeUnicode(str) &#123; return btoa(encodeURIComponent(str).replace(/%([0-9A-F]&#123;2&#125;)/g, function(match, p1) &#123; return String.fromCharCode(&apos;0x&apos; + p1); &#125;));&#125;b64EncodeUnicode(&apos;✓ à la mode&apos;); // &quot;4pyTIMOgIGxhIG1vZGU=&quot;FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。其中File对象可以是来自用户在一个 &lt;input&gt; 元素上选择文件后返回的FileList对象,也可以来自拖放操作生成的 DataTransfer对象,还可以是来自在一个HTMLCanvasElement上执行mozGetAsFile()方法后返回结果。options 是一个可选的BlobPropertyBag字典，它可能会指定如下两个属性：type，默认值为 &quot;&quot;，它代表了将会被放入到blob中的数组内容的MIME类型。 endings，默认值为&quot;transparent&quot;，用于指定包含行结束符\\n的字符串如何被写入。 它是以下两个值中的一个： &quot;native&quot;，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 &quot;transparent&quot;，代表会保持blob中保存的结束符不变 12345var aFileParts = [&apos;&lt;a id=&quot;a&quot;&gt;&lt;b id=&quot;b&quot;&gt;hey!&lt;/b&gt;&lt;/a&gt;&apos;]; // 一个包含DOMString的数组var oMyBlob = new Blob(aFileParts, &#123;type : &apos;text/html&apos;&#125;); // 得到 blobvar debug = &#123;hello: &quot;world&quot;&#125;;var blob = new Blob([JSON.stringify(debug, null, 2)], &#123;type: &apos;application/json&apos;&#125;);File通常情况下， File 对象是来自用户在一个 &lt;input&gt; 元素上选择文件后返回的 FileList 对象,也可以是来自由拖放操作生成的 DataTransfer 对象，或者来自 HTMLCanvasElement 上的 mozGetAsFile() API。File 对象是特殊类型的 Blob，且可以用在任意的 Blob 类型的 context 中。比如说， FileReader, URL.createObjectURL(), createImageBitmap(), 及 XMLHttpRequest.send() 都能处理 Blob 和 File。URL.createObjectURL()使用 Blob 创建一个指向类型化数组的URL1234var blob = new Blob([typedArray], &#123;type: &quot;application/octet-binary&quot;&#125;);// 传入一个合适的MIME类型var url = URL.createObjectURL(blob);// 会产生一个类似blob:d3958f5c-0777-0845-9dcf-2cb28783acaf 这样的URL字符串// 你可以像使用一个普通URL那样使用它，比如用在img.src上。（MSE）从 Blob 中提取数据从Blob中读取内容的唯一方法是使用 FileReader。以下代码将 Blob 的内容作为类型数组读取：1234567var reader = new FileReader();// onabort、onerror、onload、onloadstart、onloadend、onprogressreader.addEventListener(&quot;loadend&quot;, function() &#123; // reader.result 包含转化为类型数组的blob // 文件的内容。该属性仅在读取操作完成后才有效，数据的格式取决于使用哪个方法来启动读取操作。&#125;);reader.readAsArrayBuffer(blob);简单说下 FileReader：属性：FileReader.error 只读一个DOMException，表示在读取文件时发生的错误 。FileReader.readyState 只读表示FileReader状态的数字。取值如下：常量名值描述EMPTY0还没有加载任何数据LOADING1数据正在被加载DONE2已完成全部的读取请求FileReader.result 只读文件的内容。该属性仅在读取操作完成后才有效，数据的格式取决于使用哪个方法来启动读取操作。方法：FileReader.abort()中止读取操作。在返回时，readyState属性为DONE。 FileReader.readAsArrayBuffer()开始读取指定的 Blob中的内容, 一旦完成, result 属性中保存的将是被读取文件的 ArrayBuffer 数据对象. FileReader.readAsBinaryString()开始读取指定的Blob中的内容。一旦完成，result属性中将包含所读取文件的原始二进制数据。 FileReader.readAsDataURL()开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容。 FileReader.readAsText()开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个字符串以表示所读取的文件内容。 参考文献：http://blog.csdn.net/oscar999/article/details/36373183/找到个比较通俗易懂的网址：Blob对象如果遇到相关的问题，欢迎留言，如果时间允许，楼主会尽快回复！","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://algate.coding.me/categories/Javascript/"}],"tags":[{"name":"blob","slug":"blob","permalink":"https://algate.coding.me/tags/blob/"},{"name":"视频加密","slug":"视频加密","permalink":"https://algate.coding.me/tags/视频加密/"}]},{"title":"Media视频加密一","slug":"Media视频加密一-前言","date":"2018-01-02T00:31:30.000Z","updated":"2019-02-27T03:27:59.589Z","comments":true,"path":"2018/01/02/Media视频加密一-前言/","link":"","permalink":"https://algate.coding.me/2018/01/02/Media视频加密一-前言/","excerpt":"1. 前言现在看到任何我感兴趣的网页都会习惯性的打开调试工具，看看其代码写的怎么样。 有一天，看到了这句 HTML。1&lt;video src=&quot;blob:http://www.bilibili.com/d0823f0f-2b2a-4fd6-a93a-e4c82173c107&quot;&gt;&lt;/video&gt;","text":"1. 前言现在看到任何我感兴趣的网页都会习惯性的打开调试工具，看看其代码写的怎么样。 有一天，看到了这句 HTML。1&lt;video src=&quot;blob:http://www.bilibili.com/d0823f0f-2b2a-4fd6-a93a-e4c82173c107&quot;&gt;&lt;/video&gt;再继续看看别的视频网站，你会发现：现在视频网站，A站，B站，爱奇艺，youku等网站看视频和直播，想下载视频的话，发现地址全变为blob开头的链接了。为何会有一个 blob？这个是什么？然后我点击这个链接，被返回了 404！什么情况？用了什么黑科技？一个个问题从脑海中蹦出来。本着学习和钻研的态度(好奇害死猫，处女座的强迫症患了)，于是对此做了一番探索。下片文章介绍blob Media视频加密二-Blob对象","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://algate.coding.me/categories/Javascript/"}],"tags":[{"name":"blob","slug":"blob","permalink":"https://algate.coding.me/tags/blob/"}]},{"title":"vue-知识点总结","slug":"Vue-知识点总结","date":"2017-12-25T09:31:30.000Z","updated":"2019-02-27T03:27:59.644Z","comments":true,"path":"2017/12/25/Vue-知识点总结/","link":"","permalink":"https://algate.coding.me/2017/12/25/Vue-知识点总结/","excerpt":"资源来自转载：前端大全公众号1.框架和库的区别框架（framework）：有着自己的语法特点、都有对应的各个模块。库（library）：专注于一点。框架的好处：","text":"资源来自转载：前端大全公众号1.框架和库的区别框架（framework）：有着自己的语法特点、都有对应的各个模块。库（library）：专注于一点。框架的好处：提到代码的质量，开发速度提高代码的复用率降低模块之间的耦合度（高内聚低耦合）UI：user interfaceGUI：graphical user interfaceCLI：command line interfaceAPI：application interface思维模式的转换：从操作DOM的思维模式 切换到以数据为主。2.Vue概述1、what是一个渐进式的构建用户界面的js框架2、where小到的简单的表单处理，大到复杂的数据操作比较频繁的单页面应用程序3、why方便阅读的中文文档容易上手 （学习曲线比较缓和）体积小基于组件化的开发方式代码的可读性、可维护性得到了提高4、how工作方式：可以通过丰富的指令扩展模板，可以通过各种各样的插件来增强功能搭建环境方式1全局安装 vue-cli$ npm install --global vue-cli 创建一个基于 webpack 模板的新项目$ vue init webpack my-project 安装依赖，走你$ cd my-project $ npm install $ npm run dev 方式2直接引入对应的js文件3.Vue中基础知识1、双花括号mustache(胡子)/interpolation（插值表达式）语法：&lt;any&gt;{{表达式}}&lt;/any&gt; 作用：将表达式执行的结果 输出当调用元素的innerHTML中；还可以将数据绑定到视图。2、指令-循环指令基本语法1：&lt;any v-for=&quot;tmp in array&quot;&gt;&lt;/any&gt; 基本语法2：&lt;any v-for=&quot;(value,index) in array&quot;&gt;&lt;/any&gt; 作用：在遍历array这个集合时，将临时变量保存在tmp中，创建多个any标签。3、指令-选择指令语法：&lt;any v-if=&quot;表达式&quot;&gt;&lt;/any&gt; &lt;any v-else-if=&quot;表达式&quot;&gt;&lt;/any&gt; &lt;any v-else=&quot;表达式&quot;&gt;&lt;/any&gt; 作用：根据表达式执行结果的真假，来决定是否要将当前的这个元素 挂载到DOM树4、指令-事件绑定语法：&lt;any v-on:eventName=&quot;handleEvent&quot;&gt;&lt;/any&gt; 作用：给指定的元素 将handleEvent的方法绑定给指定eventName事件。5、指令-属性绑定基本语法：&lt;any v-bind:myProp=&quot;表达式&quot;&gt;&lt;/any&gt; 补充，支持简写：&lt;any :myProp=&quot;表达式&quot;&gt;&lt;/any&gt; 作用：将表达式执行的结果绑定到当前元素的myProp属性。&lt;img v-bind:src=&quot;&apos;img/&apos;+myImg&quot; alt=&quot;&quot;&gt; 动态样式绑定：&lt;p :style=&quot;{backgroundColor:myBGColor}&quot;&gt; 动态样式绑定 &lt;/p&gt; 动态样式类绑定：&lt;h1 :class=&quot;{myRed:false}&quot;&gt; 动态样式类的绑定 &lt;/h1&gt; 6、指令-双向数据绑定方向1：数据绑定到视图方向2：将视图中（表单元素）用户操作的结果绑定到数据基本语法：&lt;表单元素 v-model=&quot;变量&quot;&gt;&lt;/表单元素&gt; 4.组件化组件：组件就是可被反复使用的，带有特定功能的视图。所谓的组件化，就像玩积木一样，把封装的组件进行复用,把积木（组件）拼接在一起，构成一个复杂的页面应用程序。组件树就是由各个组件构成的一种数据结构，它存在的意义是为了帮梳理应用程序。1、组件的创建全局组件：Vue.component(&apos;my-com&apos;,{template:`&lt;h2&gt;it is a header&lt;/h2&gt;`}) 局部组件：new Vue({components:{&apos;my-footer&apos;:{template:&apos;&apos;}}}) 2、组件使用作为普通的标签去使用&lt;my-com&gt;&lt;/my-com&gt; 3、注意事项组件的id和使用方式 遵循烤串式命名方式：a-b-c如果一个组件 要渲染多个元素，将多个元素放在一个顶层标签中，比如div、form全局组件可以用在id为example的范围内的任何一个组件内部，直接调用可以；但是局部组件只能在父模板中直接调用5.自定义指令创建：Vue.directive(&apos;change&apos;,{ bind:function(el,bindings){ //首次调用 }, update:function(el,bindings){ //只要是有数据变化，都会调用 }, unbind:function(){ //解绑 } }) 使用：&lt;any v-change=&quot;count&quot;&gt;&lt;/any&gt; 6.过滤器过滤器是针对一些数据 进行筛选、过滤、格式化等相关的处理，变成我们想要的数据。过滤器的本质 就是一个带有参数带有返回值的方法。Vue1. 支持内置的过滤器，但是Vue2. 就不再内置过滤器，但是支持自定义过滤器。1、过滤器的创建和使用1.创建Vue.filter(&apos;myFilter&apos;,function(myInput){ //myInput是在调用过滤器时，管道前表达式执行的结果 //针对myInput，按照业务需求做处理 //返回 return &apos;处理后的结果&apos; }) 2.使用&lt;any&gt;{{expression | myFilter}}&lt;/any&gt; 2、如何在调用过滤器时，完成参数的发送和接受1.发送&lt;any&gt;{{expression | myFilter(参数1，参数2)}}&lt;/any&gt; 2.接受Vue.filter(&apos;myFilter&apos;,function(myInput，参数1，参数2){ return &apos;处理后的结果&apos; }) 7.复合组件知识回顾：Vue.component(&apos;my-header&apos;,{template:`&lt;div&gt;&lt;/div&gt;`});&lt;my-header&gt;&lt;/my-header&gt; 复合组件：并不是新的概念，就是一个组件，只不过这个组件中 可以调用其他的组件。注意事项：1.组件要渲染的内容 取决于在定义组件时template&lt;my-list&gt; &lt;my-item&gt;&lt;/my-item&gt; &lt;/my-list&gt; 效果是出不来的。2.允许在一个组件中，直接来调用另外一个组件。8.生命周期四个阶段：create 准备工作 （数据的初始化。。。）mount 挂载前后针对元素进行操作update 数据发生变化，destroy 清理工作 (关闭定时器、集合清空..)beforeCreate/createdbeforeMount/mountedbeforeUpdate/updatedbeforeDestroy/destroyed9.常用属性1、watch1.表单元素的双向数据绑定v-model=&quot;myValue&quot; 2.监听watch:{ myValue:function(newValue,oldValue){} } 2、computed计算属于是用于在模板中，搞定复杂的业务逻辑，因为有依赖缓存。1.指定计算属性computed:{ myHandle:function(){ return 数据 } } 2.调用&lt;any&gt;{{myHandle}}&lt;/any&gt; 10.组件间通信1、父与子通信 （props down）1.发送&lt;son myName=&apos;zhangsan&apos;&gt;&lt;/son&gt; 2.接受到son组件：Vue.component(&apos;son&apos;,{props:[&apos;myName&apos;],template:`&lt;p&gt;{{myName}}&lt;/p&gt;`}) 2、子与父通信 (events up)1.绑定methods:{ handleEvent:function(msg){} } &lt;son @customEvent=&quot;handleEvent&quot;&gt;&lt;/son&gt; 2.触发-子组件内部：this.$emit(‘customEvent’,100); 3、ref(reference 引用/参考 外号)帮助在父组件中 得到子组件中的数据、方法。1.指定ref属性&lt;son ref=&quot;mySon&quot;&gt;&lt;/son&gt; 2.根据ref得到子组件实例this.$refs.mySon 4、$parentthis.$parent得到父组件的实例5、兄弟组件通信1.varbus = new Vue();2.接收方bus.$on(‘eventName’,function(msg){})3.发送方bus.$emit(&apos;eventName&apos;,123); 11.补充组件创建的方式1、直接在template属性中指定模板内容1.全局组件Vue.component 2.局部组件{components:{&apos;my-footer&apos;：{template:``}}} 2、.vue结尾的文件&lt;template&gt;&lt;/template&gt; &lt;script&gt;&lt;/script&gt; &lt;style&gt;&lt;/style&gt; 3、单独指定一个模板内容&lt;script id=&apos;myContent&apos; type=&apos;text/x-template&apos;&gt;&lt;/script&gt; Vue.component(&apos;&apos;,{ template:&apos;#myContent&apos; }) 12.路由模块路由模块的本质 就是建立起url和页面之间的映射关系。1、SPA的基本概念和工作原理SPA：single page application 单一页面应用程序，只有一个完整的页面；它在加载页面时，不会加载整个页面，而是只更新某个指定的容器中内容，比如Gmail、移动的webApp。工作原理：解析地址栏：完整的页面地址、路由地址根据路由地址从路由词典中找到真正的要加载的页面发起ajax请求：请求要加载的页面像指定的容器中插入加载来的页面2、路由模块的基本使用专业术语：router路由器route路由routes 路由数组（路由词典）1.引入 vue.js vue-router.js2.指定一个容器&lt;router-view&gt;&lt;/router-view&gt; 3.创建业务所需要用到的组件类var MyLogin = Vue.component() 4.配置路由词典const myRoutes = [ {path:&apos;&apos;,component:MyLogin}, {path:&apos;/login&apos;,component:MyLogin} ]; const myRouter = new VueRouter({ routes:myRoutes }) new Vue({ router:myRouter }) 5.测试修改地址栏中的路由地址，测试看加载的组件是否正确注意事项：1.先引入vue，再引入插件2.一定要指定router-view3.route路由 {path:’’,component:}routes：路由数组 []router：路由器，按照指定的路由规则去访问对应的组件 new VueRouter3、使用路由模块来实现页面跳转的方式方式1：直接修改地址栏方式2：this.$router.push(‘路由地址’); 方式3：&lt;router-link to=&quot;路由地址&quot;&gt;&lt;/router-link&gt; 4、完成参数的传递在页面之间跳转的时候，在有些场景下，需要同时指定参数1.明确发送方和接收方list -- 20--&gt; detail 2.配置接收方的路由地址/detail --&gt; /detail/:index this.$route.params.index 3.发送routerLink to=&quot;/detail/20&quot; this.$router.push(&apos;/detail/20&apos;) 5、路由嵌套在一个路由中，path对应一个component，如果这个component需要根据不同的url再加载其他的component，称之为路由的嵌套举例：比如A组件现在需要根据不同的url，加载B组件或者C组件1.给A组件指定一个容器2.配置路由词典{ path:&apos;/a&apos;, component:A, children:[ {path:&apos;/b&apos;,component:B} ] } 需求：现在有两个组件，分别是login/mail,建立SPA。在此基础上，希望mail组件 嵌套inbox/outbox/draft补充：在设置子路由，路由匹配规则依然是适用的，只不过路由地址为空和异常，要携带父组件的路由地址/mail /mail/draft13.搭建基于CLI开发环境的方式1.指定一个文件夹： C:\\xampp\\htdocs\\framework\\vue\\project2.将tpls.zip拷贝到project中3.右键单击压缩包，解压缩到当前文件夹4.进入到tpls5.同时按下shift和鼠标右键，选择在此位置打开命令行串口6.执行npm install7.执行npm starthttps://www.hazyzh.com/b/180211145458作者：楷楷","categories":[{"name":"Vue","slug":"Vue","permalink":"https://algate.coding.me/categories/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://algate.coding.me/tags/vue/"}]},{"title":"Angular - 新建项目问题汇总","slug":"Angular4-新建项目问题汇总","date":"2017-12-06T00:31:30.000Z","updated":"2019-02-27T04:33:37.529Z","comments":true,"path":"2017/12/06/Angular4-新建项目问题汇总/","link":"","permalink":"https://algate.coding.me/2017/12/06/Angular4-新建项目问题汇总/","excerpt":"修改几个个地方（陆续记录），看起来不起眼，其实很重要的。我也是花了很长时间调试才出来的；1.angular-cli 引入 scss修改配置信息：","text":"修改几个个地方（陆续记录），看起来不起眼，其实很重要的。我也是花了很长时间调试才出来的；1.angular-cli 引入 scss修改配置信息：2.如下图所示：（导入bootstrap和jquery）3.更改angular端口号这里需要注意：按照网上的教程需要更改“node_modules/angular-cli/lib/config/schema.json”此路径下文件的内容，如图：而我的路径在但是，更改默认的端口号之后，页面，项目报错，一直未找到问题原因","categories":[{"name":"Angular","slug":"Angular","permalink":"https://algate.coding.me/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://algate.coding.me/tags/Angular/"}]},{"title":"react不归路-react-hot-loader","slug":"React不归路-react-hot-loader","date":"2017-11-06T10:31:30.000Z","updated":"2019-02-27T03:27:59.608Z","comments":true,"path":"2017/11/06/React不归路-react-hot-loader/","link":"","permalink":"https://algate.coding.me/2017/11/06/React不归路-react-hot-loader/","excerpt":"官网原话：React Hot Loader is a plugin for Webpack that allows instantaneous live refresh without losing state while editing React components.","text":"官网原话：React Hot Loader is a plugin for Webpack that allows instantaneous live refresh without losing state while editing React components.有人会问 webpack-dev-server 已经是热加载了，能做到只要代码修改了页面也自动更新了，为什么在 react 项目还要安装 react-hot-loader 呢？其实这两者的更新是有区别的，webpack-dev-server 的热加载是开发人员修改了代码，代码经过打包，重新刷新了整个页面。而 react-hot-loader 不会刷新整个页面，它只替换了修改的代码，做到了页面的局部刷新。简单的讲，就是使用 react 编写代码时，能让修改的部分自动刷新。但这和自动刷新网页是不同的，因为 hot-loader 并不会刷新网页，而仅仅是替换你修改的部分，也就是上面所说的 without losing state。下面来说说怎么来配置 react-hot-loader 。我是通过官方的create-react-app创建的项目的修改步骤1：// 安装 react-hot-loadernpm install –save-dev react-hot-loader步骤2：在 webpack.config.dev.js 的 entry 值里加上 react-hot-loader/patch，一定要写在entry 的最前面，如果有 babel-polyfill 就写在babel-polyfill 的后面。123456entry: [ // We ship a few polyfills by default: require.resolve(&apos;./polyfills&apos;), // add react-hot-loaders by algate require.resolve(&apos;react-hot-loader/patch&apos;),]网上好多人都没有写require.resolve()，直接把上述代码放进去也ok哦步骤3：最后这个操作就是在页面的主入口，比如我的是 index.js 添加些代码123456789101112131415import App from &apos;./page/App&apos;;import &#123; AppContainer &#125; from &apos;react-hot-loader&apos;; // 新添加const render = (App) =&gt; &#123; ReactDOM.render( &lt;AppContainer&gt;&lt;App /&gt;&lt;/AppContainer&gt;, document.getElementById(&apos;root&apos;) );&#125;render(App)// Hot Module Replacement APIif (module.hot) &#123; module.hot.accept(&apos;./page/App&apos;, () =&gt; &#123; render(App) &#125;)&#125;大功告成，去页面实践下吧！","categories":[{"name":"React","slug":"React","permalink":"https://algate.coding.me/categories/React/"}],"tags":[{"name":"react-hot-loader","slug":"react-hot-loader","permalink":"https://algate.coding.me/tags/react-hot-loader/"}]},{"title":"react不归路-module的使用","slug":"React不归路-使用组件module","date":"2017-11-06T09:31:30.000Z","updated":"2019-02-27T03:27:59.613Z","comments":true,"path":"2017/11/06/React不归路-使用组件module/","link":"","permalink":"https://algate.coding.me/2017/11/06/React不归路-使用组件module/","excerpt":"1，react中文官方文档 连接地址2，reduxRedux 是 JavaScript 状态容器，提供可预测化的状态管理。Redux 除了和 React 一起用外，还支持其它界面库。它体小精悍（只有2kB）且没有任何依赖。","text":"1，react中文官方文档 连接地址2，reduxRedux 是 JavaScript 状态容器，提供可预测化的状态管理。Redux 除了和 React 一起用外，还支持其它界面库。它体小精悍（只有2kB）且没有任何依赖。安装稳定版：npm install --save redux 多数情况下，你还需要使用 React 绑定库和开发者工具。npm install --save react-redux npm install --save-dev redux-devtools 应用中所有的 state 都以一个对象树的形式储存在一个单一的 store 中。惟一改变 state 的办法是触发 action，一个描述发生什么的对象。为了描述 action 如何改变 state 树，你需要编写 reducers。就是这样！import { createStore } from ‘redux’;这是一个 reducer，形式为 (state, action) =&gt; state 的纯函数。描述了 action 如何把 state 转变成下一个 state。state 的形式取决于你，可以是基本类型、数组、对象、甚至是 Immutable.js 生成的数据结构。惟一的要点是当 state 变化时需要返回全新的对象，而不是修改传入的参数。下面例子使用 switch 语句和字符串来做判断，但你可以写帮助类(helper)根据不同的约定（如方法映射）来判断，只要适用你的项目即可。123456789101112131415161718192021222324252627function counter(state = 0, action) &#123; switch (action.type) &#123; case &apos;INCREMENT&apos;: return state + 1; case &apos;DECREMENT&apos;: return state - 1; default: return state; &#125;&#125;// 创建 Redux store 来存放应用的状态。// API 是 &#123; subscribe, dispatch, getState &#125;。let store = createStore(counter);// 可以手动订阅更新，也可以事件绑定到视图层。store.subscribe(() =&gt; console.log(store.getState()));// 改变内部 state 惟一方法是 dispatch 一个 action。// action 可以被序列化，用日记记录和储存下来，后期还可以以回放的方式执行store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;);// 1store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;);// 2store.dispatch(&#123; type: &apos;DECREMENT&apos; &#125;);3.redux-thunk理解redux和redux的中间件redux-thunk的认识","categories":[{"name":"React","slug":"React","permalink":"https://algate.coding.me/categories/React/"}],"tags":[{"name":"react-module","slug":"react-module","permalink":"https://algate.coding.me/tags/react-module/"}]},{"title":"React-creat-app创建失败","slug":"React-项目创建失败","date":"2017-11-05T10:31:30.000Z","updated":"2019-02-27T05:12:14.195Z","comments":true,"path":"2017/11/05/React-项目创建失败/","link":"","permalink":"https://algate.coding.me/2017/11/05/React-项目创建失败/","excerpt":"执行命令 create-react-app命令：","text":"执行命令 create-react-app命令：但是执行了好久，安装了好久，当你以为成功的时候。不好意思，他不仅罢工了，连之前话很长时间安装的都delete了，delete，delete了。。。。不说了，要不，你乖乖的改改安装的源吧，因为他默认调用的npm命令。查看npm源的命令：npm config get registry 设置方法：npm config set registry https://registry.npm.taobao.org &gt;配置后可通过上面get registry来获取信息","categories":[{"name":"React","slug":"React","permalink":"https://algate.coding.me/categories/React/"}],"tags":[{"name":"react-webpack-app","slug":"react-webpack-app","permalink":"https://algate.coding.me/tags/react-webpack-app/"}]},{"title":"React-webpack-app脚手架构建项目一","slug":"React-webpack-app脚手架构建项目","date":"2017-11-05T09:31:30.000Z","updated":"2019-02-27T03:27:59.599Z","comments":true,"path":"2017/11/05/React-webpack-app脚手架构建项目/","link":"","permalink":"https://algate.coding.me/2017/11/05/React-webpack-app脚手架构建项目/","excerpt":"1. 首先，建立项目目录，npm init 初始化 npm 项目mkdir react-start cd react-start npm init 2. 全局安装 Webpack, Babel, Webpack-dev-servernpm install babel webpack webpack-dev-server -g","text":"1. 首先，建立项目目录，npm init 初始化 npm 项目mkdir react-start cd react-start npm init 2. 全局安装 Webpack, Babel, Webpack-dev-servernpm install babel webpack webpack-dev-server -g 3. 安装 react, react-domnpm install react react-dom --save 4. 安装 Babel 转换器，需要用到插件 babel-preset-react, babel-preset-latest，latest 即最新的 ES 规范，包括了 Async/Await 这些新特性。npm install babel-loader babel-core babel-preset-react babel-preset-latest --save 5. 创建项目文件，main.js 即项目入口文件，App.js 即 React 组件主文件不会命令行的，老老实实的到文件夹右击吧： index.html App.js main.js webpack.config.jstype . &gt;index.html6. Webpack 配置123456789101112131415161718192021222324var path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;./main.js&apos;, // 入口文件路径 output: &#123; path: path.resolve(__dirname, &apos;&apos;), filename: &apos;index.js&apos; &#125;, devServer: &#123; inline: true, port: 3333 &#125;, module: &#123; loaders: [ &#123; test: /\\.js$/, // babel 转换为兼容性的 js exclude: /node_modules/, loader: &apos;babel-loader&apos;, query: &#123; presets: [&apos;react&apos;, &apos;latest&apos;] &#125; &#125; ] &#125;&#125;7. 其他文件内容，一些基本的 React 和 ES6 基础，不做过多讲解了。index.html1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;React Start&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;App.js12345678910import React from &apos;react&apos;;class App extends React.Component &#123; render() &#123; return &lt;div&gt;Hello World&lt;/div&gt; &#125;&#125;export default Appmain.js12345import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import App from &apos;./App&apos;;ReactDOM.render(&lt;App /&gt;, document.getElementById(&apos;app&apos;))8. 配置 npm scripts, 编辑 package.json123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack-dev-server&quot;&#125;,9. 基本的框架搭建完毕，npm start 然后打开 http://localhost:3333 试试npm start","categories":[{"name":"React","slug":"React","permalink":"https://algate.coding.me/categories/React/"}],"tags":[{"name":"react-webpack-app","slug":"react-webpack-app","permalink":"https://algate.coding.me/tags/react-webpack-app/"}]},{"title":"React-初次见面之泥坑深谭","slug":"React-初次见面之泥坑深谭","date":"2017-11-01T09:31:30.000Z","updated":"2019-02-27T05:12:01.059Z","comments":true,"path":"2017/11/01/React-初次见面之泥坑深谭/","link":"","permalink":"https://algate.coding.me/2017/11/01/React-初次见面之泥坑深谭/","excerpt":"1.刚创建完项目的package.json文件如下","text":"1.刚创建完项目的package.json文件如下生成项目后，脚手架为了“优雅”… …隐藏了所有的webpack相关的配置文件，此时查看“”项目名称“”文件夹目录，会发现找不到任何webpack配置文件。执行以下命令：1cnpm run eject执行完毕后，显示如下：项目文件夹下会多出config和scripts的文件夹，里边是关于webpack的配置文件2.修改默认port想要更改默认create-react-app的port（默认3000），只需要在前边打开配置文件的基础上（否则找不到scripts文件夹），找到start.js 找到const DEFAULT_PORT = parseInt(process.env.PORT, 10) || 3000；更改3000为你想要的端口号就行了。","categories":[{"name":"React","slug":"React","permalink":"https://algate.coding.me/categories/React/"}],"tags":[{"name":"react","slug":"react","permalink":"https://algate.coding.me/tags/react/"}]},{"title":"vue学习-子组件传值","slug":"Vue-子组件传父组件","date":"2017-10-08T09:31:30.000Z","updated":"2019-02-27T03:27:59.633Z","comments":true,"path":"2017/10/08/Vue-子组件传父组件/","link":"","permalink":"https://algate.coding.me/2017/10/08/Vue-子组件传父组件/","excerpt":"构建项目在这里不做介绍 , 直接上关于组件传递数据的代码吧我在这里做的是一个关于弹层的删除操作例子(弹层是自己写的一个组件，没有用elementUI、iView等框架)实现弹层的显示隐藏有很多种方法。后续我会写成文档添加到blog，欢迎关注！父组件html:1234567// 点击按钮触发事件操作 this.flag.flag_dialog_delete = true;// 组件dialogDel上@close=&quot;close&quot;,你们知道哪个是子组件的close，哪个是父组件的close么？// 不凡自己试试，如果不知道答案欢迎评论，我做正确回答&lt;div v-show=&quot;flag.flag_dialog_delete&quot;&gt; &lt;dialogDel @close=&quot;close&quot;&gt;&lt;/dialogDel&gt;&lt;/div&gt;","text":"构建项目在这里不做介绍 , 直接上关于组件传递数据的代码吧我在这里做的是一个关于弹层的删除操作例子(弹层是自己写的一个组件，没有用elementUI、iView等框架)实现弹层的显示隐藏有很多种方法。后续我会写成文档添加到blog，欢迎关注！父组件html:1234567// 点击按钮触发事件操作 this.flag.flag_dialog_delete = true;// 组件dialogDel上@close=&quot;close&quot;,你们知道哪个是子组件的close，哪个是父组件的close么？// 不凡自己试试，如果不知道答案欢迎评论，我做正确回答&lt;div v-show=&quot;flag.flag_dialog_delete&quot;&gt; &lt;dialogDel @close=&quot;close&quot;&gt;&lt;/dialogDel&gt;&lt;/div&gt;Js:123456789101112131415// 子组件添加进父组件import dialogDel from &apos;./user_dialog/user_delete&apos;;components: &#123; dialogDel&#125;data () &#123; return &#123; flag: &#123; flag_dialog_delete: false &#125; &#125;&#125;子组件html：1&lt;i class=&quot;el-icon-close right&quot; @click=&quot;close&quot;&gt;&lt;/i&gt;js1234// method: 对象里添加方法如下 (上题中的哪个close？)close () &#123; this.$emit(&apos;close&apos;);&#125;父组件Js：123456// 处理子组件emit到父组件的事件// method: 对象里添加方法如下 (上题中的哪个close？)close () &#123; this.flag.flag_dialog_delete = false;&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://algate.coding.me/categories/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://algate.coding.me/tags/vue/"},{"name":"$emit","slug":"emit","permalink":"https://algate.coding.me/tags/emit/"}]},{"title":"Push到github时，频繁输入用户名和密码","slug":"Git-Push到github时-频繁输入用户名和密码的问题","date":"2017-09-26T09:31:30.000Z","updated":"2019-02-27T05:20:24.344Z","comments":true,"path":"2017/09/26/Git-Push到github时-频繁输入用户名和密码的问题/","link":"","permalink":"https://algate.coding.me/2017/09/26/Git-Push到github时-频繁输入用户名和密码的问题/","excerpt":"问题此问题之前没有出现的，直到最近一次，项目需要，增加了项目SSH密钥之后，就出现了title中的问题。尴了个尬 原因原因是使用了https方式 push这种方式产生的原因，一般是我们clone是一定是使用了http的方式例如我们在github上创建了一个项目，然后我们clone到本地时使用了http/https而非git1git clone https://github.com/***/***.git","text":"问题此问题之前没有出现的，直到最近一次，项目需要，增加了项目SSH密钥之后，就出现了title中的问题。尴了个尬 原因原因是使用了https方式 push这种方式产生的原因，一般是我们clone是一定是使用了http的方式例如我们在github上创建了一个项目，然后我们clone到本地时使用了http/https而非git1git clone https://github.com/***/***.git解决方法1git remote -v输出项目的克隆地址origin https://github.com/……/..hexo.git (fetch) origin https://github.com/……/..hexo.git (push) 移出旧的http的origin1git remote rm origin添加新的git方式的origin1git remote add origin git@github.com:***/***.git我们在查看一下push方式输入第一条命令 git remote -v 得到了新的git方式，然后push试下是否还需要输入繁琐的用户名和密码大功告成！如果遇到相关的问题，欢迎留言，如果时间允许，楼主会尽快回复！","categories":[{"name":"Git","slug":"Git","permalink":"https://algate.coding.me/categories/Git/"}],"tags":[{"name":"github","slug":"github","permalink":"https://algate.coding.me/tags/github/"}]},{"title":"一台电脑如何管理多个平台SSH KEY","slug":"Git-一台电脑如何管理多个平台SSH KEY","date":"2017-09-25T09:31:30.000Z","updated":"2019-02-27T05:20:09.768Z","comments":true,"path":"2017/09/25/Git-一台电脑如何管理多个平台SSH KEY/","link":"","permalink":"https://algate.coding.me/2017/09/25/Git-一台电脑如何管理多个平台SSH KEY/","excerpt":"多平台多个git-SSH密钥，对于我们开发人员来说非常有必要，你要玩转github，coding，gitlib，gerrit，还有你提交代码在公司和别处还得用公司邮箱和XX邮箱区分开，如果你玩过github，恰好你们公司也用git，你是不是还被提交的署名邮箱玩坏了，这里统统都不要，配置全搞定。一台电脑上（Mac os）管理多个平台使用ssh key，可以任意切换，达到多用户（账号）使用不同ssh提交代码。以下利用 gerrit 和 github 账号来做例子。1、生成ssh key1ssh-keygen -t rsa -C &quot;youremail@yourcompany.com&quot;","text":"多平台多个git-SSH密钥，对于我们开发人员来说非常有必要，你要玩转github，coding，gitlib，gerrit，还有你提交代码在公司和别处还得用公司邮箱和XX邮箱区分开，如果你玩过github，恰好你们公司也用git，你是不是还被提交的署名邮箱玩坏了，这里统统都不要，配置全搞定。一台电脑上（Mac os）管理多个平台使用ssh key，可以任意切换，达到多用户（账号）使用不同ssh提交代码。以下利用 gerrit 和 github 账号来做例子。1、生成ssh key1ssh-keygen -t rsa -C &quot;youremail@yourcompany.com&quot;如果出现 &#39;ssh-keygen&#39;不是内部或外部命令 如何处理呢？在此建议大家下载最新版，跟上时代的步伐，是没有错的.a.找到Git/usr/bin目录下的ssh-keygen.exe(如果找不到，可以在计算机全局搜索)b.属性–&gt;高级系统设置–&gt;环境变量–&gt;系统变量,找到Path变量，进行编辑，End到最后，输入分号，粘贴复制的ssh-keygen所在的路径，保存；重新cmd，执行ssh-keygen,成功！若一路回车（密码可以不写），这样只会在~/.ssh/ 目录下生成 id_rsa 和 id_rsa.pub 两个文件。为了区分，我们在第一个回车后设置路径：如图所示：1Enter file in which to save the key (/root/.ssh/id_rsa):~/.ssh/gerrit_rsa之后回车完成就会出现上图中效果，github也如此。2.服务器端绑定相对应的公钥，这个步骤使必须的，以github为例：(如图所示就OK了)测试是否通了：(github为例)123ssh -T git@github.com// 回车You&apos;ve successfully authenticated说明就可以git 命令去除繁琐的乱七八糟的输入了！完善配置config在.ssh文件夹下创建config文件，（如果没有此文件，可以打开终端，输入 touch config 生成此文件）可以用 touch config 或者 nano config 创建和编辑编辑Coding：1234567891011121314# gerritHost IP HostName IP PreferredAuthentications publickey Port 66666 # 如果项目代码地址有端口号需要配置相对应的字段 IdentityFile ~/.ssh/id_rsa_gerrit user git# githubHost github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github user git4.以此类推，有再多的平台，我也不怕了，妈妈再也不用当心我的东西乱七八糟找不到了5.可能会遇到算法的问题在config文件中加入：12Host *.*.*.*KexAlgorithms +diffie-hellman-group1-sha16.两个平台是否可以用一个rsa密钥呢。ok，不凡试试。我先拭去了……我试过了可以成功，就是说，我coding的密钥也可以用github的密钥来上传，user一样只需要配置下config就OK了，无非就是多加入一个coding的配置参考内容: https://coding.net/help/doc/git/ssh-key.html如果遇到相关的问题，欢迎留言，如果时间允许，楼主会尽快回复！","categories":[{"name":"Git","slug":"Git","permalink":"https://algate.coding.me/categories/Git/"}],"tags":[{"name":"Git-SSH","slug":"Git-SSH","permalink":"https://algate.coding.me/tags/Git-SSH/"}]},{"title":"webpack-require.context()之route去中心化管理","slug":"webpack-require.context之route去中心化管理","date":"2017-08-20T09:31:30.000Z","updated":"2019-02-27T03:27:59.658Z","comments":true,"path":"2017/08/20/webpack-require.context之route去中心化管理/","link":"","permalink":"https://algate.coding.me/2017/08/20/webpack-require.context之route去中心化管理/","excerpt":"需求：当我vue-routes配置的时候，嫌弃require(‘’)引入的路径太长，想用变量替换他，为了美观，也没了精简代码。当你在开发一个大型单页面应用的时候，项目之初一般做法是所有的路由规则都维护在一个route.js的文件里。","text":"需求：当我vue-routes配置的时候，嫌弃require(‘’)引入的路径太长，想用变量替换他，为了美观，也没了精简代码。当你在开发一个大型单页面应用的时候，项目之初一般做法是所有的路由规则都维护在一个route.js的文件里。123456789101112131415161718192021222324252627282930const router = new VueRouter(&#123; routes: routes&#125;)// routes.jsconst routes = &#123; path: &apos;usermanage&apos;, component: require(&apos;page/systemManagement/usermanage/usermanage.vue&apos;), children: [ &#123; path: &apos;student_manage&apos;, component: r =&gt; require.ensure([], () =&gt; r(require(&apos;page/systemManagement/usermanage/usermanage.student_manage.vue&apos;))) &#125;, &#123; path: &apos;user_audit&apos;, component: r =&gt; require.ensure([], () =&gt; r(require(&apos;page/systemManagement/usermanage/usermanage.user_audit.vue&apos;))) &#125;, &#123; path: &apos;role_permission&apos;, component: r =&gt; require.ensure([], () =&gt; r(require(&apos;page/systemManagement/usermanage/usermanage.role_permission.vue&apos;))) &#125;, &#123; path: &apos;role_assign&apos;, component: r =&gt; require.ensure([], () =&gt; r(require(&apos;page/systemManagement/usermanage/usermanage.role_assign.vue&apos;))) &#125;, &#123; path: &apos;class_manage&apos;, component: r =&gt; require.ensure([], () =&gt; r(require(&apos;page/systemManagement/usermanage/usermanage.class_manage.vue&apos;))) &#125; ]&#125;;这里的require.ensure上一篇文章 webpack.ensure介绍了：webpack的语法，实现按需加载的。随着业务代码的增长路由很快边长，看起来乱糟糟(怪我强迫症患了)：刚开始发现路径太长，用一个变量替换，还用es6语法:const user_path = `page/systemManagement/usermanage/`; 上边的component改为了:`component：r=&gt;(require(`${user_path}usermanage.vue`))` 报错了，刚开始以为是es6语法写错了，改成字符串的写法，还是报错，我就觉得这不应该了，一个念头飘过，require不支持变量的写法，baidu，google…… oh，小样，果然如此，node不支持，不过也发现了另外一个好东西，require.context。简单说下context()的用法：官网地址require的context方法你还可以使用 require.context() 方法来创建自己的上下文（模块）。你可以给这个方法传3个参数：要搜索的文件夹目录，是否还应该搜索它的子目录，一个匹配文件的正则表达式。webpack会在构建的时候解析代码中的 require.context() 。语法如下：require.context(directory, useSubdirectories = false, regExp = /^\\.\\//) 示例:require.context(&quot;./test&quot;, false, /\\.test\\.js$/); // （你创建了）一个test文件夹下面（不包含子目录），能被require请求到，所有文件名以 `.test.js` 结尾的文件形成的上下文（模块）。 require.context(&quot;../&quot;, true, /\\.stories\\.js$/); // （你创建了）一个父级文件夹下面（包含子目录），所有文件名以 `.stories.js` 结尾的文件形成的上下文（模块）。 上下文模块 API一个上下文模块导出一个（require）方法，这个方法可以接收一个参数：请求的对象。 A context module exports a (require) function that takes one argument: the request.导出的方法有3个属性： resolve, keys, id。1234567891011121314151617resolve 是一个函数，它返回所请求的对象被解析后得到的模块id。keys 也是一个函数，它返回一个数组，由所有可能被上下文模块处理的请求的对象（译者注：参考下面第二段代码中的key）组成。比如，在你想引入一个文件夹下面的所有文件，或者引入能匹配正则表达式的文件，你可以这样：function importAll (r) &#123; r.keys().forEach(r);&#125;importAll(require.context(&apos;../components/&apos;, true, /\\.js$/));var cache = &#123;&#125;;function importAll (r) &#123; r.keys().forEach(key =&gt; cache[key] = r(key));&#125;importAll(require.context(&apos;../components/&apos;, true, /\\.js$/));// 在构建时，所有被require的模块都会被存到（上面代码中的）cache里面。借鉴了网上内容 传送门但是直接引用到vue-route里边还是有问题的，你还需要像上边提到的例子中，有多少子路由，还得在子页面中引入自己相关的路由，所以，为了一个文件就搞定的事，我开始了漫长且兴奋的研究。ok，过程的尝试和研究就不细说了，直接上代码。当然，你也可以先自己研究，实在出不来，再查看我的代码，毕竟，你可以很清楚的明白他的实现过程。12345678910&#123; path: &apos;usermanage&apos;, component: r =&gt; require.ensure([], () =&gt; r(require(&apos;page/systemManagement/usermanage/usermanage.vue&apos;))), children: (r =&gt; &#123; return r.keys().map(key =&gt; &#123;return &#123; path: key.split(&apos;.&apos;)[2], component: r(key) &#125;&#125;); &#125;)(require.context(&apos;page/systemManagement/usermanage/&apos;,false,/usermanage\\.\\w+\\.vue$/)),&#125;上例中的path 自己可以适当的改下，用正则都行。不过遗憾的是，require.comtext()中第一个参数，依旧只能写字符串路径。其实，这个才是我要解决的问题。到最后也是没有解决。不过还好学到了另外的知识，分享出来。ok，这么高大上的东西，留在项目中，让参与项目的人颤抖吧。开玩笑啦，大家一起学习，一起进步。","categories":[{"name":"Webpack","slug":"Webpack","permalink":"https://algate.coding.me/categories/Webpack/"}],"tags":[{"name":"route","slug":"route","permalink":"https://algate.coding.me/tags/route/"}]},{"title":"Vue-实现分步骤流程效果","slug":"Vue-实现分步骤流程效果","date":"2017-08-15T09:31:30.000Z","updated":"2019-02-27T05:15:21.284Z","comments":true,"path":"2017/08/15/Vue-实现分步骤流程效果/","link":"","permalink":"https://algate.coding.me/2017/08/15/Vue-实现分步骤流程效果/","excerpt":"实现效果如下：element实现方法：官网通道","text":"实现效果如下：element实现方法：官网通道1.element实现放在一个页面，加入一个步骤内容太多，有时候页面又多。一个代码文件绑定数据，方法，我想知道你得写多少行代码才能填满你肚子，人要知足啊！就是写在里边，要维护的话，你找吧，土里边找土疙瘩，累死你，如果你写的还好，如果别人来看你写的，或者你看别人写的，你是不是该骂街了。当然也可以用路由拆成模块。2.样式修改，看样子官网的可定制化还挺高，数字，包含状态的，包含描述的，横着的，竖着的……可是改起来，好，好好改吧，认认真真的。万一需求非要按设计稿的来，哦，好吧，这改组件样式的时间我早自己写样式的时间出来了，好修改好维护。1234567891011121314151617181920212223242526272829&lt;div class=&quot;zk_tm_header&quot;&gt; &lt;ul class=&quot;zk_tm_progress&quot;&gt; &lt;li&gt; &lt;p class=&quot;zk_tmpg_title&quot;&gt;导入座次表&lt;/p&gt; &lt;p class=&quot;zk_tmpg_box&quot;&gt;&lt;span class=&quot;spanNum&quot; :class=&quot;&#123;&apos;spanProgress&apos;:path&gt;0&#125;&quot;&gt;1&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p class=&quot;zk_tmpg_title&quot;&gt;导入学籍照&lt;/p&gt; &lt;p class=&quot;zk_tmpg_box&quot;&gt;&lt;span class=&quot;spanline&quot; :class=&quot;&#123;&apos;spanProgress&apos;:path&gt;1&#125;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;spanNum&quot; :class=&quot;&#123;&apos;spanProgress&apos;:path&gt;1&#125;&quot;&gt;2&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p class=&quot;zk_tmpg_title&quot;&gt;采集样本&lt;/p&gt; &lt;p class=&quot;zk_tmpg_box&quot;&gt;&lt;span class=&quot;spanline&quot; :class=&quot;&#123;&apos;spanProgress&apos;:path&gt;2&#125;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;spanNum&quot; :class=&quot;&#123;&apos;spanProgress&apos;:path&gt;2&#125;&quot;&gt;3&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p class=&quot;zk_tmpg_title&quot;&gt;位置校准&lt;/p&gt; &lt;p class=&quot;zk_tmpg_box&quot;&gt;&lt;span class=&quot;spanline&quot; :class=&quot;&#123;&apos;spanProgress&apos;:path&gt;3&#125;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;spanNum&quot; :class=&quot;&#123;&apos;spanProgress&apos;:path&gt;3&#125;&quot;&gt;4&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p class=&quot;zk_tmpg_title&quot;&gt;样本训练&lt;/p&gt; &lt;p class=&quot;zk_tmpg_box&quot;&gt;&lt;span class=&quot;spanline&quot; :class=&quot;&#123;&apos;spanProgress&apos;:path&gt;4&#125;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;spanNum&quot; :class=&quot;&#123;&apos;spanProgress&apos;:path&gt;4&#125;&quot;&gt;5&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p class=&quot;zk_tmpg_title&quot;&gt;识别检测&lt;/p&gt; &lt;p class=&quot;zk_tmpg_box&quot;&gt;&lt;span class=&quot;spanline&quot; :class=&quot;&#123;&apos;spanProgress&apos;:path&gt;5&#125;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;spanNum&quot; :class=&quot;&#123;&apos;spanProgress&apos;:path&gt;5&#125;&quot;&gt;6&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;router-view @fatherpath=&quot;fatherpath&quot;&gt;&lt;/router-view&gt;子步骤，我是通过路由来实现的，页面代码量少，方便自己查看，关键别人来维护的话也一目了然。到了第几步骤，需要子路由给父级路由传值代码如下：（跳转到步骤2，就设置为2，然后通过绑定的fatherpath传递给父组件）；12345678910111213data() &#123; return &#123; path:1 &#125;&#125;created () &#123; this.setPath()&#125;,methods:&#123; setPath () &#123; this.$emit(&apos;fatherpath&apos;,this.path); &#125;,&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://algate.coding.me/categories/Vue/"}],"tags":[{"name":"elementUI","slug":"elementUI","permalink":"https://algate.coding.me/tags/elementUI/"},{"name":"Step步骤样式","slug":"Step步骤样式","permalink":"https://algate.coding.me/tags/Step步骤样式/"}]},{"title":"Vue-select插件实现利弊","slug":"Vue-select插件实现利弊","date":"2017-08-12T09:31:30.000Z","updated":"2019-02-27T03:27:59.629Z","comments":true,"path":"2017/08/12/Vue-select插件实现利弊/","link":"","permalink":"https://algate.coding.me/2017/08/12/Vue-select插件实现利弊/","excerpt":"element实现select功能：组件功能确实还挺丰富的，当时绑定的时候，返回的是字符串，好不容易绑定上对象，还要绑定什么value-key属性，其实压根不知道干嘛用，这还不算，当需要绑定值为对象时，绑定value，key，。他们通过什么来绑定model，都会或多或少出现问题：这就尴尬了。正常的：如下代码也就oK了。123&lt;select class=&quot;custom_select&quot; v-model=&quot;resource&quot; @change=&quot;changeResource(resource)&quot; placeholder=&quot;&quot;&gt; &lt;option v-for=&quot;(resource,key) in resourceList&quot; :value=&quot;resource&quot;&gt;&#123;&#123;resource.name&#125;&#125;&lt;/option&gt;&lt;/select&gt;","text":"element实现select功能：组件功能确实还挺丰富的，当时绑定的时候，返回的是字符串，好不容易绑定上对象，还要绑定什么value-key属性，其实压根不知道干嘛用，这还不算，当需要绑定值为对象时，绑定value，key，。他们通过什么来绑定model，都会或多或少出现问题：这就尴尬了。正常的：如下代码也就oK了。123&lt;select class=&quot;custom_select&quot; v-model=&quot;resource&quot; @change=&quot;changeResource(resource)&quot; placeholder=&quot;&quot;&gt; &lt;option v-for=&quot;(resource,key) in resourceList&quot; :value=&quot;resource&quot;&gt;&#123;&#123;resource.name&#125;&#125;&lt;/option&gt;&lt;/select&gt;变态的element:（绑定的key，label，value你会把自己搞懵逼的，不写，控制台还报错警告。这成何体统。去超市买个东西，你把醋和酱油放一块买，分开还不单卖了？没有标签，没有把打开盖子，醋和酱油，有的还分不清楚，这合适么？搞笑的逻辑）；[info]（当然也有好处：比如要在下拉框中不仅仅显示文字，还要显示图片）这个就很好用1234567891011&lt;el-select v-model=&quot;changeStu.loginname&quot; @change=&quot;changeStuName&quot; filterable placeholder=&quot;请选择学生&quot;&gt; &lt;el-option v-for=&quot;stu in studentNameLists&quot; :key=&quot;stu.loginname&quot; :label=&quot;stu.name&quot; :value=&quot;stu.loginname&quot;&gt; &lt;span&gt;&#123;&#123;stu.name&#125;&#125;&lt;/span&gt; &lt;img :src=&quot;imgSrc(stu.loginname)&quot; &gt; &lt;div class=&quot;imgBak&quot;&gt;&lt;img :src=&quot;imgSrc(stu.loginname)&quot; &gt;&lt;/div&gt; &lt;/el-option&gt;&lt;/el-select&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://algate.coding.me/categories/Vue/"}],"tags":[{"name":"elementUI","slug":"elementUI","permalink":"https://algate.coding.me/tags/elementUI/"},{"name":"select","slug":"select","permalink":"https://algate.coding.me/tags/select/"}]},{"title":"webpack.ensure(webpack代码分割)","slug":"webpack-webpack.ensure","date":"2017-08-11T09:31:30.000Z","updated":"2019-02-27T05:18:38.316Z","comments":true,"path":"2017/08/11/webpack-webpack.ensure/","link":"","permalink":"https://algate.coding.me/2017/08/11/webpack-webpack.ensure/","excerpt":"require.ensure() 官网解释看完可能懵逼，但是咋们IT的精英也是多如牛毛。非常厉害果断搬过来留档留存：webpack异步加载的原理","text":"require.ensure() 官网解释看完可能懵逼，但是咋们IT的精英也是多如牛毛。非常厉害果断搬过来留档留存：webpack异步加载的原理webpack ensure相信大家都听过。有人称它为异步加载，也有人说做代码切割，那这个家伙到底是用来干嘛的？其实说白了，它就是把js模块给独立导出一个.js文件的，然后使用这个模块的时候，webpack会构造script dom元素，由浏览器发起异步请求这个js文件。场景分析:比如应用的首页里面有个按钮，点击后可以打开某个地图。打开地图的话就要利用百度地图的js,于是我们不得不在首页中把百度地图的js一起打包进去首页,一个百度地图的js文件是非常大的，假设为1m，于是就造成了我们首页打包的js非常大，用户打开首页的时间就比较长了。有没有什么好的解决方法呢？解决1既然打包成同一个js非常大的话，那么我们完全可以把百度地图js分类出去，利用浏览器的并发请求js文件处理，这样的话，会比加载一个js文件时间小得多。嗯，这也是个不错的方案。为baidumap.js配置一个新的入口就行了，这样就能打包成两个js文件，都插入html即可（如果baidumap.js被多个入口文件引用的话，也可以不用将其设置为入口文件，而且直接利用CommonsChunkPlugin,导出到一个公共模块即可）可以参考阮一峰之前写的文章webpack模块打包那还有没有更好的解决方案呢？解决2当然还是有的！我们细想，百度地图是用户点击了才弹出来的，也就是说，这个功能是可选的。那么解决方案就来了，能不能在用户点击的时候，我在去下载百度地图的js.当然可以。那如何实现用户点击的时候再去下载百度地图的js呢？于是，我们可以写一个按钮的监听器1234567891011mapBtn.click(function() &#123; //获取 文档head对象 var head = document.getElementsByTagName(&apos;head&apos;)[0]; //构建 &lt;script&gt; var script = document.createElement(&apos;script&apos;); //设置src属性 script.async = true; script.src = &quot;http://map.baidu.com/.js&quot; //加入到head对象中 head.appendChild(script);&#125;)上面的几行代码对大家来说都不难。可以在点击的时候，才加载百度地图，等百度地图加载完成后，在利用百度地图的对象去执行我们的操作。ok，讲到这里webpack.ensure的原理也就讲了一大半了。它就是 把一些js模块给独立出一个个js文件，然后需要用到的时候，在创建一个script对象，加入到document.head对象中即可，浏览器会自动帮我们发起请求，去请求这个js文件，在写个回调，去定义得到这个js文件后，需要做什么业务逻辑操作。ok,那么我们就利用webpack的api去帮我们完成这样一件事情。点击后才进行异步加载百度地图js，上面的click加载js时我们自己写的，webpack可以轻松帮我们搞定这样的事情，而不用我们手写12345mapBtn.click(function() &#123; require.ensure([], function() &#123; var baidumap = require(&apos;./baidumap.js&apos;) //baidumap.js放在我们当前目录下 &#125;)&#125;)搞定！当然还是分析一下。require.ensure这个函数是一个代码分离的分割线，表示回调里面的require是我们想要进行分割出去的，即require(’./baidumap.js’)，把baidumap.js分割出去，形成一个webpack打包的单独js文件。当然ensure里面也是可以写一些同步的require的，比如12345678var sync = require(&apos;syncdemo.js&apos;) //下面ensure里面也用到mapBtn.click(function() &#123; require.ensure([], function() &#123; var baidumap = require(&apos;./baidumap.js&apos;) //baidumap.js放在我们当前目录下 var sync = require(&apos;syncdemo.js&apos;) //这个不会独立出去，因为它已经加载到模块缓存中了 &#125;)&#125;)也就是说，ensure会把没有使用过的require资源进行独立分成成一个js文件. require.ensure的第一个参数是什么意思呢？[], 其实就是 当前这个 require.ensure所依赖的其他 异步加载的模块。你想啊？如果A 和B都是异步加载的，B中需要A，那么B下载之前，是不是先要下载A啊？，所以ensure的第一个参数[]是它依赖的异步模块，但是这里需要注意的是，webpack会把参数里面的依赖异步模块和当前的需要分离出去的异步模块给一起打包成同一个js文件，这里可能会出现一个重复打包的问题， 假设A 和 B都是异步的， ensure A 中依赖B，ensure B中 依赖A，那么会生成两个文件，都包含A和B模块。 如果想加载A require.ensure([‘A.js’],function) 即可说完了上面的原理。下面就实践一下entry.js 依赖三个 js。Abtn-work.js 是封装了 abtn按钮点击后，才执行的业务逻辑 Bbtn-work.js 是封装了 bbtn按钮点击后，才执行的业务逻辑 util.js 是封装了 entry.js需要利用的工具箱 针对上面的需求，优化方案假设 Abtn-work.js Bbtn-work.js util.js都是非常大的文件，因为 Abtn-work.js Bbtn-work.js 都不是entry.js必须有的，即可能发生的操作，那么我们把他们利用异步加载，当发生的时候再去加载就行了util.js是entry.js立即马上依赖的工具箱。但是它又非常的大，所以将其配置打包成一个公共模块，利用浏览器的并发加载，加快下载速度。ok,构思完成，开始实现12345678910111213index.html&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;index&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;aBtn&quot;&gt;Abtn&lt;/div&gt; &lt;div id=&quot;bBtn&quot;&gt;Bbtn&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;定义了两个buttom然后看看 entry.js12345678910111213141516171819202122var util_sync = require(&apos;./util-sync.js&apos;)alert(util_sync.data)document.getElementById(&quot;aBtn&quot;).onclick = function() &#123; require.ensure([], function() &#123; var awork = require(&apos;./workA-async.js&apos;) alert(awork.data) //异步里面再导入同步模块--实际是使用同步中的模块 var util1 = require(&apos;./util-sync.js&apos;) &#125;)&#125;document.getElementById(&quot;bBtn&quot;).onclick = function() &#123; require.ensure([], function() &#123; var bwork = require(&apos;./workB-async.js&apos;) alert(bwork.data) &#125;)&#125;可以看到，workA-async.js， workB-async.js 都是点击后才ensure进来的。什么时候加载完成呢？就是 require.ensure() 第二个函数参数，即回调函数，它表示当下载js完成后，发生的因为逻辑webpack打包后，形成其实， 1.1… 2.2…就是我们ensure导出来的js文件我们看看代码是如何加载的执行的，点击打包插入js后的html可以看到，并没有加载 ensure导出来的 1.1…js 2.2…js点击 abtn,发现浏览器下载并加载了 1.1…js点击 bbtn发现浏览器下载并加载了 2.2…jsok 全部完成[转载连接地址] : http://cnodejs.org/topic/586823335eac96bb04d3e305","categories":[{"name":"Webpack","slug":"Webpack","permalink":"https://algate.coding.me/categories/Webpack/"}],"tags":[{"name":"ensure","slug":"ensure","permalink":"https://algate.coding.me/tags/ensure/"}]},{"title":"Vue-文件上传功能(另类不如自己实现)","slug":"Vue-No文件上传功能","date":"2017-08-08T09:31:30.000Z","updated":"2019-02-27T05:17:31.005Z","comments":true,"path":"2017/08/08/Vue-No文件上传功能/","link":"","permalink":"https://algate.coding.me/2017/08/08/Vue-No文件上传功能/","excerpt":"elementUI组件其实已经很方便的使用上传功能，但是有很多弊端，感觉不是很好用，在自己用elementUI的upload实现上传功能感觉很累赘（绑定一堆的方法，绑定一堆的变量，绑定出错还得费时费力去调试……）‘eg’：我就遇到个问题，上传只能上传一个文件，用插件实现的话，还得单独写个，关键还不知道往哪个方法里写，调试了很久也没调好。果断放弃了。‘eg’：选择文件夹，反而还做不到，无语ing，我要做一个选择多张图片，不是234张，是好几十张，让我选择一堆图片，烦不烦，我就选个文件夹不久解决了，element反而做不到。。。‘eg’：存储数据不方便，最主要的就是，绑定一堆乱七八糟的方法和变量，有时候（需要特殊处理的时候）就是不管你怎么操作，就是不对。","text":"elementUI组件其实已经很方便的使用上传功能，但是有很多弊端，感觉不是很好用，在自己用elementUI的upload实现上传功能感觉很累赘（绑定一堆的方法，绑定一堆的变量，绑定出错还得费时费力去调试……）‘eg’：我就遇到个问题，上传只能上传一个文件，用插件实现的话，还得单独写个，关键还不知道往哪个方法里写，调试了很久也没调好。果断放弃了。‘eg’：选择文件夹，反而还做不到，无语ing，我要做一个选择多张图片，不是234张，是好几十张，让我选择一堆图片，烦不烦，我就选个文件夹不久解决了，element反而做不到。。。‘eg’：存储数据不方便，最主要的就是，绑定一堆乱七八糟的方法和变量，有时候（需要特殊处理的时候）就是不管你怎么操作，就是不对。12345// html部分：&lt;el-button type=&quot;primary&quot; onclick=&quot;chooseSeat.click()&quot; :disabled=&quot;flag.onceUpload&quot;&gt;导入座位表&lt;/el-button&gt;&lt;input id=&quot;chooseSeat&quot; name=&quot;files&quot; style=&quot;display:none;&quot; type=&quot;file&quot; @change=&quot;onFileSelect()&quot;accept=&quot;application/vnd.ms-excel&quot;/&gt;路径选择文件夹 1&lt;input id=&quot;choose&quot; name=&quot;files&quot; style=&quot;display:none;&quot; type=&quot;file&quot; @change=&quot;onFileSelect()&quot; multiple=&quot;multiple&quot; accept=&quot;image/png,image/jpeg,image/jpg&quot; webkitdirectory directory/&gt; 123456789101112131415161718192021222324// javascript部分：onFileSelect()&#123; var oFiles = document.querySelector(&quot;#chooseSeat&quot;).files; for (var i=0;i&lt;oFiles.length;i++)&#123; this.files.push(oFiles[i]); &#125; this.startUpload();&#125;,startUpload()&#123; let v = this; let formData = new FormData(); for (var i = 0, file; file = this.files[i]; i++) &#123; formData.append(&apos;file&apos;, file); // 根据需要这里可能需要作出不同的修改：formData.append(file.name, file); &#125; formData.append(&apos;deptid&apos;,v.curGrade.id); formData.append(&apos;code&apos;,v.curGrade.code); formData.append(&apos;flag&apos;,v.resampleFlag?1:0); console.log(formData); adminService.importTeachingStudent(formData).then(function(r)&#123; // 操作 &#125;)&#125;,路径选择文件夹处理图片 123456for (var i=0;i&lt;oFiles.length;i++)&#123; var type = oFiles[i][&apos;type&apos;]; if(/^image/g.test(type))&#123; this.files.push(oFiles[i]); &#125;&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://algate.coding.me/categories/Vue/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://algate.coding.me/tags/文件上传/"},{"name":"elementUI","slug":"elementUI","permalink":"https://algate.coding.me/tags/elementUI/"}]},{"title":"vue常用组件使用以及配置","slug":"Vue-常用组件使用及配置","date":"2017-07-26T09:31:30.000Z","updated":"2019-02-27T05:15:41.336Z","comments":true,"path":"2017/07/26/Vue-常用组件使用及配置/","link":"","permalink":"https://algate.coding.me/2017/07/26/Vue-常用组件使用及配置/","excerpt":"* 路由12345678910111213141516import Vue from &apos;vue&apos;import VueRouter from &apos;vue-router&apos;// 引用路由配置文件import routes from &apos;./config/routes&apos;// 使用配置文件规则const router = new VueRouter(&#123; routes: routes&#125;)// 跑起来吧new Vue(&#123; el: &apos;#app&apos;, router, store, template: &apos;&lt;App/&gt;&apos;, components: &#123; App &#125;&#125;)","text":"* 路由12345678910111213141516import Vue from &apos;vue&apos;import VueRouter from &apos;vue-router&apos;// 引用路由配置文件import routes from &apos;./config/routes&apos;// 使用配置文件规则const router = new VueRouter(&#123; routes: routes&#125;)// 跑起来吧new Vue(&#123; el: &apos;#app&apos;, router, store, template: &apos;&lt;App/&gt;&apos;, components: &#123; App &#125;&#125;)* elementUI12345// 引入ui组件import ElementUI from &apos;element-ui&apos;import &apos;element-ui/lib/theme-default/index.css&apos;// import &apos;style/elementUI/elementUI.css&apos;Vue.use(ElementUI)* axios 发送请求 (推荐使用fetch推荐使用)123// axios 官方推荐APIimport axios from &apos;axios&apos;Vue.prototype.$http = axios[info]可以把接口封装到services里边，防止接口修改维护时，可以很快直接的定位。12345678910111213141516import axios from &apos;axios&apos;let adminService = &#123;&#125;；adminService = &#123; getUser(params) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.post(baseURL + &apos;/getUser&apos;,params).then(function(res) &#123; resolve(res); &#125;).catch(function(reason)&#123; console.log(reason); &#125;); &#125;); &#125;,&#125;export &#123; adminService&#125;如果本地测试的话，可以做到前后端分离，只不过要保存一份json格式的文件。以方便测试。这样做，好处多多。本人在搭建环境的时候，逐渐总结和积累的。* vuex数据1234// 组件之间数据传递import Vuex from &apos;vuex&apos;Vue.use(Vuex)import store from &apos;./config/vuex/store&apos;store.js—保存存储数据的1234567891011121314151617181920import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)const store = new Vuex.Store(&#123; // 定义状态 state: &#123; // 静态的。 classfiyList:[ &#123;&quot;enable&quot;:&quot;0&quot;,&quot;name&quot;:&quot;管理员&quot;,&quot;value&quot;:&quot;1&quot;&#125;, &#123;&quot;enable&quot;:&quot;0&quot;,&quot;name&quot;:&quot;领导&quot;,&quot;value&quot;:&quot;2&quot;&#125;, &#123;&quot;enable&quot;:&quot;0&quot;,&quot;name&quot;:&quot;老师&quot;,&quot;value&quot;:&quot;3&quot;&#125;, &#123;&quot;enable&quot;:&quot;0&quot;,&quot;name&quot;:&quot;学生&quot;,&quot;value&quot;:&quot;4&quot;&#125; ], trainmodelQuery:&#123;&#125;, &#125; mutations: &#123; getTrainmodelQuery(state,trainmodelQuery)&#123; state.trainmodelQuery = trainmodelQuery &#125; &#125;1234567new Vue(&#123; el: &apos;#app&apos;, router, store, template: &apos;&lt;App/&gt;&apos;, components: &#123; App &#125;&#125;)子页面需要把数据存储到store里边1this.$store.commit(&apos;getTrainmodelQuery&apos;,params);","categories":[{"name":"Vue","slug":"Vue","permalink":"https://algate.coding.me/categories/Vue/"}],"tags":[{"name":"vue组件","slug":"vue组件","permalink":"https://algate.coding.me/tags/vue组件/"}]},{"title":"vue.$set的使用-更新视图","slug":"Vue-Vue.$set使用更新视图","date":"2017-07-08T09:31:30.000Z","updated":"2019-02-27T03:27:59.625Z","comments":true,"path":"2017/07/08/Vue-Vue.$set使用更新视图/","link":"","permalink":"https://algate.coding.me/2017/07/08/Vue-Vue.$set使用更新视图/","excerpt":"在我们使用vue进行开发的过程中，可能会遇到一种情况：当生成vue实例后，当再次给数据赋值时，有时候并不会自动更新到视图上去；当我们去看vue文档的时候，会发现有这么一句话：如果在实例创建之后添加新的属性到实例上，它不会触发视图更新。so，网上查阅资料和文档后得知可以使用 Vue.$set下边是我写过的一个关于图片不同显示代码示例：","text":"在我们使用vue进行开发的过程中，可能会遇到一种情况：当生成vue实例后，当再次给数据赋值时，有时候并不会自动更新到视图上去；当我们去看vue文档的时候，会发现有这么一句话：如果在实例创建之后添加新的属性到实例上，它不会触发视图更新。so，网上查阅资料和文档后得知可以使用 Vue.$set下边是我写过的一个关于图片不同显示代码示例：123456789101112131415161718192021222324252627282930// vue&lt;ul class=&quot;zk_stu_exImg&quot;&gt; &lt;li v-for=&quot;(img,key) in exampleImg&quot;&gt; &lt;img :src=&quot;img.url&quot; @click=&quot;isWrong(&apos;y&apos;,img)&quot;&gt; &lt;img v-if=&quot;img.wrong&quot; class=&quot;wrong_flag_img&quot; src=&quot;static/img/worng2.png&quot; @click=&quot;isWrong(&apos;n&apos;,img)&quot;&gt; &lt;/li&gt;&lt;/ul&gt;// wrong属性是新添加的，wrong为true的时候显示2图，wrong为false的时候显示1图(下边有多余的代码，是我写的，把选中的错误的图片重新保存到arr数组中，看的时候可以不看else)export default &#123; methods:&#123; isWrong (yOrn,img)&#123; if(!img.wrong)&#123; this.$set(img,&apos;wrong&apos;,true); this.arr.push(img.url); console.log(img); &#125; else &#123; for(var i=0;i&lt;this.arr.length;i++)&#123; if(img.url == this.arr[i])&#123; this.arr.splice(i,1); break; &#125; &#125; this.$set(img,&apos;wrong&apos;,false); &#125; &#125; &#125;&#125;1、通过Vue.set方法设置data属性，如上：Vue.set(img,&apos;wrong&apos;,false) 2、您还可以使用 vm.$set实例方法，这也是全局 Vue.set方法的别名:this.$set(&apos;info.content&apos;, &apos;what is this?&apos;);","categories":[{"name":"Vue","slug":"Vue","permalink":"https://algate.coding.me/categories/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://algate.coding.me/tags/vue/"},{"name":"$set","slug":"set","permalink":"https://algate.coding.me/tags/set/"}]},{"title":"Jekyll博客创建-环境配置及安装","slug":"Jekyll搭建属于你自己的blog","date":"2017-06-25T09:31:30.000Z","updated":"2019-02-27T05:09:29.325Z","comments":true,"path":"2017/06/25/Jekyll搭建属于你自己的blog/","link":"","permalink":"https://algate.coding.me/2017/06/25/Jekyll搭建属于你自己的blog/","excerpt":"前人栽树，后人乘凉。多谢各位大牛的技术文档，让我可以站在巨人的肩膀上眺望远方！(不过在windows上走流程有各种坑)下边是我结合制作自己博客写的总结：（非常建议Windows下用hexo环境创建博客，jekyll下问题多多，坑坑多多）本人使用Jekyll搭建的博客地址:https://algate.github.io/","text":"前人栽树，后人乘凉。多谢各位大牛的技术文档，让我可以站在巨人的肩膀上眺望远方！(不过在windows上走流程有各种坑)下边是我结合制作自己博客写的总结：（非常建议Windows下用hexo环境创建博客，jekyll下问题多多，坑坑多多）本人使用Jekyll搭建的博客地址:https://algate.github.io/不知为何，master上传代码之后，加了分页显示的内容展示不出来。所以原jekyll代码放在了另一个地方,欢迎大家star —— 传送门mkdir Algate’s Site在Windows环境下和其他环境系统下安装内容和方法有所不同，此处只介绍windows下安装方法windows环境下安装；操作说明连接地址：http://www.madhur.co.in/blog/2011/09/01/runningjekyllwindows.html1. 安装 Ruby官网：http://rubyinstaller.org/downloads/测试：Ruby是否安装成功，执行命令ruby -v注意：勾选 “Add Ruby executables to your PATH”，安装路径不能包含空格2.安装DevKit-mingw64-64-4.7.2-20130224-1432-sfx.exe地址：在步骤一的官网地址里这里需要特别注意：要下载相对应的版本步骤：在命令窗口下切换到安装目录，并执行以下命令C:\\Devkit 下：12ruby dk.rb initnotepad config.yml在打开的记事本窗口中，末尾会自动添加新的一行- C:\\Ruby…-x64。（相对应的安装路径）回到命令行窗口内，审查（非必须）并安装。123ruby dk.rb reviewruby dk.rb install测试：gem是否安装成功，执行命令gem -v3.到想要创建站点项目的本地路径下步骤：在命令窗口下执行以下命令可以更改源，可以直接略过直接安装jekyll（但是国内你就不要跳过了）详细方法连接地址：http://blog.csdn.net/rxm1989/article/details/400501851234567891011121314151617//更换gem源gem sources --remove https://rubygems.org/gem sources -a https://ruby.taobao.org/|~~|此处有错，截止到发稿时，镜像地址已经改变，地址为：[http://gems.ruby-china.org/](http://gems.ruby-china.org/)gem sources -a http://gems.ruby-china.org///查看gem源gem sources -l清空源缓存gem sources -c更新源缓存gem sources -u//更新gemgem update --system//安装jekyllgem install jekyll是否安装成功测试：坑：（提醒 ridk install）- 但是呢你根本下载不下来，网上不好找，终于找到一个连接地址：https://www.jianshu.com/p/181e3fe0b545测试：gem是否安装成功，执行命令gem -v4.安装python（可以直接略过直接看第七步骤）地址：https://www.python.org/downloads/release/python-2714/需要手动配置环境变量5.安装 Easy Install下载distribute_setup.py地址：http://pypi.python.org/pypi/distribute（官网下载的py文件一直执行不成功）换成被人改好的文件执行成功了下载地址：https://pan.baidu.com/s/1jG2bYbs把此文件单独放到python安装根目录下命令：在python根目录下执行：python distribute_setup.py判断是否安装成功，网上的测试在Windows下有问题：测试：Easy Install 是否安装成功，执行命令easy_install –version测试是否安装成功需要找到python根目录下找相关路径 （Lib\\site-packages\\easy_install.py）例如：C:\\Python27\\Lib\\site-packages然后执行 easy_install.py –version(.py文件后缀必须添加，负责永远对不了-我的电脑如此)此处问题较多，再加上官网也没有详细的结束，会长时间尝试安装，大坑啊！网上解决方法https://jingyan.baidu.com/article/09ea3ede27f88ac0aede3900.html6.安装 Pygments7.（可以是第四步）。jekyll new algateJekyll然后在文件夹下可以自动生成文件夹，初始内容如下图所示8.cd algateJekylljekyll serve我这执行启动服务的时候，出现了下列报错需要安装bundler（gem install bundler）可能需要重新打开命令窗口执行serverjekyll –serve –watch 命令将开启实时更新，修改文件后在浏览器中刷新就可看到效果，对本地调试很有帮助；至此，简单的jekyll服务搭建完成（4-6是为了高亮显示所需要的插件）仿照https://themebetter.com/ 主题制作属于自己的blog 传送门","categories":[{"name":"文档","slug":"文档","permalink":"https://algate.coding.me/categories/文档/"}],"tags":[{"name":"jekyll","slug":"jekyll","permalink":"https://algate.coding.me/tags/jekyll/"}]},{"title":"vue-cli脚手架构建项目一问题汇总","slug":"vue-cli脚手架构建项目一问题汇总","date":"2017-06-10T09:31:30.000Z","updated":"2019-02-27T05:21:30.614Z","comments":true,"path":"2017/06/10/vue-cli脚手架构建项目一问题汇总/","link":"","permalink":"https://algate.coding.me/2017/06/10/vue-cli脚手架构建项目一问题汇总/","excerpt":"修改几个个地方（陆续记录），看起来不起眼，其实很重要的。我也是花了很长时间调试才出来的；修改配置文件，必须 cnpm 重新启动项目babel-polyfillmain.js 即vue项目的入口文件，开头部分需要引入import &quot;babel-polyfill&quot;","text":"修改几个个地方（陆续记录），看起来不起眼，其实很重要的。我也是花了很长时间调试才出来的；修改配置文件，必须 cnpm 重新启动项目babel-polyfillmain.js 即vue项目的入口文件，开头部分需要引入import &quot;babel-polyfill&quot; config下index文件 assetsPublicPath如下图[右侧箭头]想说的是，原本内容为 ‘/‘。没有小点；解决的问题是：文档发布找文件路径是在当前路径下找相对路径，否则的话会找绝对路径具体为啥，可以百度详查；static (stylesheel图片路径问题)如下图所示【此处关键】解决的问题是：样式表里引入的背景图片原本会自动加入’static/css’。把背景图识别到了样式css的目录下加上词句后，就可以找到样式表外层目录；[danger] 需要注意的是： 样式表里引入的图片路径不能写绝对路径域名是否开启html5模式(history)如下图所示【此处关键】图片中注释的一句：mode：’history’；在浏览器域名下不显示’#’，使用的是html5模式；其实也不是问题，但是如果和后端配合，前端的项目不在根路径（webapps下），那么就需要路由带 # 来控制了；alias (build下webpack.config.base中exports-resolve下)如下图所示[文件路径]但我们在页面中import，图片……需要添加文件路径的时候，写一堆“../../../”等等的路径，费半天劲，此刻不用了，只要设置了上图中的文件路径，就可以在页面中直接写”config/…文件”，开发和打包的时候，vue会自动匹配文件路径，方便又省事。[danger] 需要注意的是：样式表里图片的路径必须写绝对路径(识别不了css文件里的配置路径–问题2)一直没有找到解决之道，导致我的项目找个图片写了一堆的“../../../../”jquery引入(不推荐-实际项目用到的地方不是太多)（1）入口文件main.js中加入（2）base.conf.js中添加路径（3）步骤2中，和entry同级添加入下图内容：【此处添加如果没有引入webpack】需要引入var webpack = require(“webpack”)&lt;a&gt;&lt;/a&gt; :active激活状态样式.router-link-active 路由中用到 hover，当前选中状态，vue给我们提供了一个比较直接的样式(vue提供了简单暴力的方式)一个项目中出现激活状态的a标签不会只有一处，so需要解决的是，点击不同的模块下，其他模块的激活状态不收影响的问题；这个在配置路由的时候也会影响到此处样式的问题。需要保证，有父级路由并且，不能随意变换。ip有时候需要配置ip来解决项目中的一些问题我做过的项目就遇到过一个问题设置完代理服务器之后，我们登录单独用cas做了一个项目，当登录后台返回结果之后，如果不配置ip，多个人开发项目的时候，默认返回的都是127.0.0.1。导致不知道返回设备的session可能失效……等等port启动多个服务器项目，不仅仅是vue，可能需要改变下域名的port。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://algate.coding.me/categories/Vue/"}],"tags":[{"name":"vue-cli","slug":"vue-cli","permalink":"https://algate.coding.me/tags/vue-cli/"}]},{"title":"vue-cli脚手架构建项目一","slug":"vue-cli脚手架构建项目一","date":"2017-06-08T09:31:30.000Z","updated":"2019-02-27T03:27:59.650Z","comments":true,"path":"2017/06/08/vue-cli脚手架构建项目一/","link":"","permalink":"https://algate.coding.me/2017/06/08/vue-cli脚手架构建项目一/","excerpt":"先安装nodejs，node -v测试，可能需要配置环境变量；以下 npm 都可以用 cnpm 命令来提高安装效率，需要安装cnpmnpm install vue-cli -g 这个无用多说，全局安装vue-cli。","text":"先安装nodejs，node -v测试，可能需要配置环境变量；以下 npm 都可以用 cnpm 命令来提高安装效率，需要安装cnpmnpm install vue-cli -g 这个无用多说，全局安装vue-cli。1.开始创建项目使用vue初始化基于webpack的新项目vue init webpack your-project 项目创建过程中会提示是否安装eslint，可以选择不安装，否则项目编译过程中出现各种代码格式的问题；项目创建完成后，安装基础模块；（团队中开发人员比较多之后，每个人的代码规范层次都不一样，建议加入，可以统一书写规范，好处多多哦！）cd your-project; npm install; 安装完成之后可在开发模式下运行项目并预览项目效果npm run dev; 如果项目可以正常启动，即可继续安装vue的辅助工具npm install vue-router --save （路由管理模块） npm install vuex --save （状态管理模块） npm install axios(vue-resource) --save （网路请求模块） ……","categories":[{"name":"Vue","slug":"Vue","permalink":"https://algate.coding.me/categories/Vue/"}],"tags":[{"name":"vue-cli","slug":"vue-cli","permalink":"https://algate.coding.me/tags/vue-cli/"}]},{"title":"ES6-export与export default区别","slug":"ES6-export和default-export区别","date":"2017-05-15T09:31:30.000Z","updated":"2019-02-27T03:27:59.536Z","comments":true,"path":"2017/05/15/ES6-export和default-export区别/","link":"","permalink":"https://algate.coding.me/2017/05/15/ES6-export和default-export区别/","excerpt":"1.export与export default均可用于导出常量、函数、文件、模块等2.你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用3.在一个文件或模块中，export、import可以有多个，export default仅有一个4.通过export方式导出，在导入时要加{ }，export default则不需要","text":"1.export与export default均可用于导出常量、函数、文件、模块等2.你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用3.在一个文件或模块中，export、import可以有多个，export default仅有一个4.通过export方式导出，在导入时要加{ }，export default则不需要1.export12345//a.jsexport const str = &quot;blablabla~&quot;;export function log(sth) &#123; return sth;&#125;对应的导入方式：12//b.jsimport &#123; str, log &#125; from &apos;a&apos;; //也可以分开写两次，导入的时候带花括号2.export default123//a.jsconst str = &quot;blablabla~&quot;;export default str;对应的导入方式：12//b.jsimport str from &apos;a&apos;; //导入的时候没有花括号使用export default命令，为模块指定默认输出，这样就不需要知道所要加载模块的变量名123//a.jslet sex = &quot;boy&quot;;export default sex（sex不能加大括号）原本直接export sex外部是无法识别的，加上default就可以了.但是一个文件内最多只能有一个export default。其实此处相当于为sex变量值”boy”起了一个系统默认的变量名default，自然default只能有一个值，所以一个文件内不能有多个export default。123import any from &quot;./a.js&quot;import any12 from &quot;./a.js&quot;console.log(any,any12) // boy,boy","categories":[{"name":"Es6","slug":"Es6","permalink":"https://algate.coding.me/categories/Es6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://algate.coding.me/tags/es6/"}]},{"title":"dialog弹层组件全面解析-实现思路一","slug":"Vue-dialog弹层组件全面解析一","date":"2017-03-26T09:31:30.000Z","updated":"2019-02-27T05:21:50.444Z","comments":true,"path":"2017/03/26/Vue-dialog弹层组件全面解析一/","link":"","permalink":"https://algate.coding.me/2017/03/26/Vue-dialog弹层组件全面解析一/","excerpt":"效果如下图流程one.自己定义弹层(弹层实现不包括别的样式和事件-非UI框架实现思路)通过父组件页面的flag来显示和隐藏弹层","text":"效果如下图流程one.自己定义弹层(弹层实现不包括别的样式和事件-非UI框架实现思路)通过父组件页面的flag来显示和隐藏弹层vue1&lt;!-- 页面点击事件 --&gt; &lt;hgroup&gt; &lt;button class=&quot;c_button_icon&quot; @click=&quot;J_addOrEdit(null,&apos;add&apos;)&quot;&gt;&lt;i class=&quot;icon_add size_12&quot;&gt;&lt;/i&gt;&lt;/button&gt; &lt;!-- &lt;el-button type=&quot;primary&quot; size=&quot;small&quot; icon=&quot;el-icon-plus&quot;&gt;&lt;/el-button&gt; --&gt; &lt;el-button type=&quot;primary&quot; size=&quot;small&quot; @click=&quot;J_import&quot;&gt;导入&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; size=&quot;small&quot; @click=&quot;J_deletes&quot;&gt;删除&lt;/el-button&gt; &lt;/hgroup&gt; （此处使用elementUI的command-还不错，统一管理，代码简洁，规范整理不是显的太乱）&lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button type=&quot;text&quot; size=&quot;small&quot; @click=&quot;J_addOrEdit(scope.row,&apos;edit&apos;)&quot;&gt;编辑&lt;/el-button&gt; &lt;el-dropdown trigger=&quot;click&quot; @command=&quot;J_handle&quot;&gt; &lt;span class=&quot;el-dropdown-link&quot;&gt;更多&lt;/span&gt; &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt; &lt;el-dropdown-item :command=&apos;{&quot;handle&quot;:&quot;J_reset&quot;,&quot;row&quot;:scope.row}&apos;&gt;重置密码 &lt;/el-dropdown-item&gt; &lt;el-dropdown-item :command=&apos;{&quot;handle&quot;:&quot;J_enable&quot;,&quot;row&quot;:scope.row}&apos;&gt;启用 &lt;/el-dropdown-item&gt; &lt;el-dropdown-item :command=&apos;{&quot;handle&quot;:&quot;J_disabled&quot;,&quot;row&quot;:scope.row}&apos;&gt;禁用 &lt;/el-dropdown-item&gt; &lt;el-dropdown-item :command=&apos;{&quot;handle&quot;:&quot;J_delete&quot;,&quot;row&quot;:scope.row}&apos;&gt;删除 &lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; &lt;/template&gt; 2&lt;!-- 子组件 --&gt; &lt;div v-show=&quot;flag.flag_dialog_addOrEdit&quot;&gt; &lt;dialogAddorEdit @close=&quot;close&quot; :info_user=&quot;user&quot; ref=&quot;ref_user&quot;&gt;&lt;/dialogAddorEdit&gt; &lt;/div&gt; &lt;div v-if=&quot;flag.flag_dialog_import&quot;&gt; &lt;dialogImport @close=&quot;close&quot;&gt;&lt;/dialogImport&gt; &lt;/div&gt; &lt;div v-show=&quot;flag.flag_dialog_delete&quot;&gt; &lt;dialogDel @close=&quot;close&quot;&gt;&lt;/dialogDel&gt; &lt;/div&gt; &lt;div v-show=&quot;flag.flag_dialog_reset&quot;&gt; &lt;dialogReset @close=&quot;close&quot;&gt;&lt;/dialogReset&gt; &lt;/div&gt; &lt;div v-show=&quot;flag.flag_dialog_enable&quot;&gt; &lt;dialogEnable @close=&quot;close&quot;&gt;&lt;/dialogEnable&gt; &lt;/div&gt; 需要注意的是：使用 v-show和 v-if 之后各有利弊：1.使用v-if之后，dialog相当于重新加载，导致的结果就是子组件获取$ref上的数据的时候获取不到，需要进入弹层的时候赋值并且表单验证之后，直接关闭弹层再打开也没有飘红的现象。（在用vue 使用elementUI验证规则的时候，定义规则的时候，需要注意。v-if，值为undefined）–关于验证可以访问另一篇文章：vue-表单验证规则。2.使用v-show,dialog相当于显示和隐藏，$ref上的数据可以获取到，省去不少麻烦。但是，表单验证的时候，验证过表单直接关闭弹层再打开就会出现飘红的现象。体验很糟糕，不过elementUI提供了方案，关闭弹层触发的时候执行重置为初始值并移除校验结果。给子组件传递数据用了两种方式，:info_user=&quot;user&quot; 和 ref=&quot;ref_user&quot;user 父组件数据绑定到子组件上去$ref.ref_user 来操作子组件数据script:1.import dialogDel from &apos;./user_dialog/user_delete&apos;; import dialogAddorEdit from &apos;./user_dialog/user_addOrEdit&apos;; import dialogImport from &apos;./user_dialog/user_import&apos;; import dialogReset from &apos;./user_dialog/user_reset&apos;; import dialogEnable from &apos;./user_dialog/user_enable&apos;; 2.data () { return { flag: { flag_dialog_delete: false, flag_dialog_addOrEdit: false, flag_dialog_import: false, flag_dialog_reset: false, flag_dialog_enable: false }, multipleSelection: [] } }, 3.components: { dialogDel, dialogAddorEdit, dialogImport, dialogReset, dialogEnable }, 4.method: { &lt;!-- 点击操作 --&gt; J_handle (command) { switch (command.handle) { case &apos;J_reset&apos;: this.flag.flag_dialog_reset = true; console.log(command.row); break; case &apos;J_enable&apos;: this.flag.flag_dialog_enable = true; console.log(command.row); break; case &apos;J_disabled&apos;: this.flag.flag_dialog_enable = true; console.log(command.row); break; case &apos;J_delete&apos;: this.flag.flag_dialog_delete = true; console.log(command.row); break; } }, // add &amp; edit J_addOrEdit (data, edit) { this.flag.flag_dialog_addOrEdit = true; if (edit === &apos;edit&apos;) { this.$refs.ref_user.title = &apos;用户编辑&apos;; this.$refs.ref_user.deptId = this.deptId; this.$refs.ref_user.userType = this.userType; this.user = Object.assign({}, data); } else { this.$refs.ref_user.title = &apos;添加用户&apos;; this.$refs.ref_user.deptId = this.deptId; this.$refs.ref_user.userType = this.userType; this.user = {}; } console.log(data); }, // import J_import () { this.flag.flag_dialog_import = true; }, // deletes J_deletes () { this.flag.flag_dialog_delete = true; }, &lt;!-- msg为子组件emit给父组件传递的数据 --&gt; close (msg) { this.flag.flag_dialog_delete = false; this.flag.flag_dialog_addOrEdit = false; this.flag.flag_dialog_import = false; this.flag.flag_dialog_reset = false; this.flag.flag_dialog_enable = false; /* eslint-disable no-unused-expressions */ msg ? this.J_get_students() : null; } } 子组件页面子组件页面关闭和取消按钮添加close事件，通过 $emit 传递给父组件子组件使用props =&gt; :info_user 来获得父组件user绑定过来的数据初始化 user_ref 上的 title 的默认值1.user_addOrEdit&lt;div class=&quot;c_dialog_box&quot;&gt; &lt;div class=&quot;c_dialog&quot;&gt; &lt;header class=&quot;c_dialog_header&quot;&gt; &lt;span&gt;{{title}}&lt;/span&gt; &lt;i class=&quot;el-icon-close right&quot; @click=&quot;close&quot;&gt;&lt;/i&gt; &lt;/header&gt; &lt;section class=&quot;c_dialog_center&quot;&gt; &lt;div&gt; &lt;el-form :model=&quot;info_user&quot; label-width=&quot;80px&quot;&gt; &lt;el-form-item label=&quot;账号&quot;&gt; &lt;el-input v-model=&quot;info_user.gradecode&quot; placeholder=&quot;账号&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;姓名&quot;&gt; &lt;el-input v-model=&quot;info_user.gradename&quot; placeholder=&quot;姓名&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;机构&quot;&gt; &lt;el-input v-model=&quot;info_user.superior&quot; placeholder=&quot;机构&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;性别&quot;&gt; &lt;el-radio-group v-model=&quot;info_user.graderoom&quot;&gt; &lt;el-radio label=&quot;1&quot;&gt;男&lt;/el-radio&gt; &lt;el-radio label=&quot;2&quot;&gt;女&lt;/el-radio&gt; &lt;/el-radio-group&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;邮箱&quot;&gt; &lt;el-input v-model=&quot;info_user.gradenum&quot; placeholder=&quot;邮箱&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;电话&quot;&gt; &lt;el-input v-model=&quot;info_user.genre&quot; placeholder=&quot;电话&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/section&gt; &lt;footer class=&quot;c_dialog_footer&quot;&gt; &lt;el-button type=&quot;info&quot; size=&quot;small&quot; plain @click=&quot;close&quot;&gt;取消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; size=&quot;small&quot; @click=&quot;J_dialog_data_save&quot;&gt;确定&lt;/el-button&gt; &lt;/footer&gt; &lt;/div&gt; &lt;/div&gt; import { userService } from ‘services/usermanage.service’; export default { props: [&apos;info_user&apos;], data () { return { &lt;!-- v-if时 通过$ref操作子组件初始化是没有值的(需要赋值) --&gt; title: &apos;&apos; }; }, created () { console.log(this.info_user); }, updated() { console.log(this.title); }, methods: { close () { this.$emit(&apos;close&apos;); }, J_dialog_data_save() { if (this.title === &apos;用户编辑&apos;) { // save edit data let params = { id: this.info_user.id, deptId: this.deptId, loginName: this.info_user.loginName, name: this.info_user.name, sex: this.info_user.sex, email: this.info_user.email, phone: this.info_user.phone }; userService.editUser(params).then(r =&gt; { r.data.code === 0 ? this.$message.success(r.data.msg) : this.$message.error(r.data.msg); this.$emit(&apos;close&apos;, r.data.code === 0 ? &apos;update&apos; : null); }); } else { // save add data let params = { deptId: this.deptId, loginName: this.info_user.loginName, name: this.info_user.name, sex: this.info_user.sex, userType: this.userType, email: this.info_user.email, phone: this.info_user.phone }; userService.addUser(params).then(r =&gt; { r.data.code === 0 ? this.$message.success(r.data.msg) : this.$message.error(r.data.msg); this.$emit(&apos;close&apos;, r.data.code === 0 ? &apos;update&apos; : null); }); } } } };2.user_delete&lt;template&gt; &lt;div class=&quot;c_dialog_box&quot;&gt; &lt;div class=&quot;c_dialog&quot;&gt; &lt;header class=&quot;c_dialog_header&quot;&gt; &lt;span&gt;删除确认&lt;/span&gt; &lt;i class=&quot;el-icon-close right&quot; @click=&quot;close&quot;&gt;&lt;/i&gt; &lt;/header&gt; &lt;section class=&quot;c_dialog_center&quot;&gt; &lt;p&gt;您正在执行删除操作，确认删除所选内容&lt;/p&gt; &lt;/section&gt; &lt;footer class=&quot;c_dialog_footer&quot;&gt; &lt;el-button type=&quot;info&quot; size=&quot;small&quot; plain @click=&quot;close&quot;&gt;取消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; size=&quot;small&quot;&gt;确定&lt;/el-button&gt; &lt;/footer&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data () { return { }; }, methods: { close () { this.$emit(&apos;close&apos;); } } }; &lt;/script&gt; &lt;style lang=&quot;scss&quot;&gt; @import &quot;src/style/c_dialog&quot;; &lt;/style&gt; c_dialog样式文件.c_dialog_box { position: fixed; z-index: 100; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); } .c_dialog { min-width: 420px; position:absolute; top:50%; left:50%; -webkit-transform: translate(-50%,-50%); -moz-transform: translate(-50%,-50%); transform:translate(-50%,-50%); background: #fff; } .c_dialog .c_dialog_header { height: 50px; padding-left: 30px; padding-right: 15px; line-height: 50px; color: #fff; font-size: 16px; background: #2dabff; } .c_dialog .c_dialog_header .right { float: right; font-size: 18px; line-height: 50px; cursor: pointer; } .c_dialog .c_dialog_center { padding: 30px 35px; } .c_dialog_import_progress { border: none; width: 100%; height: 30px; background: #ccc; color: #19ca6c; /\\* IE10、Firefox \\*/ } progress::-moz-progress-bar { background: #19ca6c; } /\\* firefox value \\*/ progress::-webkit-progress-bar { background: #e3e9ee; } progress::-webkit-progress-value { background: #19ca6c; } .c_dialog .c_dialog_footer { padding: 20px 30px; text-align: right; }","categories":[{"name":"Vue","slug":"Vue","permalink":"https://algate.coding.me/categories/Vue/"}],"tags":[{"name":"dialog","slug":"dialog","permalink":"https://algate.coding.me/tags/dialog/"}]},{"title":"JS-http状态码详解","slug":"JS-Http状态码详解","date":"2017-02-12T00:31:30.000Z","updated":"2019-02-27T03:27:59.559Z","comments":true,"path":"2017/02/12/JS-Http状态码详解/","link":"","permalink":"https://algate.coding.me/2017/02/12/JS-Http状态码详解/","excerpt":"1xx消息这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。 这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。100 Continue客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。101 Switching Protocols服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。102 Processing由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。","text":"1xx消息这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。 这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。100 Continue客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。101 Switching Protocols服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。102 Processing由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。2xx成功这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。200 OK请求已成功，请求所希望的响应头或数据体将随此响应返回。201 Created请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回。假如需要的资源无法及时创建的话，应当返回’202 Accepted’。202 Accepted服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。203 Non-Authoritative Information服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。204 No Content服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。205 Reset Content服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。206 Partial Content服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含Range头信息来指示客户端希望得到的内容范围，并且可能包含If-Range来作为请求条件。响应必须包含如下的头部域：Content-Range用以指示本次响应中返回的内容的范围；如果是Content-Type为multipart/byteranges的多段下载，则每一multipart段中都应包含Content-Range域用以指示本段的内容范围。假如响应中包含Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。DateETag和／或Content-Location，假如同样的请求本应该返回200响应。Expires, Cache-Control，和／或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。假如本响应请求使用了If-Range强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了If-Range弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。假如ETag或Last-Modified头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。任何不支持Range以及Content-Range头的缓存都禁止缓存206响应返回的内容。207 Multi-Status由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。3xx重定向这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。当且仅当后续的请求所使用的方法是GET或者HEAD时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A→B→C→……→A或A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照HTTP/1.0版规范的建议，浏览器不应自动访问超过5次的重定向。300 Multiple Choices被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。除非这是一个HEAD请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由Content-Type定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。如果服务器本身已经有了首选的回馈选择，那么在Location中应当指明这个回馈的URI；浏览器可能会将这个Location值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。301 Moved Permanently被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。如果这不是一个GET或者HEAD请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。注意：对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。302 Found请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。303 See Other对应当前请求的响应可以在另一个URI上被找到，而且客户端应当采用GET的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的URI不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。新的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。注意：许多HTTP/1.1版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。304 Not Modified如果客户端发送了一个带条件的GET请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。该响应必须包含以下的头信息：Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将Date字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。ETag和／或Content-Location，假如同样的请求本应返回200响应。Expires, Cache-Control，和／或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的GET请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。305 Use Proxy被请求的资源必须通过指定的代理才能被访问。Location域中将给出指定的代理所在的URI信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能创建305响应。注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器创建。忽视这些限制可能导致严重的安全后果。306 Switch Proxy在最新版的规范中，306状态码已经不再被使用。307 Temporary Redirect请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的URI发出访问请求。如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。4xx客户端错误这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。400 Bad Request由于包含语法错误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。401 Unauthorized当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。客户端可以重复提交一个包含恰当的Authorization头信息的请求。如果当前请求已经包含了Authorization证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。402 Payment Required该状态码是为了将来可能的需求而预留的。403 Forbidden服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。404 Not Found请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。405 Method Not Allowed请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表。鉴于PUT，DELETE方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。406 Not Acceptable请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。除非这是一个HEAD请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由Content-Type头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。407 Proxy Authentication Required与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个Proxy-Authenticate用以进行身份询问。客户端可以返回一个Proxy-Authorization信息头用以验证。参见RFC 2617。408 Request Timeout请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。409 Conflict由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。冲突通常发生于对PUT请求的处理中。例如，在采用版本检查的环境下，某次PUT提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。410 Gone被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。411 Length Required服务器拒绝在没有定义Content-Length头的情况下接受请求。在添加了表明请求消息体长度的有效Content-Length头之后，客户端可以再次提交该请求。412 Precondition Failed服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。413 Request Entity Too Large服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个Retry-After的响应头，以告知客户端可以在多少时间以后重新尝试。414 Request-URI Too Long请求的URI长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。重定向URI“黑洞”，例如每次重定向把旧的URI作为新的URI的一部分，导致在若干次重定向后URI超长。客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的URI，当GET后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。415 Unsupported Media Type对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。416 Requested Range Not Satisfiable如果请求中包含了Range请求头，并且Range中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义If-Range请求头，那么服务器就应当返回416状态码。假如Range使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个Content-Range实体头，用以指明当前资源的长度。这个响应也被禁止使用multipart/byteranges作为其Content-Type。417 Expectation Failed在请求头Expect中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect的内容无法被满足。418 I’m a teapot本操作码是在1998年作为IETF的传统愚人节笑话, 在RFC 2324 超文本咖啡壶控制协议中定义的，并不需要在真实的HTTP服务器中定义。421 There are too many connections from your internet address从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。422 Unprocessable Entity请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked当前资源被锁定。（RFC 4918 WebDAV）424 Failed Dependency由于之前的某个请求发生的错误，导致当前请求失败，例如PROPPATCH。（RFC 4918 WebDAV）425 Unordered Collection在WebDav Advanced Collections草案中定义，但是未出现在《WebDAV顺序集协议》（RFC 3658）中。426 Upgrade Required客户端应当切换到TLS/1.0。（RFC 2817）449 Retry With由微软扩展，代表请求应当在执行完适当的操作后进行重试。5xx服务器错误这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。500 Internal Server Error服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。501 Not Implemented服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。502 Bad Gateway作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。503 Service Unavailable由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个Retry-After头用以标明这个延迟时间。如果没有给出这个Retry-After信息，那么客户端应当以处理500响应的方式处理它。504 Gateway Timeout作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。注意：某些代理服务器在DNS查询超时时会返回400或者500错误。505 HTTP Version Not Supported服务器不支持，或者拒绝支持在请求中使用的HTTP版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。506 Variant Also Negotiates由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。507 Insufficient Storage服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。（WebDAV RFC 4918）509 Bandwidth Limit Exceeded服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。510 Not Extended获取资源所需要的策略并没有被满足。（RFC 2774）","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://algate.coding.me/categories/Javascript/"}],"tags":[{"name":"Http","slug":"Http","permalink":"https://algate.coding.me/tags/Http/"}]},{"title":"前端资源收集整理","slug":"Resources-colection","date":"2017-02-01T10:31:30.000Z","updated":"2019-02-27T03:27:59.615Z","comments":true,"path":"2017/02/01/Resources-colection/","link":"","permalink":"https://algate.coding.me/2017/02/01/Resources-colection/","excerpt":"资源教程综合类前端知识体系前端知识结构Web前端开发大系概览Web前端开发大系概览-中文版Web Front-end Stack v2.2免费的编程中文书籍索引前端书籍前端免费书籍大全前端知识体系","text":"资源教程综合类前端知识体系前端知识结构Web前端开发大系概览Web前端开发大系概览-中文版Web Front-end Stack v2.2免费的编程中文书籍索引前端书籍前端免费书籍大全前端知识体系免费的编程中文书籍索引智能社 - 精通JavaScript开发重新介绍 JavaScript（JS 教程）麻省理工学院公开课：计算机科学及编程导论JavaScript中的this陷阱的最全收集–没有之一JS函数式编程指南JavaScript Promise迷你书（中文版）腾讯移动Web前端知识库Front-End-Develop-Guide 前端开发指南前端开发笔记本大前端工具集 - 聂微东前端开发者手册入门类前端入门教程瘳雪峰的Javascript教程jQuery基础教程前端工程师必备的PS技能——切图篇结合个人经历总结的前端入门方法效果类弹出层焦点图轮播特效工具类css sprite 雪碧图制作版本控制入门 – 搬进 GithubGrunt-beginner前端自动化工具慕课专题张鑫旭 - 慕课系列lyn - 慕课系列艾伦 - 慕课系列碧仔 - Hello，移动WEB周报类平安科技移动开发二队技术周报六. API:1. 总目录开发中心mozilla js参考chrome开发中心（chrome的内核已转向blink）safari开发中心microsoft js参考js秘密花园js秘密花园w3help 综合Bug集合网站综合搜索javascripting各种流行库搜索综合APIrunoob.com-包含各种API集合开源中国在线API文档合集devdocs 英文综合API网站2. jQueryjQuery API 中文文档hemin 在线版css88 jq apicss88 jqui api学习jqueryjquery 源码查找3. EcmascriptUnderstanding ECMAScript 6 - Nicholas C. Zakasexploring-es6exploring-es6翻译exploring-es6翻译后预览阮一峰 es6阮一峰 JavascriptECMA-262，第 5 版es54. Js templatetemplate-chooserartTemplatetomdjs淘宝模板juicer模板Fxtpl v1.0 繁星前端模板引擎laytplmozilla - nunjucksJuicerdustjsetpl5. 弹出层artDialog 最新版artDialog 文档google code 下载地址贤心弹出层响应式用户交互组件库sweetalert-有css3动画弹出层6. CSSCSS 语法参考CSS3动画手册腾讯css3动画制作工具志爷css小工具集合css3 js 移动大杂烩bouncejs 触摸库css3 按钮动画animate.css全局CSS的终结(狗带) [译]7. AngularjsAngular.js 的一些学习资源angularjs中文社区Angularjs源码学习Angularjs源码学习angular对bootstrap的封装angularjs + nodejs吕大豹 AngularjsAngularJS 最佳实践Angular的一些扩展指令Angular数据绑定原理一些扩展Angular UI组件Ember和AngularJS的性能测试带你走近AngularJS - 基本功能介绍Angularjs开发指南Angularjs学习不要带着jQuery的思维去学习AngularJSangularjs 学习笔记angularjs 开发指南angularjs 英文资料angular bootstrapangular jq mobileangular ui整合jQuery Mobile+AngularJS经验谈有jQuery背景，该如何用AngularJS编程思想AngularJS在线教程angular学习笔记8. Reactreact.js 中文论坛react.js 官方网址react.js 官方文档react.js material UIreact.js TouchstoneJS UIreact.js amazeui UIReact 入门实例教程 - 阮一峰React Native 中文版Webpack 和 React 小书 - 前端乱炖Webpack 和 React 小书 - gitbookwebpackWebpack，101入门体验webpack入门教程基于webpack搭建前端工程解决方案探索React原创实战视频教程9. 移动端API99移动端知识集合移动端前端开发知识库移动前端的一些坑和解决方法（外观表现）【原】移动web资源整理zepto 1.0 中文手册zepto 1.0 中文手册zepto 1.1.2zepto 中文注释jqmobile 手册移动浏览器开发集合移动开发大杂烩微信webview中的一些问题框架特色的HTML框架可以创建精美的iOS应用淘宝SUI10. avalonavalonjsAvalon新一代UI库： OniUIavalon.oniui-基于avalon的组件库11. RequriejsJavascript模块化编程（一）：模块的写法Javascript模块化编程（二）：AMD规范Javascript模块化编程（三）：require.js的用法RequireJS入门（一）RequireJS入门（二）RequireJS进阶（三）requrie源码学习requrie 入门指南requrieJS 学习笔记requriejs 其一require backbone结合12. Seajsseajsseajs 中文手册13. Less,sasssasssass教程-sass中国Sass 中文文档less14. MarkdownMarkdown 语法说明 (简体中文版)markdown入门参考gitbook 国外的在线markdown可编辑成书mdeditor 一款国内的在线markdown编辑器stackedit 国外的在线markdown编辑器，功能强大，同步云盘mditor 一款轻量级的markdown编辑器lepture-editormarkdown-editor15. D3d3 TutorialsGallerylofteriteyeruanyifeng16. 兼容性esma 兼容列表W3C CSS验证服务caniusecsscreatormicrosoft在线测兼容-移动端emulators17. UI相关bootcssMetroUICSSsemanticButtonskitecsspintueramazeuiworldhellolinuxtoygitmagicrogerdudlergitrefbookgogojimmy18. HTTPHTTP API 设计指南19. 其它APIjavascript流行库汇总验证apiunderscore 中文手册underscore源码分析underscore源码分析-亚里士朱德的博客underscrejs en apilodash - underscore的代替品ext4apibackbone 中文手册qwrap手册缓动函数svg 中文参考svg mdn参考svg 导出 canvassvg 导出 pngai-to-svglocalStorage 库20. 图表类Highcharts 中文APIHighcharts 英文APIECharts 百度的图表软件高德地图开源的矢量图脚本框架svg 地图21. vueVueVue 论坛Vue 入门指南Vue 的一些资源索引21. 正则JS正则表达式元字符正则表达式30分钟入门教程MDN-正则表达式ruanyifeng - RegExp对象小胡子哥 - 进阶正则表达式is.js正则在线测试22. ionicionic23. 其它Mock.js 是一款模拟数据生成器七. 开发规范前端通过分析github代码库总结出来的工程师代码书写习惯HTML&amp;CSS编码规范 by @mdo团队合作的css命名规范-腾讯AlloyTeam前端团队前端编码规范之js - by yuwenhui前端编码规范之js - by 李靖前端开发规范手册Airbnb JavaScript 编码规范（简体中文版）AMD与CMD规范的区别AMD与CMD规范的区别KISSY 源码规范bt编码规范规范加强版前端代码规范 及 最佳实践百度前端规范百度前端规范百度前端规范ECMAScript6 编码规范–广发证券前端团队JavaScript 风格指南/编码规范（Airbnb公司版）网易前端开发规范css模块前端规范资源列表PHP最流行的PHP 代码规范最流行的PHP 代码规范Android【敏捷开发】Android团队开发规范Android 开发规范与应用八. 其它收集1. 各大公司开源项目Facebook Projects百度web前端研发部百度EFE百度githuballoyteamalloyteam-githuballoyteam-AlloyGameEngineAlloyDesigner 即时修改，即时保存，设计稿较正，其它开发辅助工具H5交互页编辑器AEditor介绍 H5动画交互页开发的工具介绍AEditor H5动画交互页开发的工具maka值得订阅的weekly腾讯html5奇舞团开源项目Qunar UED2. Javascript常用ieBetter.js-让IE6-IE8拥有IE9+,Chrome等浏览器特性模拟键盘拼音中国个人身份证号验证算法数据结构与算法 JavaScript 描述. 章节练习常见排序算法（JS版）经典排序常见排序算法-js版本JavaScript 算法与数据结构 精华集面试常考算法题精讲移动端fastclickno-click-delayJSON模拟生成JSON数据返回跨域JSONAPI3. Html5HTML5 有哪些让你惊艳的 demo？4. CSSbrowserhacks5. jQuery焦点图myfocusmyfocus-官方演示站SuperSlidev2.1 – 大话主席soChange6. Ext, EasyUI, J-UI 及其它各种UI方案Extextjsext4英文apiext4中文apiEasyUIjquery easyui 未压缩源代码J-UIJ-UIOtherMUI-最接近原生APP体验的高性能前端框架Amaze UI | 中国首个开源 HTML5 跨屏前端框架淘宝 HTML5 前端框架KISSY - 阿里前端JavaScript库网易Nej - Nice Easy JavascriptKendo UI MVVM DemoBootstrapSmart UI雅虎UI - CSS UI7. 页面 社会化 分享功能百度分享 pc端JiaThis pc端社会化分享组件 移动端ShareSDK 轻松实现社会化功能 移动端友盟分享 移动端8. 富文本编辑器百度 ueditor经典的ckeditor经典的kindeditorwysiwyg一个有情怀的编辑器。Bach’s Editortower用的编辑器summernote 编辑器html5编辑器XEditorwangEditor9. 日历PC经典my97强大的独立日期选择器fullcalendarfullcalendar日历控件知识点集合中文api农历日历超酷的仿百度带节日日历老黄历控件日期格式化大牛日历控件我群某管理作品input按位替换-官网input按位替换-githubbootstrap-daterangepicker国外30个插件集合JavaScript datepickerDatepair.js一个风格多样的日历弹出层式的全日历jquery双日历移动大气实用jQuery手机移动端日历日期选择插件jQuery Mobile 移动开发中的日期插件MobiscrollDate libraryDatejssugarjs10. 综合效果搜索平台效果网17素材常用的JavaScript代码片段11. 前端工程化概述前端工具大全什么是前端工程化GulpGulp官网Gulp中文网gulp资料收集Gulp：任务自动管理工具 - ruanyifengGulp插件Gulp不完全入门教程为什么使用gulp?Gulp安装及配合组件构建前端开发一体化Gulp 入门指南Gulp 入门指南 - nimojsGulp入门教程Gulp in ActionGulp开发教程（翻译）前端构建工具gulpjs的使用介绍及技巧GruntgruntjsGrunt中文网Fisfis 官网fis12. 轮播图pc图轮单屏轮播sochange左右按钮多图切换fullpage全屏轮播移动端无缝切换滑屏效果全屏fullpage单个图片切换单个全屏切换百度的切换库单个全屏切换滑屏效果旋转拖动设置类似于swipe切换支持多种形式的触摸滑动滑屏效果大话主席pc移动图片轮换滑屏效果基于zepto的fullpage[WebApp]定宽网页设计下，固定宽度布局开发WebApp并实现多终端下WebApp布局自适应判断微信客户端的那些坑可以通过javascript直接调用原生分享的工具JiaThis 分享到微信代码聊聊移动端跨平台开发的各种技术前端自动化测试多种轮换图片滑动侧边栏13. 文件上传百度上传组件上传flash 头像上传图片上传预览图片裁剪图片裁剪-shearphotojQuery图片处理14. 模拟select糖饼 selectflexselect双selectselect215. 取色插件类似 Photoshop 的界面取色插件jquery color取色插件集合farbtastic 圆环＋正方形16. 城市联动jquery.cityselect.js基于jQuery+JSON的省市或自定义联动效果17. 剪贴板剪贴板clipboard 最新的剪切方案不是Flash的剪贴板18. 简繁转换简繁转换19. 表格 Gridfacebook表格类似于Excel编辑表格-handsontablebootstrap-table插件datatables20. 在线演示js 在线编辑 - runjsjs 在线编辑 - jsbinjs 在线编辑 - codepenjs 在线编辑 - jsfiddlejava 在线编辑 - runjsjs 在线编辑 - hchartsjs 在线编辑 - jsdmsql 在线编辑 - sqlfiddlemozilla 在线编辑器21. 播放器Html5 VideoPlayer22. 粒子动画Proton 烟花九. Nodejsnodejs 篇幅比较巨大Node.js 包教不包会篇幅比较少node express 入门教程nodejs定时任务一个nodejs博客【NodeJS 学习笔记04】新闻发布系统过年7天乐，学nodejs 也快乐七天学会NodeJSNodejs学习笔记（二）— 事件模块nodejs入门angularjs nodejs从零开始nodejs系列文章理解nodejsnodejs事件轮询node入门nodejs cmsNode初学者入门，一本全面的NodeJS教程NodeJS的代码调试和性能调优十. 性能优化常规优化Javascript高性能动画与页面渲染移动H5前端性能优化指南5173首页前端性能优化实践给网页设计师和前端开发者看的前端性能优化复杂应用的 CSS 性能分析和优化建议张鑫旭——前端性能前端性能监控总结网站性能优化之CSS无图片技术web前端性能优化进阶路前端技术：网站性能优化之CSS无图片技术浏览器的加载与页面性能优化页面加载中的图片性能优化Hey——前端性能html优化99css——性能Yslow——性能优化YSLOW中文介绍转一篇Yahoo关于网站性能优化的文章，兼谈本站要做的优化Yahoo!团队实践分享：网站性能网站性能优化指南：什么使我们的网站变慢？网站性能优化实践，减少加载时间，提高用户体验浅谈网站性能优化 前端篇前端重构实践之如何对网站性能优化？前端性能优化：使用媒体查询加载指定大小的背景图片网站性能系列博文加载，不只是少一点点前端性能的测试与优化分享网页加载速度优化的一些技巧？页面加载中的图片性能优化web前端优化(基于Yslow)网站性能优化工具大全【高性能前端1】高性能HTML【高性能前端2】高性能CSS由12306谈谈网站前端性能和后端性能优化AlloyTeam——前端优化毫秒必争，前端网页性能最佳实践网站性能工具Yslow的使用方法前端工程与性能优化（上）：静态资源版本更新与缓存前端工程与性能优化（下）：静态资源管理与模板框架HTTPS连接的前几毫秒发生了什么YslowEssential Web Performance Metrics — A Primer, Part 1Essential Web Performance Metrics — Part 2YUISlide,针对移动设备的动画性能优化Improving Site Performance让网站提速的最佳前端实践Why Website Speed is ImportantNeed for Speed – How to Improve your Website Performance阿里无线前端性能优化指南 (Pt.1 加载期优化)优化工具JavaScript 性能分析新工具 OneProfileJavaScript 堆内存分析新工具 OneHeap在线工具google在线工具阿里测阿里-免费测试服务阿里-F2etest多浏览器兼容性测试解决方案js性能测试十一. 前端架构技术架构前端架构如何成为前端架构师关于前端架构-张克军百度腾讯offer比较（腾讯游戏VS百度基础架构）十二. 个人作品1. 推荐作品winter代码片段需要翻墙fgm岑安作品集当耐特demo集合米空格 js作品myFocusSeaJS组件库颜海镜作品脚儿网作品javascript个人作品妙味的雷东升游戏作品javascript作品集云五笔，灰度产生生成工具项目主页个性的作品主页播放器ucren js demos 集智能社实例陈列架zoye demo王员外平凡jyg 游戏案例很多jquery插件不羁虫 - soJs 作品系列frozenui黑白棋fromone2. 群员作品MDialog - [合肥-M.J]轮播图 - [上海－冷静][广州—坚壳][成都 - 无痕] 感恩节专题[球霸天][北京-小数][ptf] Magix 工具[杭州-Pft] Magix 基于 MVC 结构和 Hash 驱动的 OPOA（One Page One Application）应用[上海-剧中人]-实验室[上海-豪情 ] 作品集合[成都-feeling][上海-angela][海南-hank]作品[上海-张力]博客[上海-zenki]作品移动端图案解锁[合肥-M.J] - MPreview 移动端图片预览组[合肥-M.J] - Mexam 移动端在线做题组[北京-苏瑞] - dancer小人[上海-玄沐]- 个人网站[厦门-二哲]- 个人博客3. 国外大牛精品pazguille十三. 简历模板不错的个人简历简历张伦简历翁天信动画方式的简历组件丰富简历简历池haorooms博客Justin Young十四. 面试题那几个月在找工作（百度，网易游戏）2014最新面试题阿里前端面试题2016校招内推 – 阿里巴巴前端 – 三面面试经历腾讯面试题年后跳槽那点事：乐视+金山+360面试之行阿里前端面试题上线拉勾网js面试题前端面试Web开发笔试面试题 大全前端开发面试题2014最新前端面试题百度面试面试题前端工作面试问题前端开发面试题5个经典的前端面试问题最全前端面试问题及答案总结如何面试一名前端开发工程师？史上最全 前端开发面试问题及答案整理前端实习生面试总结史上最全 前端开发面试问题及答案整理BAT及各大互联网公司2014前端笔试面试题：JavaScript篇前端开发面试题大收集收集的前端面试题和答案如何面试前端工程师前端开发面试题牛客网-笔试面经十五. iconfont中文字体淘宝字库字体制作教程zhangxinxu-icommonicommon用字体在网页中画ICON图标(推荐教程)字体压缩工具 感谢初级群 [深圳-小鱼] 的推荐十六. 开发工具类前端开发工具IntelliJ IDEA 简体中文专题教程Webstorm,InterllIdea,PhpstormSublimeTextAtomvisual studio codeChrome, Firebug, Filddle 调试FiddlerFiddler调式使用知多少(一)深入研究微信fiddle微信fiddleChromeGoogle Chrome 官方Chrome - 基础Chrome - 进阶Chrome - 性能Chrome - 性能进阶Chrome - 移动Chrome - 使用技巧Chrome - Console控制台不完全指南Chrome - Workspace使浏览器变成IDEnetwork面板chrome开发工具快捷键chrome调试工具常用功能整理Chrome 开发工具 Workspace 使用Chrome神器Vimium快捷键学习记录sass调试-w3cplus如何更专业的使用Chrome开发者工具-w3cpluschrome调试canvaschrome profiles1chrome profiles2chrome profiles3chrome移动版调试chrome调试chrome的调试chrome console 命令详解查看事件绑定1查看事件绑定2神器——Chrome开发者工具(一)奇趣百科性能优化(Chrome DevTools 中的 Timeline Profils 等工具使用介绍)chrome 开发者工具的 15 个小技巧Chrome开发者工具不完全指南Chrome 开发者工具使用技巧Firebugfirebug视频教程firefox 模拟器console.log 命令详解Firebug入门指南Firebug控制台详解移动,微信调试浏览器端调试安卓移动端前端开发调试使用 Chrome 远程调试 Android 设备mac移动端调试mac移动端调试无线调试攻略无线调试攻略屌爆了,完美调试 微信webview(x5)微信调试的那些事远程console微信调试工具各种真机远程调试方法汇总iOS SimulatorSimulatorXcode中的iOS模拟器(iOS Simulator)的介绍和使用心得imgloading img智图-图片优化平台在线png优化生成二维码生成二维码浏览器同步puerliveReloadf5File Watchers在线PPT制作nodePPTPPTrevealslippy十七. 前端导航网站界面清爽的前端导航前端导航前端网址导航前端名录前端导航前端开发资源网址导航前端开发仓库 - 众多效果的收集地前端资源导航F2E 前端导航十八. 常用CDN新浪CDN百度静态资源公共库360网站卫士常用前端公共库CDN服务Bootstrap中文网开源项目免费 CDN 服务开放静态文件 CDN - 七牛CDN加速 - jq22jQuery CDNGoogle jQuery CDN微软CDN十九. Git,SVN,GithubGitgit-scm廖雪峰-Git教程git-for-windowsGitHub 添加 SSH keysgogithubgit常规命令练习git的资料整理我所记录的git命令（非常实用）企业开发git工作流模式探索部分休整GitHub 漫游指南GitHub秘籍使用git和github进行协同开发流程动画方式练习git原文地址:https://cnodejs.org/topic/56ef3edd532839c33a99d00e来自CNode社区的大神i5ting的收集，mark以后，果断搬过来。","categories":[{"name":"前端资源","slug":"前端资源","permalink":"https://algate.coding.me/categories/前端资源/"}],"tags":[{"name":"前端资源","slug":"前端资源","permalink":"https://algate.coding.me/tags/前端资源/"}]},{"title":"雅虎前端优化的35条军规","slug":"optimize-雅虎前端优化的35条军规","date":"2017-01-04T00:31:30.000Z","updated":"2019-02-27T03:27:59.649Z","comments":true,"path":"2017/01/04/optimize-雅虎前端优化的35条军规/","link":"","permalink":"https://algate.coding.me/2017/01/04/optimize-雅虎前端优化的35条军规/","excerpt":"雅虎前端优化的35条军规：可以大量借鉴使用阅读目录内容部分css部分js部分javascript, css图片cookie移动端服务器","text":"雅虎前端优化的35条军规：可以大量借鉴使用阅读目录内容部分css部分js部分javascript, css图片cookie移动端服务器摘要：无论是在工作中，还是在面试中，web前端性能的优化都是很重要的，那么我们进行优化需要从哪些方面入手呢？可以遵循雅虎的前端优化34条军规，不过现在已经是35条了，所以可以说是雅虎前端优化的35条军规。已分类，挺好的，这样对于优化有一个比较清晰的方向回到顶部内容部分1.尽量减少HTTP请求数80%的终端用户响应时间都花在了前端上，其中大部分时间都在下载页面上的各种组件：图片，样式表，脚本，Flash等等。减少组件数必然能够减少页面提交的HTTP请求数。这是让页面更快的关键。减少页面组件数的一种方式是简化页面设计。但有没有一种方法可以在构建复杂的页面同时加快响应时间呢？嗯，确实有鱼和熊掌兼得的办法。合并文件是通过把所有脚本放在一个文件中的方式来减少请求数的，当然，也可以合并所有的CSS。如果各个页面的脚本和样式不一样的话，合并文件就是一项比较麻烦的工作了，但把这个作为站点发布过程的一部分确实可以提高响应时间。CSS Sprites是减少图片请求数量的首选方式。把背景图片都整合到一张图片中，然后用CSS的background-image和background-position属性来定位要显示的部分。图像映射可以把多张图片合并成单张图片，总大小是一样的，但减少了请求数并加速了页面加载。图片映射只有在图像在页面中连续的时候才有用，比如导航条。给image map设置坐标的过程既无聊又容易出错，用image map来做导航也不容易，所以不推荐用这种方式。行内图片（Base64编码）用data: URL模式来把图片嵌入页面。这样会增加HTML文件的大小，把行内图片放在（缓存的）样式表中是个好办法，而且成功避免了页面变“重”。但目前主流浏览器并不能很好地支持行内图片。减少页面的HTTP请求数是个起点，这是提升站点首次访问速度的重要指导原则。2.减少DNS查找域名系统建立了主机名和IP地址间的映射，就像电话簿上人名和号码的映射一样。当你在浏览器输入www.yahoo.com的时候，浏览器就会联系DNS解析器返回服务器的IP地址。DNS是有成本的，它需要20到120毫秒去查找给定主机名的IP地址。在DNS查找完成之前，浏览器无法从主机名下载任何东西。DNS查找被缓存起来更高效，由用户的ISP（网络服务提供商）或者本地网络存在一个特殊的缓存服务器上，但还可以缓存在个人用户的计算机上。DNS信息被保存在操作系统的DNS cache(微软Windows上的”DNS客户端服务”)里。大多数浏览器有独立于操作系统的自己的cache。只要浏览器在自己的cache里还保留着这条记录，它就不会向操作系统查询DNS。IE默认缓存DNS查找30分钟，写在DnsCacheTimeout注册表设置中。Firefox缓存1分钟，可以用network.dnsCacheExpiration配置项设置。(Fasterfox把缓存时间改成了1小时 P.S. Fasterfox是FF的一个提速插件)如果客户端的DNS cache是空的（包括浏览器的和操作系统的），DNS查找数等于页面上不同的主机名数，包括页面URL，图片，脚本文件，样式表，Flash对象等等组件中的主机名，减少不同的主机名就可以减少DNS查找。减少不同主机名的数量同时也减少了页面能够并行下载的组件数量，避免DNS查找削减了响应时间，而减少并行下载数量却增加了响应时间。我的原则是把组件分散在2到4个主机名下，这是同时减少DNS查找和允许高并发下载的折中方案。3.避免重定向重定向用301和302状态码，下面是一个有301状态码的HTTP头：HTTP/1.1 301 Moved PermanentlyLocation: http://example.com/newuriContent-Type: text/html浏览器会自动跳转到Location域指明的URL。重定向需要的所有信息都在HTTP头部，而响应体一般是空的。其实额外的HTTP头，比如Expires和Cache-Control也表示重定向。除此之外还有别的跳转方式：refresh元标签和JavaScript，但如果你必须得做重定向，最好用标准的3xxHTTP状态码，主要是为了让返回按钮能正常使用。牢记重定向会拖慢用户体验，在用户和HTML文档之间插入重定向会延迟页面上的所有东西，页面无法渲染，组件也无法开始下载，直到HTML文档被送达浏览器。有一种常见的极其浪费资源的重定向，而且web开发人员一般都意识不到这一点，就是URL尾部缺少一个斜线的时候。例如，跳转到http://astrology.yahoo.com/astrology会返回一个重定向到http://astrology.yahoo.com/astrology/的301响应（注意添在尾部的斜线）。在Apache中可以用Alias，mod_rewrite或者DirectorySlash指令来取消不必要的重定向。重定向最常见的用途是把旧站点连接到新的站点，还可以连接同一站点的不同部分，针对用户的不同情况（浏览器类型，用户帐号类型等等）做一些处理。用重定向来连接两个网站是最简单的，只需要少量的额外代码。虽然在这些时候使用重定向减少了开发人员的开发复杂度，但降低了用户体验。一种替代方案是用Alias和mod_rewrite，前提是两个代码路径都在相同的服务器上。如果是因为域名变化而使用了重定向，就可以创建一条CNAME（创建一个指向另一个域名的DNS记录作为别名）结合Alias或者mod_rewrite指令。4.让Ajax可缓存Ajax的一个好处是可以给用户提供即时反馈，因为它能够从后台服务器异步请求信息。然而，用了Ajax就无法保证用户在等待异步JavaScript和XML响应返回期间不会非常无聊。在很多应用程序中，用户能够一直等待取决于如何使用Ajax。例如，在基于web的电子邮件客户端中，用户为了寻找符合他们搜索标准的邮件消息，将会保持对Ajax请求返回结果的关注。重要的是，要记得“异步”并不意味着“即时”。要提高性能，优化这些Ajax响应至关重要。最重要的提高Ajax性能的方法就是让响应变得可缓存，就像在添上Expires或者Cache-Control HTTP头中讨论的一样。下面适用于Ajax的其它规则：Gzip组件减少DNS查找压缩JavaScript避免重定向配置ETags我们一起看看例子，一个Web 2.0的电子邮件客户端用了Ajax来下载用户的通讯录，以便实现自动完成功能。如果用户从上一次使用之后再没有修改过她的通讯录，而且Ajax响应是可缓存的，有尚未过期的Expires或者Cache-Control HTTP头，那么之前的通讯录就可以从缓存中读出。必须通知浏览器，应该继续使用之前缓存的通讯录响应，还是去请求一个新的。可以通过给通讯录的Ajax URL里添加一个表明用户通讯录最后修改时间的时间戳来实现，例如&amp;t=1190241612。如果通讯录从上一次下载之后再没有被修改过，时间戳不变，通讯录就将从浏览器缓存中直接读出，从而避免一次额外的HTTP往返消耗。如果用户已经修改了通讯录，时间戳也可以确保新的URL不会匹配缓存的响应，浏览器将请求新的通讯录条目。即使Ajax响应是动态创建的，而且可能只适用于单用户，它们也可以被缓存，而这样会让你的Web 2.0应用更快。5.延迟加载组件可以凑近看看页面并问自己：什么才是一开始渲染页面所必须的？其余内容都可以等会儿。JavaScript是分隔onload事件之前和之后的一个理想选择。例如，如果有JavaScript代码和支持拖放以及动画的库，这些都可以先等会儿，因为拖放元素是在页面最初渲染之后的。其它可以延迟加载的部分包括隐藏内容（在某个交互动作之后才出现的内容）和折叠的图片。工具可帮你减轻工作量：YUI Image Loader可以延迟加载折叠的图片，还有YUI Get utility是一种引入JS和CSS的简单方法。Yahoo!主页就是一个例子，可以打开Firebug的网络面板仔细看看。最好让性能目标符合其它web开发最佳实践，比如“渐进增强”。如果客户端支持JavaScript，可以提高用户体验，但必须确保页面在不支持JavaScript时也能正常工作。所以，在确定页面运行正常之后，可以用一些延迟加载脚本增强它，以支持一些拖放和动画之类的华丽效果。6.预加载组件预加载可能看起来和延迟加载是相反的，但它其实有不同的目标。通过预加载组件可以充分利用浏览器空闲的时间来请求将来会用到的组件（图片，样式和脚本）。用户访问下一页的时候，大部分组件都已经在缓存里了，所以在用户看来页面会加载得更快。实际应用中有以下几种预加载的类型：无条件预加载——尽快开始加载，获取一些额外的组件。google.com就是一个sprite图片预加载的好例子，这个sprite图片并不是google.com主页需要的，而是搜索结果页面上的内容。条件性预加载——根据用户操作猜测用户将要跳转到哪里并据此预加载。在search.yahoo.com的输入框里键入内容后，可以看到那些额外组件是怎样请求加载的。提前预加载——在推出新设计之前预加载。经常在重新设计之后会听到：“这个新网站不错，但比以前更慢了”，一部分原因是用户访问先前的页面都是有旧缓存的，但新的却是一种空缓存状态下的体验。可以通过在将要推出新设计之前预加载一些组件来减轻这种负面影响，老站可以利用浏览器空闲的时间来请求那些新站需要的图片和脚本。7.减少DOM元素的数量一个复杂的页面意味着要下载更多的字节，而且用JavaScript访问DOM也会更慢。举个例子，想要添加一个事件处理器的时候，循环遍历页面上的500个DOM元素和5000个DOM元素是有区别的。大量的DOM元素是一种征兆——页面上有些内容无关的标记需要清理。正在用嵌套表格来布局吗？还是为了修复布局问题而添了一堆的s？或许应该用更好的语义化标记。YUI CSS utilities对布局有很大帮助：grids.css针对整体布局，fonts.css和reset.css可以用来去除浏览器的默认格式。这是个开始清理和思考标记的好机会，例如只在语义上有意义的时候使用，而不是因为它能够渲染一个新行。DOM元素的数量很容易测试，只需要在Firebug的控制台里输入：document.getElementsByTagName(‘*’).length那么多少DOM元素才算是太多呢？可以参考其它类似的标记良好的页面，例如Yahoo!主页是一个相当繁忙的页面，但只有不到700个元素（HTML标签）。8.跨域分离组件分离组件可以最大化并行下载，但要确保只用不超过2-4个域，因为存在DNS查找的代价。例如，可以把HTML和动态内容部署在www.example.org，而把静态组件分离到static1.example.org和static2.example.org。9.尽量少用iframe用iframe可以把一个HTML文档插入到父文档里，重要的是明白iframe是如何工作的并高效地使用它。的优点：引入缓慢的第三方内容，比如标志和广告安全沙箱并行下载脚本的缺点：代价高昂，即使是空白的iframe阻塞页面加载非语义10.杜绝404HTTP请求代价高昂，完全没有必要用一个HTTP请求去获取一个无用的响应（比如404 Not Found），只会拖慢用户体验而没有任何好处。有些站点用的是有帮助的404——“你的意思是xxx？”，这样做有利于用户体验，，但也浪费了服务器资源（比如数据库等等）。最糟糕的是链接到的外部JavaScript有错误而且结果是404。首先，这种下载将阻塞并行下载。其次，浏览器会试图解析404响应体，因为它是JavaScript代码，需要找出其中可用的部分。回到顶部css部分11.避免使用CSS表达式用CSS表达式动态设置CSS属性，是一种强大又危险的方式。从IE5开始支持，但从IE8起就不推荐使用了。例如，可以用CSS表达式把背景颜色设置成按小时交替的：1background-color: expression( (new Date()).getHours()%2 ? “#B8D4FF” : “#F08A00” );12.选择舍弃@import前面提到了一个最佳实践：为了实现逐步渲染，CSS应该放在顶部。在IE中用@import与在底部用效果一样，所以最好不要用它。13.避免使用滤镜IE专有的AlphaImageLoader滤镜可以用来修复IE7之前的版本中半透明PNG图片的问题。在图片加载过程中，这个滤镜会阻塞渲染，卡住浏览器，还会增加内存消耗而且是被应用到每个元素的，而不是每个图片，所以会存在一大堆问题。最好的方法是干脆不要用AlphaImageLoader，而优雅地降级到用在IE中支持性很好的PNG8图片来代替。如果非要用AlphaImageLoader，应该用下划线hack：_filter来避免影响IE7及更高版本的用户。14.把样式表放在顶部在Yahoo!研究性能的时候，我们发现把样式表放到文档的HEAD部分能让页面看起来加载地更快。这是因为把样式表放在head里能让页面逐步渲染。关注性能的前端工程师想让页面逐步渲染。也就是说，我们想让浏览器尽快显示已有内容，这在页面上有一大堆内容或者用户网速很慢时显得尤为重要。给用户显示反馈（比如进度指标）的重要性已经被广泛研究过，并且被记录下来了。在我们的例子中，HTML页面就是进度指标！当浏览器逐渐加载页面头部，导航条，顶部logo等等内容的时候，这些都被正在等待页面加载的用户当作反馈，能够提高整体用户体验。回到顶部js部分15.去除重复脚本页面含有重复的脚本文件会影响性能，这可能和你想象的不一样。在对美国前10大web站点的评审中，发现只有2个站点含有重复脚本。两个主要原因增加了在单一页面中出现重复脚本的几率：团队大小和脚本数量。在这种情况下，重复脚本会创建不必要的HTTP请求，执行无用的JavaScript代码，而影响页面性能。IE会产生不必要的HTTP请求，而Firefox不会。在IE中，如果一个不可缓存的外部脚本被页面引入了两次，它会在页面加载时产生两个HTTP请求。即使脚本是可缓存的，在用户重新加载页面时也会产生额外的HTTP请求。除了产生没有意义的HTTP请求之外，多次对脚本求值也会浪费时间。因为无论脚本是否可缓存，在Firefox和IE中都会执行冗余的JavaScript代码。避免不小心把相同脚本引入两次的一种方法就是在模版系统中实现脚本管理模块。典型的脚本引入方法就是在HTML页面中用SCRIPT标签：116.尽量减少DOM访问用JavaScript访问DOM元素是很慢的，所以，为了让页面反应更迅速，应该：缓存已访问过的元素的索引先“离线”更新节点，再把它们添到DOM树上避免用JavaScript修复布局问题17.用智能的事件处理器有时候感觉页面反映不够灵敏，是因为有太多频繁执行的事件处理器被添加到了DOM树的不同元素上，这就是推荐使用事件委托的原因。如果一个div里面有10个按钮，应该只给div容器添加一个事件处理器，而不是给每个按钮都添加一个。事件能够冒泡，所以可以捕获事件并得知哪个按钮是事件源。18.把脚本放在底部脚本会阻塞并行下载，HTTP/1.1官方文档建议浏览器每个主机名下并行下载的组件数不要超过两个，如果图片来自多个主机名，并行下载的数量就可以超过两个。如果脚本正在下载，浏览器就不开始任何其它下载任务，即使是在不同主机名下的。有时候，并不容易把脚本移动到底部。举个例子，如果脚本是用document.write插入到页面内容中的，就没办法再往下移了。还可能存在作用域问题，在多数情况下，这些问题都是可以解决的。一个常见的建议是用推迟（deferred）脚本，有DEFER属性的脚本意味着不能含有document.write，并且提示浏览器告诉他们可以继续渲染。不幸的是，Firefox不支持DEFER属性。在IE中，脚本可能被推迟，但不尽如人意。如果脚本可以推迟，我们就可以把它放到页面底部，页面就可以更快地载入。回到顶部javascript, css19.把JavaScript和CSS放到外面很多性能原则都是关于如何管理外部组件的，然而，在这些顾虑出现之前你应该问一个更基础的问题：应该把JavaScript和CSS放到外部文件中还是直接写在页面里？实际上，用外部文件可以让页面更快，因为JavaScript和CSS文件会被缓存在浏览器。HTML文档中的行内JavaScript和CSS在每次请求该HTML文档的时候都会重新下载。这样做减少了所需的HTTP请求数，但增加了HTML文档的大小。另一方面，如果JavaScript和CSS在外部文件中，并且已经被浏览器缓存起来了，那么我们就成功地把HTML文档变小了，而且还没有增加HTTP请求数。20.压缩JavaScript和CSS压缩具体来说就是从代码中去除不必要的字符以减少大小，从而提升加载速度。代码最小化就是去掉所有注释和不必要的空白字符（空格，换行和tab）。在JavaScript中这样做能够提高响应性能，因为要下载的文件变小了。两个最常用的JavaScript代码压缩工具是JSMin和YUI Compressor，YUI compressor还可以压缩CSS。混淆是一种可选的源码优化措施，要比压缩更复杂，所以混淆过程也更容易产生bug。在对美国前十的网站调查中，压缩可以缩小21%，而混淆能缩小25%。虽然混淆的缩小程度更高，但比压缩风险更大。除了压缩外部脚本和样式，行内的和块也可以压缩。即使启用了gzip模块，先进行压缩也能够缩小5%或者更多的大小。JavaScript和CSS的用处越来越多，所以压缩代码会有不错的效果。 回到顶部图片 21.优化图片 尝试把GIF格式转换成PNG格式，看看是否节省空间。在所有的PNG图片上运行pngcrush（或者其它PNG优化工具） 22.优化CSS Sprite 在Sprite图片中横向排列一般都比纵向排列的最终文件小组合Sprite图片中的相似颜色可以保持低色数，最理想的是256色以下PNG8格式“对移动端友好”，不要在Sprite图片中留下太大的空隙。虽然不会在很大程度上影响图片文件的大小，但这样做可以节省用户代理把图片解压成像素映射时消耗的内存。100×100的图片是1万个像素，而1000×1000的图片就是100万个像素了。 23.不要用HTML缩放图片 不要因为在HTML中可以设置宽高而使用本不需要的大图。如果需要 1 那么图片本身（mycat.jpg）应该是100x100px的，而不是去缩小500x500px的图片。 24.用小的可缓存的favicon.ico（P.S. 收藏夹图标） favicon.ico是放在服务器根目录的图片，它会带来一堆麻烦，因为即便你不管它，浏览器也会自动请求它，所以最好不要给一个404 Not Found响应。而且只要在同一个服务器上，每次请求它时都会发送cookie，此外这个图片还会干扰下载顺序，例如在IE中，当你在onload中请求额外组件时，将会先下载favicon。 所以为了缓解favicon.ico的缺点，应该确保： 足够小，最好在1K以下设置合适的有效期HTTP头（以后如果想换的话就不能重命名了），把有效期设置为几个月后一般比较安全，可以通过检查当前favicon.ico的最后修改日期来确保变更能让浏览器知道。 回到顶部 cookie 25.给Cookie减肥 使用cookie的原因有很多，比如授权和个性化。HTTP头中cookie信息在web服务器和浏览器之间交换。重要的是保证cookie尽可能的小，以最小化对用户响应时间的影响。 清除不必要的cookie保证cookie尽可能小，以最小化对用户响应时间的影响注意给cookie设置合适的域级别，以免影响其它子域设置合适的有效期，更早的有效期或者none可以更快的删除cookie，提高用户响应时间 26.把组件放在不含cookie的域下 当浏览器发送对静态图像的请求时，cookie也会一起发送，而服务器根本不需要这些cookie。所以它们只会造成没有意义的网络通信量，应该确保对静态组件的请求不含cookie。可以创建一个子域，把所有的静态组件都部署在那儿。 如果域名是www.example.org，可以把静态组件部署到static.example.org。然而，如果已经在顶级域example.org或者www.example.org设置了cookie，那么所有对static.example.org的请求都会含有这些cookie。这时候可以再买一个新域名，把所有的静态组件部署上去，并保持这个新域名不含cookie。Yahoo!用的是yimg.com，YouTube是ytimg.com，Amazon是images-amazon.com等等。 把静态组件部署在不含cookie的域下还有一个好处是有些代理可能会拒绝缓存带cookie的组件。有一点需要注意：如果不知道应该用example.org还是www.example.org作为主页，可以考虑一下cookie的影响。省略www的话，就只能把cookie写到*.example.org，所以因为性能原因最好用www子域，并且把cookie写到这个子域下。 回到顶部移动端 27.保证所有组件都小于25K 这个限制是因为iPhone不能缓存大于25K的组件，注意这里指的是未压缩的大小。这就是为什么缩减内容本身也很重要，因为单纯的gzip可能不够。 28.把组件打包到一个复合文档里 把各个组件打包成一个像有附件的电子邮件一样的复合文档里，可以用一个HTTP请求获取多个组件（记住一点：HTTP请求是代价高昂的）。用这种方式的时候，要先检查用户代理是否支持（iPhone就不支持）。 回到顶部服务器 29.Gzip组件 前端工程师可以想办法明显地缩短通过网络传输HTTP请求和响应的时间。毫无疑问，终端用户的带宽速度，网络服务商，对等交换点的距离等等，都是开发团队所无法控制的。但还有别的能够影响响应时间的因素，压缩可以通过减少HTTP响应的大小来缩短响应时间。 从HTTP/1.1开始，web客户端就有了支持压缩的Accept-Encoding HTTP请求头。 1Accept-Encoding: gzip, deflate 如果web服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web服务器通过Content-Encoding相应头来通知客户端。 1Content-Encoding: gzip 尽可能多地用gzip压缩能够给页面减肥，这也是提升用户体验最简单的方法。 30.避免图片src属性为空 Image with empty string src属性是空字符串的图片很常见，主要以两种形式出现： straight HTMLJavaScriptvar img = new Image();img.src = “”;这两种形式都会引起相同的问题：浏览器会向服务器发送另一个请求。 31.配置ETags 实体标签（ETags），是服务器和浏览器用来决定浏览器缓存中组件与源服务器中的组件是否匹配的一种机制（“实体”也就是组件：图片，脚本，样式表等等）。添加ETags可以提供一种实体验证机制，比最后修改日期更加灵活。一个ETag是一个字符串，作为一个组件某一具体版本的唯一标识符。唯一的格式约束是字符串必须用引号括起来，源服务器用相应头中的ETag来指定组件的ETag： 1234HTTP/1.1 200 OK Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT ETag: “10c24bc-4ab-457e1c1f” Content-Length: 12195 然后，如果浏览器必须验证一个组件，它用If-None-Match请求头来把ETag传回源服务器。如果ETags匹配成功，会返回一个304状态码，这样就减少了12195个字节的响应体。 GET /i/yahoo.gif HTTP/1.1 Host: us.yimg.com If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT If-None-Match: “10c24bc-4ab-457e1c1f” HTTP/1.1 304 Not Modified 32.对Ajax用GET请求 Yahoo!邮箱团队发现使用XMLHttpRequest时，浏览器的POST请求是通过一个两步的过程来实现的：先发送HTTP头，在发送数据。所以最好用GET请求，它只需要发送一个TCP报文（除非cookie特别多）。IE的URL长度最大值是2K，所以如果要发送的数据超过2K就无法使用GET了。 POST请求的一个有趣的副作用是实际上没有发送任何数据，就像GET请求一样。正如HTTP说明文档中描述的，GET请求是用来检索信息的。所以它的语义只是用GET请求来请求数据，而不是用来发送需要存储到服务器的数据。 33.尽早清空缓冲区 当用户请求一个页面时，服务器需要用大约200到500毫秒来组装HTML页面，在这期间，浏览器闲等着数据到达。PHP中有一个flush()函数，允许给浏览器发送一部分已经准备完毕的HTML响应，以便浏览器可以在后台准备剩余部分的同时开始获取组件，好处主要体现在很忙的后台或者很“轻”的前端页面上（P.S. 也就是说，响应时耗主要在后台方面时最能体现优势）。 较理想的清空缓冲区的位置是HEAD后面，因为HTML的HEAD部分通常更容易生成，并且允许引入任何CSS和JavaScript文件，这样就可以让浏览器在后台还在处理的时候就开始并行获取组件。 例如： … &lt;?php flush(); ?&gt; … 34.使用CDN（内容分发网络） 用户与服务器的物理距离对响应时间也有影响。把内容部署在多个地理位置分散的服务器上能让用户更快地载入页面。但具体要怎么做呢？ 实现内容在地理位置上分散的第一步是：不要尝试去重新设计你的web应用程序来适应分布式结构。这取决于应用程序，改变结构可能包括一些让人望而生畏的任务，比如同步会话状态和跨服务器复制数据库事务（翻译可能不准确）。缩短用户和内容之间距离的提议可能被推迟，或者根本不可能通过，就是因为这个难题。 记住终端用户80%到90%的响应时间都花在下载页面组件上了：图片，样式，脚本，Flash等等，这是业绩黄金法则。最好先分散静态内容，而不是一开始就重新设计应用程序结构。这不仅能够大大减少响应时间，还更容易表现出CDN的功劳。 内容分发网络（CDN）是一组分散在不同地理位置的web服务器，用来给用户更高效地发送内容。典型地，选择用来发送内容的服务器是基于网络距离的衡量标准的。例如：选跳数（hop）最少的或者响应时间最快的服务器。 35.添上Expires或者Cache-Control HTTP头 这条规则有两个方面： 对于静态组件：通过设置一个遥远的将来时间作为Expires来实现永不失效多余动态组件：用合适的Cache-ControlHTTP头来让浏览器进行条件性的请求 网页设计越来越丰富，这意味着页面里有更多的脚本，图片和Flash。站点的新访客可能还是不得不提交几个HTTP请求，但通过使用有效期能让组件变得可缓存，这避免了在接下来的浏览过程中不必要的HTTP请求。有效期HTTP头通常被用在图片上，但它们应该用在所有组件上，包括脚本、样式和Flash组件。 浏览器（和代理）用缓存来减少HTTP请求的数目和大小，让页面能够更快加载。web服务器通过有效期HTTP响应头来告诉客户端，页面的各个组件应该被缓存多久。用一个遥远的将来时间做有效期，告诉浏览器这个响应在2010年4月15日前不会改变。 1Expires: Thu, 15 Apr 2010 20:00:00 GMT 如果你用的是Apache服务器，用ExpiresDefault指令来设置相对于当前日期的有效期。下面的例子设置了从请求时间起10年的有效期： ExpiresDefault “access plus 10 years”","categories":[{"name":"Js优化","slug":"Js优化","permalink":"https://algate.coding.me/categories/Js优化/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://algate.coding.me/tags/性能优化/"}]},{"title":"JS进阶-浅谈模块化编程(requireJs的用法)","slug":"JS进阶-浅谈模块化编程","date":"2016-12-03T00:31:30.000Z","updated":"2019-02-27T03:27:59.572Z","comments":true,"path":"2016/12/03/JS进阶-浅谈模块化编程/","link":"","permalink":"https://algate.coding.me/2016/12/03/JS进阶-浅谈模块化编程/","excerpt":"目前，通行的Javascript模块规范共有两种：CommonJS和AMD。我主要介绍AMD，但是要先从CommonJS讲起。服务器端模块以后，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。","text":"目前，通行的Javascript模块规范共有两种：CommonJS和AMD。我主要介绍AMD，但是要先从CommonJS讲起。服务器端模块以后，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。一、原始写法模块就是实现特定功能的一组方法。只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。123456 function m1()&#123; //... &#125; function m2()&#123; //... &#125;上面的函数m1()和m2()，组成一个模块。使用的时候，直接调用就行了。这种做法的缺点很明显：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。二、对象写法为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面。123456789 var module1 = new Object(&#123; _count : 0, m1 : function ()&#123; //... &#125;, m2 : function ()&#123; //... &#125; &#125;);上面的函数m1()和m2(），都封装在module1对象里。使用的时候，就是调用这个对象的属性。module1.m1();但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。module1._count = 5;三、立即执行函数写法使用”立即执行函数”（Immediately-Invoked Function Expression，IIFE），可以达到不暴露私有成员的目的。12345678910111213 var module1 = (function()&#123; var _count = 0; var m1 = function()&#123; //... &#125;; var m2 = function()&#123; //... &#125;; return &#123; m1 : m1, m2 : m2 &#125;; &#125;)();使用上面的写法，外部代码无法读取内部的_count变量。console.info(module1._count); //undefinedmodule1就是Javascript模块的基本写法。下面，再对这种写法进行加工。四、放大模式如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用”放大模式”（augmentation）。123456 var module1 = (function (mod)&#123; mod.m3 = function () &#123; //... &#125;; return mod; &#125;)(module1);上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。五、宽放大模式（Loose augmentation）在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”。1234 var module1 = ( function (mod)&#123; //... return mod; &#125;)(window.module1 || &#123;&#125;);与”放大模式”相比，＂宽放大模式＂就是”立即执行函数”的参数可以是空对象。六、输入全局变量独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。为了在模块内部调用全局变量，必须显式地将其他变量输入模块。123 var module1 = (function ($, YAHOO) &#123; //... &#125;)(jQuery, YAHOO);上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。重点说说requireJs的用法：一、为什么要用require.js？最早的时候，所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。下面的网页代码，相信很多人都见过。123456 &lt;script src=&quot;1.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;2.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;3.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;4.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;5.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;6.js&quot;&gt;&lt;/script&gt;这段代码依次加载多个js文件。这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。require.js的诞生，就是为了解决这两个问题：（1）实现js文件的异步加载，避免网页失去响应；（2）管理模块之间的依赖性，便于代码的编写和维护。二、require.js的加载使用require.js的第一步，是先去官方网站下载最新版本。下载后，假定把它放在js子目录下面，就可以加载了。1 &lt;script src=&quot;js/require.js&quot;&gt;&lt;/script&gt;有人可能会想到，加载这个文件，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样：1 &lt;script src=&quot;js/require.js&quot; defer async=&quot;true&quot; &gt;&lt;/script&gt;async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了：1 &lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。三、主模块的写法上一节的main.js，我把它称为”主模块”，意思是整个网页的入口代码。它有点像C语言的main()函数，所有代码都从这儿开始运行。下面就来看，怎么写main.js。如果我们的代码不依赖任何其他模块，那么可以直接写入javascript代码。12 // main.js alert(&quot;加载成功！&quot;);但这样的话，就没必要使用require.js了。真正常见的情况是，主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数。1234 // main.js require([&apos;moduleA&apos;, &apos;moduleB&apos;, &apos;moduleC&apos;], function (moduleA, moduleB, moduleC)&#123; // some code here &#125;);require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’, ‘moduleC’]，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。下面，我们看一个实际的例子。假定主模块依赖jquery、underscore和backbone这三个模块，main.js就可以这样写：123 require([&apos;jquery&apos;, &apos;underscore&apos;, &apos;backbone&apos;], function ($, _, Backbone)&#123; // some code here &#125;);require.js会先加载jQuery、underscore和backbone，然后再运行回调函数。主模块的代码就写在回调函数中。四、模块的加载上一节最后的示例中，主模块的依赖模块是[‘jquery’, ‘underscore’, ‘backbone’]。默认情况下，require.js假定这三个模块与main.js在同一个目录，文件名分别为jquery.js，underscore.js和backbone.js，然后自动加载。使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。1234567 require.config(&#123; paths: &#123; &quot;jquery&quot;: &quot;jquery.min&quot;, &quot;underscore&quot;: &quot;underscore.min&quot;, &quot;backbone&quot;: &quot;backbone.min&quot; &#125; &#125;);上面的代码给出了三个模块的文件名，路径默认与main.js在同一个目录（js子目录）。如果这些模块在其他目录，比如js/lib目录，则有两种写法。一种是逐一指定路径。1234567 require.config(&#123; paths: &#123; &quot;jquery&quot;: &quot;lib/jquery.min&quot;, &quot;underscore&quot;: &quot;lib/underscore.min&quot;, &quot;backbone&quot;: &quot;lib/backbone.min&quot; &#125; &#125;);另一种则是直接改变基目录（baseUrl）。12345678 require.config(&#123; baseUrl: &quot;js/lib&quot;, paths: &#123; &quot;jquery&quot;: &quot;jquery.min&quot;, &quot;underscore&quot;: &quot;underscore.min&quot;, &quot;backbone&quot;: &quot;backbone.min&quot; &#125; &#125;);如果某个模块在另一台主机上，也可以直接指定它的网址，比如：12345 require.config(&#123; paths: &#123; &quot;jquery&quot;: &quot;https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min&quot; &#125; &#125;);require.js要求，每个模块是一个单独的js文件。这样的话，如果加载多个模块，就会发出多次HTTP请求，会影响网页的加载速度。因此，require.js提供了一个优化工具，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数。五、AMD模块的写法require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。假定现在有一个math.js文件，它定义了一个math模块。那么，math.js就要这样写：123456789 // math.js define(function ()&#123; var add = function (x,y)&#123; return x+y; &#125;; return &#123; add: add &#125;; &#125;);加载方法如下：1234 // main.js require([&apos;math&apos;], function (math)&#123; alert(math.add(1,1)); &#125;);如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。12345678 define([&apos;myLib&apos;], function(myLib)&#123; function foo()&#123; myLib.doSomething(); &#125; return &#123; foo : foo &#125;; &#125;);当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。六、加载非规范的模块理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。那么，require.js是否能够加载非规范的模块呢？回答是可以的。这样的模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征。举例来说，underscore和backbone这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。123456789101112 require.config(&#123; shim: &#123; &apos;underscore&apos;:&#123; exports: &apos;_&apos; &#125;, &apos;backbone&apos;: &#123; deps: [&apos;underscore&apos;, &apos;jquery&apos;], exports: &apos;Backbone&apos; &#125; &#125; &#125;);require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。比如，jQuery的插件可以这样定义：123456 shim: &#123; &apos;jquery.scroll&apos;: &#123; deps: [&apos;jquery&apos;], exports: &apos;jQuery.fn.scroll&apos; &#125; &#125;七、require.js插件require.js还提供一系列插件，实现一些特定的功能。domready插件，可以让回调函数在页面DOM结构加载完成后再运行。123 require([&apos;domready!&apos;], function (doc)&#123; // called once the DOM is ready &#125;);text和image插件，则是允许require.js加载文本和图片文件。12345678910 define([ &apos;text!review.txt&apos;, &apos;image!cat.jpg&apos; ], function(review,cat)&#123; console.log(review); document.body.appendChild(cat); &#125; );类似的插件还有json和mdown，用于加载json文件和markdown文件。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://algate.coding.me/categories/Javascript/"}],"tags":[{"name":"模块化编程","slug":"模块化编程","permalink":"https://algate.coding.me/tags/模块化编程/"}]},{"title":"Tomcat配置多域名多端口访问","slug":"Tomcat配置多域名多端口访问","date":"2016-09-25T09:31:30.000Z","updated":"2019-02-27T03:27:59.617Z","comments":true,"path":"2016/09/25/Tomcat配置多域名多端口访问/","link":"","permalink":"https://algate.coding.me/2016/09/25/Tomcat配置多域名多端口访问/","excerpt":"话不多说，直接开始1.安装Java要使用tomcat，首先要安装Java，并且配置Java环境，这里不介绍如何安装，重点强调安装过程中遇到的问题1tomcat.bat","text":"话不多说，直接开始1.安装Java要使用tomcat，首先要安装Java，并且配置Java环境，这里不介绍如何安装，重点强调安装过程中遇到的问题1tomcat.bat一.启动一闪而过tomcat启动服务，一闪而过，只能证明，环境变量配错了。正常的使用java，只需要把安装路径放到系统变量的Path里边，但是Tomcat启动找的却是JAVA_HOME,所以一定要配置java_home的环境变量，具体怎么配，请谷歌[info] 如果不知道具体什么错误，可以cmd启动运行startup,会提示有什么错误二.安装版本问题启动成功后，报错，就试具体原因了：有个刚启动就报的错，是因为tomcat和java的位数不同，所以安装的时候，最好选择同一版本，要么都是32，要么都是64位；三.安装位置tomcat安装，一般都是直接解压放到你想放到的地方就行了。四.项目代码位置我把项目放到tomcat下时，放错了地方，导致页面显示空白这里需要注意的是：一般放到webapps下就可以了，公司用到的大项目直接在webapps下。我把webapps下的东西删除，放上我自己的项目，但是页面就是没有显示出来最后我把原安装包解压发现webapps下有好多的文件夹，复制这么多文件放到webapps下[info] 我们需要把项目放到webapps下的ROOT文件夹里边。打开浏览器，就可以正常显示了也许你会说，我直接点击页面就可以浏览了，但是有些时候调试，需要真实的服务器环境来看。五.多端口多域名配置接下来就是配置ｔｏｍｃａｔ多域名，多端口的访问问题了：有三种情况：具体需要那种情况就看自己的需要了。但是修改的是同一个文件：安装目录下的conf文件夹里边的server.xml文件。可以直接看第三种情况，其实可以把前两个情况都解决。A.相同的域名，不同的端口访问，这种情况访问同一个项目Code:123456789101112131415161718&lt;Service name=&quot;Catalina&quot;&gt; &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt; &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt; &lt;Realm className=&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt; &lt;Realm className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot; resourceName=&quot;UserDatabase&quot;/&gt; &lt;/Realm&gt; &lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; &gt; &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot; prefix=&quot;localhost_access_log.&quot; suffix=&quot;.txt&quot; pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt; &lt;/Host&gt; &lt;/Engine&gt;&lt;/Service&gt;在service下找到Connector复制一份Code:123&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;port的值随意修改成你想要的数字 ，然后在浏览器改端口号，直接可以预览了。B.不同的域名访问同一项目（此种方法没什么用，直接可以略过）这个怎么操作呢，当然是复制一份带标签的内容，修改localhost改为自己想要的内容，比如你想yourname.com就可以改为你想要的，OK了，不过还有个问题需要解决，在第三种情况会有说明，所以直接看三吧C.不同的域名不同的端口（或者相同的端口），访问不同的项目直接复制一份(包括标签)Code:123456789101112131415161718&lt;Service name=&quot;Catalina2&quot;&gt; &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt; &lt;Engine name=&quot;Catalina2&quot; defaultHost=&quot;localhost&quot;&gt; &lt;Realm className=&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt; &lt;Realm className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot; resourceName=&quot;UserDatabase&quot;/&gt; &lt;/Realm&gt; &lt;Host name=&quot;你要的域名（www.baidu.com）&quot; appBase=&quot;安装目录先新建一个文件夹的名字&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; &gt; &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot; prefix=&quot;localhost_access_log.&quot; suffix=&quot;.txt&quot; pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt; &lt;/Host&gt; &lt;/Engine&gt;&lt;/Service&gt;port端口号可以一样把webapps复制一份放到安装目录下，更改文件名为appBase的名，把项目放到ROOT下（之前说过了哦！）然后启动服务，浏览器访问：你要的域名:8080/项目的路径文件 ,妥妥的，你就可以访问你的新文件夹下的新项目了。","categories":[{"name":"工具","slug":"工具","permalink":"https://algate.coding.me/categories/工具/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"https://algate.coding.me/tags/tomcat/"}]},{"title":"Progress标签样式","slug":"CSS-Progress标签样式","date":"2016-09-10T09:31:30.000Z","updated":"2019-02-27T05:19:41.307Z","comments":true,"path":"2016/09/10/CSS-Progress标签样式/","link":"","permalink":"https://algate.coding.me/2016/09/10/CSS-Progress标签样式/","excerpt":"progress元素属于HTML5家族，指进度条。IE10+以及其他靠谱浏览器都支持。如下简单code:&lt;progress&gt;o(︶︿︶)o&lt;/progress&gt; 不同浏览器下的效果不尽相同,样式控制有巨大差异，详细自己可以写个html的progress的标签看看不同浏览器下的效果，哎，那叫一个惨不忍睹！","text":"progress元素属于HTML5家族，指进度条。IE10+以及其他靠谱浏览器都支持。如下简单code:&lt;progress&gt;o(︶︿︶)o&lt;/progress&gt; 不同浏览器下的效果不尽相同,样式控制有巨大差异，详细自己可以写个html的progress的标签看看不同浏览器下的效果，哎，那叫一个惨不忍睹！使用progress{border:……; background:……;}可以控制浏览器下progress元素的边框和背景色。其中，Chrome浏览器是个特例，直接的设置看不到效果（实际上支持），原因下面会解释。FireFox浏览器已经完成的进度条，使用progress::-moz-progress-bar { }表示，这与Chrome浏览器是相反的。Chrome的表现与FireFox有着明显的差异，其progress元素的结构似乎是这样的：progressprogress-value progress-bar 其中，progress-bar指全部的进度，progress-value指已经完成的进度。因此，Chrome浏览器下，已经完成的进度条，使用progress::-webkit-progress-value { }表示， FireFox浏览器下是moz-bar. 而progress-bar默认含有背景色，因此，我们需要如下设置，以自定义背景色：progress::-webkit-progress-bar { background: ……; }Opera浏览器Opera似乎没有什么::-o-progress-*{}的用法，因此，Opera浏览器，其已完成进度的背景色是无解的，只能使用默认的颜色——我的浏览器是和谐绿色。IE10浏览器IE10浏览器很奇葩的，它也可以设置已完成进度的背景色，使用的是color属性，progress{color:*;}综上全部，我们可以使用类似下面的CSS实现最大兼容的自定义进度条样式：progress { border: none; width: 100%; height: 30px; background: #e3e9ee; color: #19ca6c; /* IE10、Firefox */ } progress::-moz-progress-bar { background: #19ca6c; } /* firefox value */ progress::-webkit-progress-bar { background: #e3e9ee; } progress::-webkit-progress-value { background: #19ca6c; } 得到如下效果样式：最后：IE6~IE9浏览器不支持progress元素，我们可以通过嵌套其他元素的方法进行兼容&lt;progress max=&quot;100&quot; value=&quot;20&quot;&gt;&lt;ie style=&quot;width:20%;&quot;&gt;&lt;/ie&gt;&lt;/progress&gt; css:/*ie6-ie9*/ progress ie { display:block; height: 100%; background: #19ca6c; } progress以及自定义的ie元素，ie6~8都是不认识的，我们需要打个动态补丁js:if (typeof window.screenX !== &quot;number&quot;) { document.createElement(&quot;progress&quot;); document.createElement(&quot;ie&quot;); }","categories":[{"name":"Css","slug":"Css","permalink":"https://algate.coding.me/categories/Css/"}],"tags":[{"name":"progress","slug":"progress","permalink":"https://algate.coding.me/tags/progress/"}]},{"title":"JS进阶-浅谈前端架构","slug":"JS进阶-浅谈前端架构","date":"2016-07-03T00:31:30.000Z","updated":"2019-02-27T03:27:59.569Z","comments":true,"path":"2016/07/03/JS进阶-浅谈前端架构/","link":"","permalink":"https://algate.coding.me/2016/07/03/JS进阶-浅谈前端架构/","excerpt":"原文地址前端架构前端架构总述在互联网应用越来越大，越来越复杂的今天，我们不可避免的需要工具来管理我们的前端代码。 替代以前的一个巨大的脚本文件，我们希望可以将文件写入不同的文件模块。并且希望代码可以 重用，可以简单的引用和添加各种各样的依赖到我们的项目（ 无论是菜单一样的 UI 组件还是 一个类似 jQuery 的 DOM 操作库）。不止是 JavaScript 我们希望可以用这种方式来组织， 他应该也包含 CSS，HTML 模板，字体，图片和其他静态文件。为什么前端需要模块化开发随着互联网应用越来越大，前端的开发也越来越复杂。如果还维持在以往以页面为单位的开发， 会导致很多问题，类似依赖管理，命名冲突等棘手的问题。命名冲突是最常见的问题：12345678// util.jsfunction log(message) &#123;&#125;// logger.jsfunction log(message) &#123;&#125;","text":"原文地址前端架构前端架构总述在互联网应用越来越大，越来越复杂的今天，我们不可避免的需要工具来管理我们的前端代码。 替代以前的一个巨大的脚本文件，我们希望可以将文件写入不同的文件模块。并且希望代码可以 重用，可以简单的引用和添加各种各样的依赖到我们的项目（ 无论是菜单一样的 UI 组件还是 一个类似 jQuery 的 DOM 操作库）。不止是 JavaScript 我们希望可以用这种方式来组织， 他应该也包含 CSS，HTML 模板，字体，图片和其他静态文件。为什么前端需要模块化开发随着互联网应用越来越大，前端的开发也越来越复杂。如果还维持在以往以页面为单位的开发， 会导致很多问题，类似依赖管理，命名冲突等棘手的问题。命名冲突是最常见的问题：12345678// util.jsfunction log(message) &#123;&#125;// logger.jsfunction log(message) &#123;&#125;当页面的 script 标签同时依赖这两个文件时便会产生冲突，导致后面函数会覆盖前面的。 从而可能会产生一些预想之外的结果。而传统的解决方案是使用命名空间：12345678910// util.jsvar util.log = function(message) &#123;&#125;// logger.jsvar logger.log = function(message) &#123;&#125;这样会带来显而易见的问题，所有的代码会变得冗余且编写困难。如果使用模块化的编写方案，例如 Common Module Definition，代码见的依赖会变得格外简单。123456789101112131415161718// util.jsvar log = function(message) &#123;&#125;module.exports = log// logger.jsvar log = function(message) &#123;&#125;module.exports = log// app.js using util.js log for loggingvar log = require(&quot;util.js&quot;)log(&quot;Hello Module Definition&quot;)util.js 与 logger.js 不会相互冲突，他们会被工具包装为 CMD 下的定义方式。 然后通过依赖的方式来解决冲突依赖管理同样是一个棘手的问题：1234&lt;script src=&quot;/util.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/logger.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/app.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;如果你有一大堆的依赖关系，你必须依序将所有的文件引入，否则会导致变量未定义等问题。 如果使用了 Common Module Definition 便可以无序的引入组件文件。在样式方面由于 CSS 与浏览器本身的限制我们仍然无法使用这样的技术来划分模块。12345678910/* layout.css */.box &#123;&#125;/* dropdown.css */.box &#123;&#125;这样的话 dropdown.css 的 .box 便会覆盖之前的 .box 的样式，所以我们需要在模块中添加限制。所以在样式表方面我们需要详细的划分模块的命名空间，例如在 dropbox.css 中我们可以用这样的命名方式 .dropdown .box 的方式。 这边便不会影响到父级的样式。如何进行模块化开发首先对页面进行模块化的拆分，将模块的定义文件放在一个文件夹下，其中包含有 JavaScript CSS 以及 Templates（前后端）的文件。模块的脚本文件默认会被 CMD 包装， 而 CSS 文件，开发着需要对文件进行特殊的命名，默认以模块文件夹名为命名空间， 以防与别人冲突，而模板文件则不会有这样的顾虑。我们开发了 Linner 来支持模块化的开发。架构概览在前端项目中，我们在底层拥有基础组件库与可视化编辑框架用于装修需求。 在基础组件之上，我们会沉淀出标准的组件库，类似电商标准组件库之类的类库， 而真正的类库中开发者也需要将自己的组织为组件的形式。而工具则为整个过程保驾护航。工具阐述简单来说，Linner 允许我们做：项目结构化 页面组件化 仓库管理 使用 CoffeeScript 与 SCSS 来替代 JavaScript 与 CSS 合并 CSS 与 JavaScript 文件 复制 CSS 与 JavaScript 文件 预编译 CSS 与 JavaScript 文件 合并图片至一张大图（Sprites） 压缩 CSS 与 JavaScript 文件 监视文件系统变化并实时更新 项目结构化项目通过标准化的方式来组织：.├── app│ ├── components│ │ └── dropdown│ │ ├── view.coffee│ │ ├── view.hbs│ │ └── view.scss│ ├── images│ │ └── logo.png│ ├── scripts│ │ └── app.coffee│ ├── styles│ │ └── app.scss│ ├── templates│ │ └── welcome.hbs│ └── views│ └── index.html├── bin│ └── server├── config.yml├── public├── test└── vendorapp 文件夹是用户自己编写代码的地方images 用以存放项目相关的图片文件 scripts 用以存放项目相关的 JavaScript 文件 styles 用以存放项目相关的 Stylesheet 文件 templates 用以存放项目相关的前端模板文件 views 用以存放项目相关的后端模板文件 components 用以存放项目的组件文件 config.yml 是整个项目的配置文件bin 文件夹可以让用户很方便的启动一个本地的服务器，以当前文件夹作为根test 文件夹可以使用户编写一些单元测试来测试自己的前端项目vendor 文件夹可以使用户引入第三方的代码组件，如 jQuery、Underscore 等public 文件夹是项目打包后文件位置，发布项目所需要的所有文件页面组件化不要面向页面编程，要面向组件编程。当拿到网站的整体设计稿时，我们应该首先去找出页面间有相同逻辑的模块。 将他们抽出，考虑如何将其设计为可复用的模块。我们可以将模块的内容包含 JavaScript CSS 与前后端模板组织在 app/components 内，通过在 app/scripts 里面的 app.coffee 中去初始化所有的组件。通过 cmd 的形式去管理组件与组件之间的依赖关系。这样组件内部就可以通过 module.exports = “dropdown” 与 require “dropdown” 这样的形式去导出与依赖组件。仓库管理通过 bundles 来管理远端依赖，在项目中可以非常方便的引入一些著名的第三方库。 如 jQuery，Underscore 等。依赖可以规定多个版本，当需要升级版本时，可以更改 version 与 url 在工具下次启动时便可以拉取新版本的依赖。如果希望依赖一直为最新状态，可以将 version 设置为 master 这样工具会在每次启动时都获取最新的文件。使用 CoffeeScript 与 SCSS 来替代 JavaScript 与 CSSCoffeeScriptCoffeeScript 是这一门编程语言构建在 JavaScript 之上，其被编译成高效的 JavaScript， 这样你就可以在 Web 浏览器上运行它，或是通过诸如用于服务器端应用的 Node.js 一类的技术来使用它。 编译过程通常都很简单，产生出来的 JavaScript 与许多的最佳做法都保持了一致。SCSSSCSS 扩展了 CSS3，增加了规则、变量、混入、选择器、继承等等特性。 SCSS 生成良好格式化的 CSS 代码，易于组织和维护。使用成本使用 CoffeeScript 与 SCSS 可以大幅降低开发成本，使用 CoffeeScript 可以避免一些常见的 JavaScript 开发错误。 而 SCSS 则可以更好的抽象样式文件，使样式得到更好的维护。并且 CoffeeScript 与 SCSS 的学习成本都很低， 前端可以通过很简短的学习就能立刻写出优雅的代码。合并 CSS 与 JavaScript 文件前端文件的合并可以明显的减少 HTTP 请求，明显的加快网页的浏览速度。复制 CSS 与 JavaScript 文件复制文件是一个很普遍的需求，可以将文件从一个位置复制到另一个位置。如果是 CoffeeScript 文件或者 SCSS 文件，工具会帮助转换为对应的 Javascript 与 CSS 文件。预编译 JavaScript 模板文件随着互联网应用越来越大，前端模板的需求也日渐突出。在使用前端模板的过程中， 为了提高前端的渲染性能，我们需要对前端模板进行预编译。预编译的结果是使 templates 文件能直接转化为 JavaScript 的方法调用。这样可以以非常快的速度来渲染前端模板。合并图片至一张大图（Sprites）当页面内的图片很多时，会产生多个 HTTP 请求，当请求变多时会严重影响网站的速度。 所以我们需要将多个 PNG 图片合并成一张图片。同时利用 CSS 的 background 来显示对应的单个图片压缩 CSS 与 JavaScript 文件在项目发布上线时需要将资源文件进行最大程度的压缩。从而减少 HTTP 请求文件的体积。 从而可以将文件尽快的传输给用户，使页面更快的展示出来。工具提供了快速的文件名的版本替换，可以使服务器更好的缓存压缩后的文件。监视文件系统变化并实时更新文件系统的实时监控可以监控到项目内文件的变动，同时重新执行整个工具的逻辑。在开发阶段，我们可以尽最大程度的提高开发者的效率。例如使用浏览器实时刷新。 当文件系统有任何变化时，工具会发动 LiveReload 来自动刷新页面， 当用户只修改了 CSS 文件时，我们甚至可以不刷新页面，直接重载 CSS 文件。 极大的提高开发效率。性能调优大约 80%-90% 的终端响应时间是花费在前端，其中包含下载页面中的图片，样式表，脚本，flash等。Yahoo 为此总结了 14 条规则，成为网站性能优化的事实标准。雅虎网站性能优化的 14 条规则：尽可能减少 HTTP 请求数 使用 CDN（内容分发网络） 为文件头指定 Expires 或 Cache-Control，使内容具有缓存性 使用 Gzip 压缩内容 把 CSS 放到顶部 把 JavaScript 放在底部 避免在 CSS 中使用 Expressions 把 JavaScript 和 CSS 都放到外部文件中 减少 DNS 查找次数 压缩 JavaScript 和 CSS 避免重定向 剔除重复的 JavaScript 和 CSS 配置 Etags 使 AJAX 缓存 对规则的分析：代码编写方面的规则： 把 CSS 放到顶部 把 JavaScript 放在底部 把 JavaScript 和 CSS 都放到外部文件中 避免在 CSS 中使用 Expressions 使 AJAX 缓存 打包方面的规则： 尽可能减少 HTTP 请求数 压缩 JavaScript 和 CSS 剔除重复的 JavaScript 和 CSS 部署方面的规则： 使用 CDN（内容分发网络） 为文件头指定 Expires 或 Cache-Control，使内容具有缓存性 使用 Gzip 压缩内容 减少 DNS 查找次数 避免重定向 配置 Etags 对规则的实践部署方面的规则，应用 Nginx 为静态文件添加 Expires 跟 Cache-Control 头， 配置 Etags，并启用 Gzip 压缩。并且避免在 Nginx 中做重定向，有条件的话可以 启用 CDN，并优化网络配置以减少 DNS 查找次数。 代码编写方面的规则，需要在编写代码种形成规范。默认使用类似 jQuery 这样的库 便可以对 AJAX 进行缓存。 打包方面 Linner 可以合并 JavaScript 与 CSS 文件, 并且支持小图片的合并， 用以减少 HTTP 请求数。同时 Linner 的仓库管理可以避免重复的 JavaScript 与 CSS 文件的出现。在 build 过后所有的文件将会被压缩。 附件工具的使用安装 Ruby 2.0.0 以上版本 安装 Linner 及其使用规则 安装 Linnergem install linner使用 Linner 创建项目结构linner new webapp &amp;&amp; cd webapp在项目下启动 Linnerlinner watch退出 LinnerCTRL + C打包资源文件linner build清空打包的资源文件linner cleanconfig.yml 文件配置详解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253paths: app: &quot;app&quot; test: &quot;test&quot; public: &quot;public&quot;groups: scripts: paths: - app/scripts concat: &quot;/scripts/app.js&quot;: &quot;app/**/*.&#123;js,coffee&#125;&quot; &quot;/scripts/vendor.js&quot;: &quot;vendor/**/*.&#123;js,coffee&#125;&quot; order: - vendor/jquery-1.10.2.js - ... - app/scripts/app.coffee styles: paths: - app/styles concat: &quot;/styles/app.css&quot;: &quot;app/styles/**/[a-z]*.&#123;css,scss,sass&#125;&quot; images: paths: - app/images sprite: &quot;../app/images/icons.scss&quot;: &quot;app/images/**/*.png&quot; views: paths: - app/views copy: &quot;/&quot;: &quot;app/views/**/*.html&quot; templates: paths: - app/templates precompile: &quot;/scripts/templates.js&quot;: &quot;app/templates/**/*.hbs&quot;modules: wrapper: cmd ignored: vendor/**/* definition: /scripts/app.jssprites: url: /images/ path: /images/ selector: .icon-revision: index.htmlnotification: truebundles: jquery.js: version: 1.10.2 url: http://code.jquery.com/jquery-1.10.2.js handlebars.js: version: 1.0.0 url: https://raw.github.com/wycats/handlebars.js/1.0.0/dist/handlebars.runtime.jspaths 表示当前工具做监视的文件系统目录groups 区分了不同的组，每个组可以有一个名字。在组内部的声明中需要指定当前组的 paths，然后可以指定一系列的操作原语，包括：concat order copy precompile sprite 等modules 定义了需要被 CMD 包装的文件路径，以及包装定义的头文件连接位置sprites 定义了图片 sprites 的一些生成规则，例如以 .icon- 开头来生成 CSS 列表，这样用户便可以以这样的 CSS 选择器来直接生成样式。revision 定义了需要被加载 rev 的文件，用以 md5 的文件名来替换旧文件名notification 定义了是否需要有通知系统，（用以 Mac 系统的通知）bundles 定义了项目的依赖关系，项目可以依赖很多第三方的项目，可以自定义版本号。 如果需要每次启动都更新最新版本的依赖，可以将 version 设置为 master","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://algate.coding.me/categories/Javascript/"}],"tags":[{"name":"前端架构","slug":"前端架构","permalink":"https://algate.coding.me/tags/前端架构/"}]},{"title":"浏览器渲染原理以及内部解剖","slug":"JS-浏览器渲染原理以及内部解剖","date":"2016-04-12T00:31:30.000Z","updated":"2019-02-27T03:27:59.565Z","comments":true,"path":"2016/04/12/JS-浏览器渲染原理以及内部解剖/","link":"","permalink":"https://algate.coding.me/2016/04/12/JS-浏览器渲染原理以及内部解剖/","excerpt":"原文地址：浏览器渲染原理及解剖浏览器内部工作原理[info]很多人对浏览器的渲染原理和浏览器内容工作原理混淆。其实这是两个概念，这篇文章给了一个很全面的解释。1、浏览器渲染原理简单地说，页面渲染就是浏览器将html代码根据CSS定义的规则显示在浏览器窗口中的这个过程。先来大致了解一下浏览器都是怎么工作的：1. 用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；2. 浏览器开始载入html代码，发现head标签内有一个link标签引用外部CSS文件；3. 浏览器又发出CSS文件的请求，服务器返回这个CSS文件；4. 浏览器继续载入html中body部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；5. 浏览器在代码中发现一个img标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；6. 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；7. 浏览器发现了一个包含一行Javascript代码的script标签，赶快运行它；8. Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个（style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码；9. 终于等到了/html的到来，浏览器泪流满面……10. 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下标签的CSS路径；11. 浏览器召集了在座的各位div,span,ul,li们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。","text":"原文地址：浏览器渲染原理及解剖浏览器内部工作原理[info]很多人对浏览器的渲染原理和浏览器内容工作原理混淆。其实这是两个概念，这篇文章给了一个很全面的解释。1、浏览器渲染原理简单地说，页面渲染就是浏览器将html代码根据CSS定义的规则显示在浏览器窗口中的这个过程。先来大致了解一下浏览器都是怎么工作的：1. 用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；2. 浏览器开始载入html代码，发现head标签内有一个link标签引用外部CSS文件；3. 浏览器又发出CSS文件的请求，服务器返回这个CSS文件；4. 浏览器继续载入html中body部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；5. 浏览器在代码中发现一个img标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；6. 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；7. 浏览器发现了一个包含一行Javascript代码的script标签，赶快运行它；8. Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个（style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码；9. 终于等到了/html的到来，浏览器泪流满面……10. 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下标签的CSS路径；11. 浏览器召集了在座的各位div,span,ul,li们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。浏览器每天就这么来来回回跑着，要知道不同的人写出来的html和css代码质量参差不齐，说不定哪天跑着跑着就挂掉了。好在这个世界还有这么一群人——页面重构工程师，平时挺不起眼，也就帮视觉设计师们切切图啊改改字，其实背地里还是干了不少实事的。说到页面为什么会慢？那是因为浏览器要花时间、花精力去渲染，尤其是当它发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫reflow。reflow几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。通常我们都无法预估浏览器到底会reflow哪一部分的代码，它们都彼此相互影响着。reflow问题是可以优化的，我们可以尽量减少不必要的reflow。比如开头的例子中的图片载入问题，这其实就是一个可以避免的reflow——给图片设置宽度和高度就可以了。这样浏览器就知道了图片的占位面积，在载入图片前就预留好了位置。另外，有个和reflow看上去差不多的术语：repaint，中文叫重绘。如果只是改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器repaint。repaint的速度明显快于 reflow（在IE下需要换一下说法，reflow要比repaint 更缓慢）。下次将通过一系列的实验说明在Firefox、IE等浏览器下reflow的优化。前端必读：浏览器内部工作原理2、浏览器内部工作原理目录 一、介绍 二、渲染引擎 三、解析与DOM树构建 四、渲染树构建 五、布局 六、绘制 七、动态变化 八、渲染引擎的线程 九、CSS2可视模型","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://algate.coding.me/categories/Javascript/"}],"tags":[{"name":"浏览器渲染","slug":"浏览器渲染","permalink":"https://algate.coding.me/tags/浏览器渲染/"}]},{"title":"Sublime完美配置 for myself","slug":"Sublime完美配置","date":"2016-03-25T09:31:30.000Z","updated":"2019-02-27T05:14:01.913Z","comments":true,"path":"2016/03/25/Sublime完美配置/","link":"","permalink":"https://algate.coding.me/2016/03/25/Sublime完美配置/","excerpt":"插件安装需要注意的是，为了避免安装的目录乱，直接下载 portbale version1.安装插件管理器ctrl+` 打开调试窗口，在输入框内粘贴如下代码，然后回车即可自动安装，安装完成可能需要重启ST。Code:import urllib.request,os,hashlib; h = &apos;2915d1851351e5ee549c20394736b442&apos; + &apos;8bc59f460fa1548d1514676163dafc88&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 回车，稍等片刻就好了，会有提示。","text":"插件安装需要注意的是，为了避免安装的目录乱，直接下载 portbale version1.安装插件管理器ctrl+` 打开调试窗口，在输入框内粘贴如下代码，然后回车即可自动安装，安装完成可能需要重启ST。Code:import urllib.request,os,hashlib; h = &apos;2915d1851351e5ee549c20394736b442&apos; + &apos;8bc59f460fa1548d1514676163dafc88&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 回车，稍等片刻就好了，会有提示。2.搜索安装插件快捷调用这样就可以使用package control 进行插件安装了，ctrl+shift+p。输入install package，回车弹出搜索框：输入要安装插件的name，回车就会安装，安装的时候，左下角会有 = 左右移动，说明在安装了，如果没有任何提示，那说明没有开始安装，就要找别的方法了。（太费事了，具体自己到网上搜索方法吧！）[info] 如果要移除package，c+s+p，输入remove package……3.基础用户设置网上现在的教程都是比较老的，如图所示，只有一个settings，没错，直接点击就行了，新窗口，左边为default设置，是不允许更改的，右边为user设置，自己可以更改：我的默认设置：123456789101112131415161718192021222324&#123; \"auto_find_in_selection\": true, \"bold_folder_labels\": true, \"color_scheme\": \"Packages/User/SublimeLinter/Monokai (SL).tmTheme\", \"default_line_ending\": \"unix\", \"disable_tab_abbreviations\": true, \"draw_minimap_border\": true, \"ensure_newline_at_eof_on_save\": true, \"fade_fold_buttons\": false, \"font_face\": \"Microsoft YaHei Mono\", \"font_size\": 14, \"highlight_line\": true, \"highlight_modified_tabs\": true, \"ignored_packages\": [ \"Vintage\" ], \"save_on_focus_lost\": true, \"tab_size\": 4, \"theme\": \"Default.sublime-theme\", \"translate_tabs_to_spaces\": true, \"trim_trailing_white_space_on_save\": true, \"word_wrap\": \"true\"&#125;trim_trailing_white_space_on_save，自动移除行尾多余空格，处女座更安心了。ensure_newline_at_eof_on_save，文件末尾自动保留一个空行，懂的人自然知道它的用处。font_face 设置字体。Microsoft YaHei Mono 是一款混合字体，专为代码优化，看起来很舒服。当然你也可以使用你自己喜欢的字体，或者删掉本行，使用默认字体。disable_tab_abbreviations 设置为 true ，禁用 Emmet 的 tab 键功能（请使用 ctrl+e），系统自带的 tab 功能还是可圈可点的。当然你也可以不设置它，以完全使用 Emmet 的 tab 补全功能。translate_tabs_to_spaces 很明白就是把代码 tab 对齐转换为空格对齐，tab_size 配合设置空格数。这个需求因人而异了，不喜欢可以去掉。draw_minimap_border，用于右侧代码预览时给所在区域加上边框，方便识别。save_on_focus_lost，窗口失焦立即保存文件，嘛嘛再也不用担心你忘记保存了。highlight_line，当前行高亮。word_wrap，设置自动换行。fade_fold_buttons，默认显示行号右侧的代码段闭合展开三角号。bold_folder_labels，侧边栏文件夹显示加粗，区别于文件。highlight_modified_tabs，高亮未保存文件。default_line_ending: “unix”, 使用 unix 风格的换行符。auto_find_in_selection: true ，开启选中范围内搜索（而不是整个文档4.ChineseLocalization完全汉化插件（不懂英文的福利，我也是在2018年春节前发现的。网上无意中看到的，我的英文还算ok吧，也没太在意这个插件）5.Emmet，前端神器默认情况下使用快捷键ctrl+e可以自动扩展成适应于react的className形式。而使用tab来默认拓展则需要通过修改sublime快捷键，如下所示：打开 preferences -&gt; Key bindings - Users，把下面代码复制到[]内部。12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123; &quot;keys&quot;: [&quot;tab&quot;], &quot;command&quot;: &quot;expand_abbreviation_by_tab&quot;, // put comma-separated syntax selectors for which // you want to expandEmmet abbreviations into &quot;operand&quot; key // instead of SCOPE_SELECTOR. // Examples: source.js, text.html - source &quot;context&quot;: [ &#123; &quot;operand&quot;: &quot;source.js&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;match_all&quot;: true, &quot;key&quot;: &quot;selector&quot; &#125;, // run only if there&apos;s no selected text &#123; &quot;match_all&quot;: true, &quot;key&quot;: &quot;selection_empty&quot; &#125;, // don&apos;t work if there are active tabstops &#123; &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: false, &quot;match_all&quot;: true, &quot;key&quot;: &quot;has_next_field&quot; &#125;, // don&apos;t work if completion popup is visible and you // want to insert completion with Tab. If you want to // expand Emmet with Tab even if popup is visible -- // remove this section &#123; &quot;operand&quot;: false, &quot;operator&quot;: &quot;equal&quot;, &quot;match_all&quot;: true, &quot;key&quot;: &quot;auto_complete_visible&quot; &#125;, &#123; &quot;match_all&quot;: true, &quot;key&quot;: &quot;is_abbreviation&quot; &#125; ]&#125;6.SideBarEnhancements ，增强型侧边栏如上图打开之后输入：12345678910111213141516171819202122232425262728293031323334353637383940414243[ // &#123; \"keys\": [\"ctrl+shift+c\"], \"command\": \"copy_path\" &#125;, // firefox &#123; \"keys\": [\"f1\"], \"command\": \"side_bar_files_open_with\", \"args\": &#123; \"paths\": [], \"application\": \"C:\\\\Program Files (x86)\\\\Mozilla Firefox\\\\firefox.exe\", \"extensions\":\".*\" //匹配任何文件类型 &#125; &#125;, //chrome &#123; \"keys\": [\"f2\"], \"command\": \"side_bar_files_open_with\", \"args\": &#123; \"paths\": [], \"application\": \"C:\\\\Program Files (x86)\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe\", \"extensions\":\".*\" &#125; &#125;, //ie &#123; \"keys\": [\"f3\"], \"command\": \"side_bar_files_open_with\", \"args\": &#123; \"paths\": [], \"application\": \"C:\\\\Program Files\\\\Internet Explorer\\\\iexplore.exe\", \"extensions\":\".*\" &#125; &#125;, //safari &#123; \"keys\": [\"f4\"], \"command\": \"side_bar_files_open_with\", \"args\": &#123; \"paths\": [], \"application\": \"C:\\\\software\\\\Browser\\\\Safari\\\\safari.exe\", \"extensions\":\".*\" &#125; &#125;, //opera &#123; \"keys\": [\"f5\"], \"command\": \"side_bar_files_open_with\", \"args\": &#123; \"paths\": [], \"application\": \"C:\\\\software\\\\Browser\\\\opera\\\\opera.exe\", \"extensions\":\".*\" &#125; &#125;]7. HTML/CSS/js Prettify然后找到这个文件文件夹tools-&gt;HTML/CSS/JS Prettify-&gt;set prettify preference修改文件目录（sublime版本）修改路径：找到这一样代码后面添加 vue“allowed_file_extensions”: [“htm”, “html”, “xhtml”, “shtml”, “xml”, “svg”, “vue”],7.1 vue syntax highlight识别vue高亮。（wepy文件.wpy 文件后缀为.wpy，可共用Vue的高亮规则）重新打开sublime就可以识别了。语法选中项为vue-component8.ConvertToUTF8功能：文件转码成utf-8简介：通过本插件，您可以编辑并保存目前编码不被 Sublime Text 支持的文件，特别是中日韩用户使用的 GB2312，GBK，BIG5，EUC-KR，EUC-JP ，ANSI等。ConvertToUTF8 同时支持 Sublime Text 2 和 3。使用：安装插件后自动转换为utf-8格式9.IMESupport功能：sublime中文输入法简介：还在纠结 Sublime Text 中文输入法不能跟随光标吗？试试「IMESupport 」这个插件吧！目前只支持 Windows，在搜索等界面不能很好的跟随光标。使用：Ctrl + Shift + P →输入pci →输入IMESupport →回车10.最新版sublime主题、字体相关设置：preferences（首选项） -&gt; color（配色方案）-&gt;弹出下图所示，选择monokai extended就ok了修改左侧边栏样式：（继续往下看，不要着急操作）preferences（首选项） -&gt; theme（主题方案）-&gt;弹出下图所示，选择Default.sublime-theme但是这个只是选择默认样式，如何修改呢。继续往下看：[warning] （默认的配置文件是不允许你修改的，你也找不到的，需要插件来查找和修改）（1）安装插件 PackageResourceViewer（2）打开 Open Resource（3）找到 Theme - Default，回车（4）找打 Default.sublime-theme，回车打开（5）搜索 ‘sidebar_label’ 并且修改找到的第一个（在362行）,添加 ‘ “font.size”: 14’，保存即可其他相关颜色，背景等搜索网络教程解决吧。11.为了省去更改侧边栏样式的问题，直接更改主题是最快的方式，需要安装相关插件搜索 theme 可以发现有很多的主题， 网上推荐这个 Afterglow 不错（可显示侧边栏小图标）改之前的效果：（10-相关操作之后的样式 + sidebar）Welcome to Afterglow ThemeTo activate the theme, add or replace your current theme settings with the code below.安装完afterglow之后，会有package control message。关于插件的相关信息，如果要修改需要设置里添加相关信息123456789101112131415161718192021222324252627282930313233Settings for Afterglow&#123; \"theme\": \"Afterglow.sublime-theme\", \"color_scheme\": \"Packages/Theme - Afterglow/Afterglow.tmTheme\"&#125;Settings for Afterglow-blue&#123; \"theme\": \"Afterglow-blue.sublime-theme\", \"color_scheme\": \"Packages/Theme - Afterglow/Afterglow.tmTheme\"&#125;Settings for Afterglow-magenta&#123; \"theme\": \"Afterglow-magenta.sublime-theme\", \"color_scheme\": \"Packages/Theme - Afterglow/Afterglow.tmTheme\"&#125;Settings for Afterglow-orange&#123; \"theme\": \"Afterglow-orange.sublime-theme\", \"color_scheme\": \"Packages/Theme - Afterglow/Afterglow.tmTheme\"&#125;Settings for Afterglow-green&#123; \"theme\": \"Afterglow-green.sublime-theme\", \"color_scheme\": \"Packages/Theme - Afterglow/Afterglow.tmTheme\"&#125;If you know other settings (height of the tabs, sidebar options, ...), visit this page:https://github.com/YabataDesign/afterglow-theme/blob/master/README.mdhttps://github.com/YabataDesign/afterglow-theme/blob/master/README.md我选择的主题是：（决定侧边栏的样式效果）配色方案是：（决定编辑部分的样式效果）由于默认的侧边的样式效果看不清问，颜色几乎和背景融为一体，网上好多人说好看，还是那句话，萝卜白菜各有所爱，关键是看不清……修改像 10 中提到的那样，利用 PackageResourceViewer 插件，修改样式文件字体大小有 12,13，他默认是 14 修改font.size 为自己合适的大小1234567// Sidebar entry font size 14 &#123; &quot;class&quot;: &quot;sidebar_label&quot;, &quot;settings&quot;: [&quot;sidebar_size_14&quot;], &quot;font.size&quot;: 16, &quot;color&quot;: [200, 200, 200] // 03 &#125;,1234// 修改文件夹名称样式&quot;parents&quot;: [&#123;&quot;class&quot;: &quot;tree_row&quot;,&quot;attributes&quot;: [&quot;expandable&quot;]&#125;],还有 hover，selected 等 自己可以自行配置相关的样式it’s mine.STATUS BARlabel_control修改下图部位的样式（编辑器最下边文字样式）BOTTOM PANEL ICONS - GROUP 2icon_reverse + icon_wrap修改下图中部位样式12.YUI Compressor压缩JS和CSS文件快捷键： ctrl + b13.JsFormat刚开始在JSX文件格式化后惨不忍睹，其实配置一个属性就可以支持JSX语法格式化。菜单-&gt;Preferences-&gt;Package Settings-&gt;JsFormat-&gt;Settings-User加入以下代码{ &quot;e4x&quot;: true,//支持jsx格式化 &quot;format_on_save&quot;: true//保存立即格式化，对于严格代码规范的人来说，把没有必要格式化的代码也格式化了 } 14.代码检查1.首先安装SublimeLinter、SublimeLinter-jshint、SublimeLinter-jsxhint、SublimeLinter-contrib-eslint插件。2.然后命令行全局安装npm install -g eslint npm install -g babel-eslint npm install -g eslint-plugin-react npm install -g jsxhint 3.以ES6语法检查为例，在项目工程根目录新建.eslintrc,输入{ &quot;parserOptions&quot;: { &quot;ecmaVersion&quot;: 6, &quot;sourceType&quot;: &quot;module&quot;, &quot;ecmaFeatures&quot;: { &quot;jsx&quot;: true } }, &quot;rules&quot;: { &quot;semi&quot;: [&quot;error&quot;, &quot;always&quot;] } } 详细配置参考 http://eslint.org/docs/user-guide/configuring15.React ES6 SnippetsES6 Snippets，代码提示这个没找到，找到了 react native snippets16.Babeles6/es2015、JSX代码高亮设置①：view &gt; Syntax &gt; Babel &gt; JavaScript (Babel)设置②：点击编辑器右下角 &gt; Babel &gt; JavaScript (Babel)reacthttps://www.jianshu.com/p/0427629bd111","categories":[{"name":"工具","slug":"工具","permalink":"https://algate.coding.me/categories/工具/"}],"tags":[{"name":"sublime","slug":"sublime","permalink":"https://algate.coding.me/tags/sublime/"}]},{"title":"Gallery-画廊插件使用","slug":"Gallery-画廊插件使用","date":"2016-02-08T09:31:00.000Z","updated":"2019-02-27T03:27:59.543Z","comments":true,"path":"2016/02/08/Gallery-画廊插件使用/","link":"","permalink":"https://algate.coding.me/2016/02/08/Gallery-画廊插件使用/","excerpt":"To add a photo gallery placeholder to your post, just add the following lines to your front-matter:1234photos:- https://www.hdwallpapers.net/previews/starry-night-over-corsica-986.jpg- https://www.hdwallpapers.net/previews/water-plant-close-up-979.jpg- ...","text":"To add a photo gallery placeholder to your post, just add the following lines to your front-matter:1234photos:- https://www.hdwallpapers.net/previews/starry-night-over-corsica-986.jpg- https://www.hdwallpapers.net/previews/water-plant-close-up-979.jpg- ...and enable lightgallery plugin in your _config.yml:12345# Pluginsplugins:+ lightgallery: true # options: true, false google_analytics: # enter the tracking ID for your Google Analytics ...You can also add photos between text to create another gallery like this:or this:Finally, you can also use Justified Gallery to display you photos in a grid:12345# Pluginsplugins:+ justifiedgallery: true # options: true, false google_analytics: # enter the tracking ID for your Google Analytics ...","categories":[{"name":"文档","slug":"文档","permalink":"https://algate.coding.me/categories/文档/"}],"tags":[{"name":"Gallery","slug":"Gallery","permalink":"https://algate.coding.me/tags/Gallery/"}]},{"title":"Markdown语法","slug":"markdown-最新编辑语言规范","date":"2016-01-25T09:31:00.000Z","updated":"2019-02-27T03:27:59.648Z","comments":true,"path":"2016/01/25/markdown-最新编辑语言规范/","link":"","permalink":"https://algate.coding.me/2016/01/25/markdown-最新编辑语言规范/","excerpt":"","text":"@TOC欢迎使用Markdown编辑器你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。新的改变我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：全新的界面设计 ，将会带来全新的写作体验；在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示；增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；全新的 KaTeX数学公式 语法；增加了支持甘特图的mermaid语法^1 功能；增加了 多屏幕编辑 Markdown文章功能；增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间；增加了 检查列表 功能。功能快捷键撤销：Ctrl/Command + Z重做：Ctrl/Command + Y加粗：Ctrl/Command + B斜体：Ctrl/Command + I标题：Ctrl/Command + Shift + H无序列表：Ctrl/Command + Shift + U有序列表：Ctrl/Command + Shift + O检查列表：Ctrl/Command + Shift + C插入代码：Ctrl/Command + Shift + K插入链接：Ctrl/Command + Shift + L插入图片：Ctrl/Command + Shift + G合理的创建标题，有助于目录的生成直接输入1次#，并按下space后，将生成1级标题。输入2次#，并按下space后，将生成2级标题。以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。如何改变文本的样式强调文本 强调文本加粗文本 加粗文本==标记文本==删除文本引用文本H~2~O is是液体。2^10^ 运算结果是 1024.插入链接与图片链接: link.图片: 带尺寸的图片: 当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。如何插入一段漂亮的代码片去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 代码片.12// An highlighted blockvar foo = 'bar';生成一个适合你的列表项目项目项目项目1项目2项目3 计划任务 完成任务创建一个表格一个简单的表格是这么创建的：项目 | Value——– | —–电脑 | $1600手机 | $12导管 | $1设定内容居中、居左、居右使用:---------:居中使用:----------居左使用----------:居右| 第一列 | 第二列 | 第三列 ||:———–:| ————-:|:————-|| 第一列文本居中 | 第二列文本居右 | 第三列文本居左 |SmartyPantsSmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：| TYPE |ASCII |HTML|—————-|——————————-|—————————–||Single backticks|&#39;Isn&#39;t this fun?&#39; |’Isn’t this fun?’ ||Quotes |&quot;Isn&#39;t this fun?&quot; |”Isn’t this fun?” ||Dashes |-- is en-dash, --- is em-dash|– is en-dash, — is em-dash|创建一个自定义列表Markdown: Text-to-HTML conversion toolAuthors: John: Luke如何创建一个注脚一个具有注脚的文本。^2注释也是必不可少的Markdown将文本转换为 HTML。*[HTML]: 超文本标记语言KaTeX数学公式您可以使用渲染LaTeX数学表达式 KaTeX:Gamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\foralln\\in\\mathbb N$ 是通过欧拉积分$$\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.$$你可以找到更多关于的信息 LaTeX 数学表达式here.新的甘特图功能，丰富你的文章12345678gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section 现有任务 已完成 :done, des1, 2014-01-06,2014-01-08 进行中 :active, des2, 2014-01-09, 3d 计划一 : des3, after des2, 5d 计划二 : des4, after des3, 5d关于 甘特图 语法，参考 这儿,UML 图表可以使用UML图表进行渲染。 Mermaid. 例如下面产生的一个序列图：:123456789sequenceDiagram张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?李四--&gt;&gt;王五: 你最近怎么样，王五？李四--x 张三: 我很好，谢谢!李四-x 王五: 我很好，谢谢!Note right of 王五: 李四想了很长时间, 文字太长了&lt;br/&gt;不适合放在一行.李四--&gt;&gt;张三: 打量着王五...张三-&gt;&gt;王五: 很好... 王五, 你怎么样?这将产生一个流程图。:12345graph LRA[长方形] -- 链接 --&gt; B((圆))A --&gt; C(圆角长方形)B --&gt; D&#123;菱形&#125;C --&gt; D关于 Mermaid 语法，参考 这儿,FLowchart流程图我们依旧会支持flowchart的流程图：123456789flowchatst=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op关于 Flowchart流程图 语法，参考 这儿.","categories":[{"name":"文档","slug":"文档","permalink":"https://algate.coding.me/categories/文档/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://algate.coding.me/tags/markdown/"}]},{"title":"HTML - 特殊标签和属性(随时更新)","slug":"HTML-特殊标签和属性","date":"2015-07-28T00:31:30.000Z","updated":"2019-03-14T06:47:51.376Z","comments":true,"path":"2015/07/28/HTML-特殊标签和属性/","link":"","permalink":"https://algate.coding.me/2015/07/28/HTML-特殊标签和属性/","excerpt":"1.manifest 页面头部 &lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot;&gt;manifest 属性规定文档的缓存 manifest 的位置。HTML5 引入了应用程序缓存，这意味着 Web 应用程序可以被缓存，然后在无互联网连接的时候进行访问。应用程序缓存使得应用程序有三个优点：离线浏览 - 用户可以在离线时使用应用程序 快速 - 缓存的资源可以更快地加载 减少服务器加载 - 浏览器只从服务器上下载已更新/已更改的资源","text":"1.manifest 页面头部 &lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot;&gt;manifest 属性规定文档的缓存 manifest 的位置。HTML5 引入了应用程序缓存，这意味着 Web 应用程序可以被缓存，然后在无互联网连接的时候进行访问。应用程序缓存使得应用程序有三个优点：离线浏览 - 用户可以在离线时使用应用程序 快速 - 缓存的资源可以更快地加载 减少服务器加载 - 浏览器只从服务器上下载已更新/已更改的资源 manifest 属性应该被 Web 应用程序中您想要缓存的每个页面包含。manifest 文件是一个简单的文本文件，列举出了浏览器用于离线访问而缓存的资源。2.base 单边标签base href=&quot;http://www.w3school.com.cn/i/&quot; base target=&quot;_blank&quot; &lt;base&gt; 标签为页面上的所有链接规定默认地址或默认目标。通常情况下，浏览器会从当前文档的 URL 中提取相应的元素来填写相对 URL 中的空白。使用 &lt;base&gt; 标签可以改变这一点。浏览器随后将不再使用当前文档的 URL，而使用指定的基本 URL 来解析所有的相对 URL。这其中包括 &lt;a&gt;、&lt;img&gt;、&lt;link&gt;、&lt;form&gt; 标签中的 URL。3.meta标签的相关属性&lt;meta http-equiv=&quot;refresh&quot; content=&quot;5; url=&apos;//algate.github.io/&apos;&quot;&gt; 上面meta的功能是, 访问该页面的时候，3秒钟后将自动跳转到url的地址http://blog.csdn.net/cczhumin/article/details/51241609","categories":[{"name":"HTML","slug":"HTML","permalink":"https://algate.coding.me/categories/HTML/"}],"tags":[{"name":"特殊标签","slug":"特殊标签","permalink":"https://algate.coding.me/tags/特殊标签/"}]},{"title":"JS-作用域闭包面向对象","slug":"JS-作用域闭包面向对象","date":"2015-06-06T00:31:30.000Z","updated":"2019-02-27T03:27:59.562Z","comments":true,"path":"2015/06/06/JS-作用域闭包面向对象/","link":"","permalink":"https://algate.coding.me/2015/06/06/JS-作用域闭包面向对象/","excerpt":"作用域js中我们代码运行的环境叫做–作用域作用域：全局作用域(可以加window.)–window；私有作用域–函数执行时产生的作用域；在全局作用域先定义的变量或者（系统自带的一些方法），相当于给全局window增加了一些属性名，我们可以直接写或者window.a都没有问题，不写默认window. ;console.log(a);–a is not defined;–预解释的时候没有找到a；a=12;预解释：js代码执行之前，带var和function关键字的提前声明declare（定义），然后找完了，从上往下执行；预解释只发生在当前作用域var的预解释：—-代码执行之前先声明(只声明并没有赋值–定义undefined)—-从上往下执行代码—-声明的变量和值进行关联","text":"作用域js中我们代码运行的环境叫做–作用域作用域：全局作用域(可以加window.)–window；私有作用域–函数执行时产生的作用域；在全局作用域先定义的变量或者（系统自带的一些方法），相当于给全局window增加了一些属性名，我们可以直接写或者window.a都没有问题，不写默认window. ;console.log(a);–a is not defined;–预解释的时候没有找到a；a=12;预解释：js代码执行之前，带var和function关键字的提前声明declare（定义），然后找完了，从上往下执行；预解释只发生在当前作用域var的预解释：—-代码执行之前先声明(只声明并没有赋值–定义undefined)—-从上往下执行代码—-声明的变量和值进行关联function的预解释：—-代码执行前先声明declare，但是和var不同的是，funciton连定义也完成了；—-函数作用域中，没有声明只是赋值的话，改变的是全局作用域下的变量；在函数作用域下，也要进行预解释，如果函数内部有var和funciton的声明变量，形成函数的私有作用域，如果找不到，就往上一级的作用域里找，一直到window下的作用域，如果还找不到，就会报一个未定义的错误；1预解释发现相重的，不重复声明；（只声明不代表不定义–遇到函数fn=3；function fn(){};（就是所谓的函数的优先级高）执行 的是函数的）函数不仅声明还定义了；；2预解释是不管条件的；3预解释只解释等号左边的，不预解释右边的；var fn=function a(){};4function中return后面的返回值(包括函数)，不进行预解释；5预解释只发生在一个脚本块中；6函数中的形参相当于私有作用域下声明了一个变量，进行了预解释；7闭包格式的函数–不进行预解释的预解释：找var和function123456var a=12;function a()&#123; var a=13;console.log(a);&#125;a=a();console.log(a);声明了a，遇到function发现已经声明了，function还有定义， 预解释声明--var a；a=function(){}; 执行：a=12;a=12(){}--number is not function 作用域：函数没有执行的时候没有任何的意义开辟一个新的内存，里面存储的是我们看上去像代码的字符串，然后函数里面存储的是对新的内存地址的访问函数执行的时候，会形成一个私有的作用域(和我们开始的window类似)，首先也是预解释，接下来从上往下执行代码–正常情况下，我们一个function的生命周期：出生：从预解释开始声明加定义-开辟一个新的内存块，让函数名存贮对这个内存块的引用地址成长：函数执行，形成一个私有作用域，然后里面开始类似与window的新一轮预解释，代码从上到下执行；死亡：一般情况下，私有作用域下的代码完成后，整个私有作用域就销毁了；函数执行形成一个私有作用域，保护里面的变量不受外界的干扰(外面拿不到也修改不了)–这种机制叫做闭包；–一个function运行的时候，会形成一个私有的作用域，如果这个没有返回一个function(外面没有其他的东西占用他的内存的话)，这个私有作用域执行完会自动销毁了，但是如果返回了一个funciton，而且之后函数外面还用到了这个function的话，那么这个函数是销毁不了的；–(一个函数是从形参开始执行的)this:[1]this和在哪定义和在哪执行没有半毛钱关系，和(函数执行时候的主体–主体是谁就是谁&lt;主体就是.前面的&gt;)有关系，没有的话默认的是window，而且this只出现在function中&amp;或者全局作用域下；[2]绑定事件：谁绑定的主体就是谁[3]闭包：主体是window改变this关键字的方法1.call和apply函数体.call(主体，形参，值，值)--一个一个 函数体.apply(主体，[形参，值，值])--数组的形式 call方法的第一个参数，是指函数运行是this的指向 从第二个参数开始，这些参数一次传给函数，传给函数的参数是以散列的方式存在的 apply方法最多只有两个参数，第一个参数和call相同，第二个参数是一个集合(数组)，把整个集合传给函数方法，第二个参数相当于函数的arguments； call的特殊用法：fn.call(null)--如果一个方法和函数不能确定主体是谁，或者this指向了一个不存在的对象(null或undefined)则this指的是window； apply的特殊用法：–找出数组中最大值和最小值Math.min(12,3,34,5,3,7,8,4,23,15)--Math.min的参数是一个个传进去的(散列式的),不能是数组； Matn.min(a)--错误的，不能是一个变量； Math.min.apply(null,a);--用apply传递的第二个参数是一个集合特点，把a这个集合，以整体的方式传给了min； 2.传递this主体下声明var that=this 函数中的 this--&gt;that(执行的时候没有声明向上级找--找到的是主体中的this) 用instanceof 不能够严格的判断一个实例是不是这个类的实例 123function isArray(obj)&#123; return Object.prototype.toString.call(obj)==&quot;[object Array]&quot;;&#125; 面向对象：实例创建对象：(1)单例模式–需要手动一个个创建；(避免使用全局变量或者全局的方法导致冲突，我们把需要的方法和变量当作对象数据类型的属性名和属性值存起来，每次执行的时候，对象.属性名就可以了，解决全局下的冲突问题)；—–命名空间：我们把创建的那个对象名称之为命名空间；第二种情况：12345678910var obj=(function()&#123; var a=&quot;&quot;; function check()&#123; &#125;; function submit()&#123; &#125;; return &#123;check:check,submit:submit&#125;;&#125;)();obj.check();obj.submit();(2)工厂模式--为了解决单例模式一个个生产的问题，实现批量生产 构造一个函数，函数里var一个obj对象，把方法和变量当作对象数据类型的属性名和属性值存起来，然后把obj返回；(3)构造函数–实例识别（差异）对象、类、实例js对象是一种复合类型，通过变量名存储和访问，对象是一个无序的属性集合类是对象的细分，只需要new操作符就可以实现一个实例；工厂模式和构造函数的区别：不需要手动创建obj对象了，而且也不用return obj对象了；原先obj统一替换成this（this是谁）[4]跟创建的实例有关系，创建的实例是谁，this就是谁执行：定义变量=new 函数名(参数值)我们把执行函数的时候，用new创建的方式称之为构造函数模式（实例创建方式），通过这种方式，我们把原先的那个函数称之为类，把返回的结果(就是var的那个变量)称之为这个类的一个实例构造函数new执行过程：返回的实例也是一个对象数据类型；也就是说，new一个函数的时候，首先会默认创建一个对象，也就是我们创建的实例(变量)；接下来会以实例(this)作为上下文，把对应的属性存起来；返回的时候，实例就拥有了这些属性名和属性值；默认的把我们创建的对象给我们的实例（变量名）–也就是我们创建的实例就是我们要的对象，换句话说this就是我们创建的这个实例检测实例：instanceof–用来检测某一个实例是否是属于某个类的，属于返回true，不属于返回false；Js内置类：String，Object，Array，Number，Math，Date，RegExpJs中所有的对象数据类型都是内置Object类的一个实例(4)基于构造函数的原型链模式：–解决产品差异化的同时，有相同的部分还可以共享———-构造函数不足：很多通用的方法没有实现共享，函数里边的相同方法一样才对，但是现有的构造函数模式，实现不了；将需要共享的属性写在原型链prototype上，这样prototype上所定义的属性和方法就可以被一个类的实例共享了；prototype原理：每一个function都有一个天生自带的属性prototype，如果不是构造函数(new 函数)的话，这个函数没有任何意义；prototype存储的是一个对象数据类型，有自己的内存块，并且这个内存块上又有两个自带的属性constructor,proto；constructor是prototype这个对象数据类型特有的，而proto是所有对象数据类型都有的；当我们new一个函数的时候，函数变成了类，并且返回一个实例，这个实例是对象数据类型的，所以有proto这个自带的属性，并且这个属性指向的是我们函数里面prototype自己的那个内存地址—-所以我们变量（new）除了拥有函数里面自带的私有属性的时候，拥有了原型链proto属性；一个对象被创建时,它的 proto 属性和内部属性[[Prototype]]指向了相同的对象 (也就是它的构造函数的prototype属性).改变proto 属性的值同时也会改变内部属性[[Prototype]]的值;我们在调用实例上的属性名的时候，遵循这样顺序：先找私有的，私有的没有，在通过proto所在的类的原型上，如果在私有的中找到了，就不再往下找了；hasOwnProperty–检测某个实例上是否存在某个属性（是私有属性才有效，原型链上的无法检测）isPrototypeOf–检测原型链的对象是否存在于指定的对象实例中Fn.prototype.isPrototypeOf(实例)——trueFn.isPrototypeOf————————–falsehasOwnProperty()与for in的区别1 in 判断某个对象中有没有某个属性–不管私有还是共有的；(属性名 in 实例)2 hasOwnProperty()只能检测自定义属性，无法检测原型链属性。我们常用的一些内置的类 如：String Array 等提供的方法都是在原型上的“str”.hasOwnProperty(“split”);//falseString.prototype.hasOwnProperty(“split”);//true只检测公有的属性–return !obj.hasOwnPorperty(key)&amp;&amp;(key in obj);js中我们常用的this的几种情况：【】给元素绑定事件oDiv.onclick=function(){}；this就是oDiv；【】闭包(function(){this是window})()；【】函数执行前的主体 fn()–&gt;window obj.fn()–&gt;obj；【】当一构造函数执行的时候，this就是我们创建的那个实例；所有的对象数据类型都是内置Object类的一个实例","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://algate.coding.me/categories/Javascript/"}],"tags":[{"name":"作用域闭包面向对象","slug":"作用域闭包面向对象","permalink":"https://algate.coding.me/tags/作用域闭包面向对象/"}]},{"title":"HTML - 浏览器icon的不同支持","slug":"HTML-浏览器对icon的支持","date":"2015-06-06T00:31:30.000Z","updated":"2019-02-27T03:27:59.547Z","comments":true,"path":"2015/06/06/HTML-浏览器对icon的支持/","link":"","permalink":"https://algate.coding.me/2015/06/06/HTML-浏览器对icon的支持/","excerpt":"页面中引用icon一般情况下都是link标签实现的123&lt;link href=&quot;%PUBLIC_URL%/favicon.ico&quot; mce_href=&quot;%PUBLIC_URL%/favicon.ico&quot; rel=&quot;icon&quot; type=&quot;image/x-icon&quot; /&gt;&lt;link href=&quot;%PUBLIC_URL%/favicon.ico&quot; mce_href=&quot;%PUBLIC_URL%/favicon.ico&quot; rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; /&gt;&lt;link href=&quot;%PUBLIC_URL%/favicon.svg&quot; mce_href=&quot;%PUBLIC_URL%/favicon.svg&quot; rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; /&gt;chrome下没有要求，只需要link找到href就ok了，不能加载svg和gif动画fireworks 下就好多了，可以加载svg，把svg做成动画相当漂亮IE我就懒的想说了，但是要想在IE下显示icon，需要强调的是1.必须是icon，2.rel识别的是”icon” 不加shortcut，3.type的值必须为“image/x-icon”","text":"页面中引用icon一般情况下都是link标签实现的123&lt;link href=&quot;%PUBLIC_URL%/favicon.ico&quot; mce_href=&quot;%PUBLIC_URL%/favicon.ico&quot; rel=&quot;icon&quot; type=&quot;image/x-icon&quot; /&gt;&lt;link href=&quot;%PUBLIC_URL%/favicon.ico&quot; mce_href=&quot;%PUBLIC_URL%/favicon.ico&quot; rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; /&gt;&lt;link href=&quot;%PUBLIC_URL%/favicon.svg&quot; mce_href=&quot;%PUBLIC_URL%/favicon.svg&quot; rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; /&gt;chrome下没有要求，只需要link找到href就ok了，不能加载svg和gif动画fireworks 下就好多了，可以加载svg，把svg做成动画相当漂亮IE我就懒的想说了，但是要想在IE下显示icon，需要强调的是1.必须是icon，2.rel识别的是”icon” 不加shortcut，3.type的值必须为“image/x-icon”","categories":[{"name":"HTML","slug":"HTML","permalink":"https://algate.coding.me/categories/HTML/"}],"tags":[{"name":"icon","slug":"icon","permalink":"https://algate.coding.me/tags/icon/"}]},{"title":"删除系统找不到的文件","slug":"compute-删除系统找不到的文件","date":"2015-01-02T09:31:30.000Z","updated":"2019-02-27T03:27:59.647Z","comments":true,"path":"2015/01/02/compute-删除系统找不到的文件/","link":"","permalink":"https://algate.coding.me/2015/01/02/compute-删除系统找不到的文件/","excerpt":"删除系统找不到文件编辑一个记事本，写入下边的代码DEL /F /A /Q \\\\?\\%1 RD /S /Q \\\\?\\%1 保存为bat文件格式文件把系统不存在的文件拖到该bat文件上。你就会发现神奇的事情!","text":"删除系统找不到文件编辑一个记事本，写入下边的代码DEL /F /A /Q \\\\?\\%1 RD /S /Q \\\\?\\%1 保存为bat文件格式文件把系统不存在的文件拖到该bat文件上。你就会发现神奇的事情!","categories":[{"name":"计算机","slug":"计算机","permalink":"https://algate.coding.me/categories/计算机/"}],"tags":[{"name":"删除文件","slug":"删除文件","permalink":"https://algate.coding.me/tags/删除文件/"}]}]}